function __vite__mapDeps(indexes) {
    if (!__vite__mapDeps.viteFileDeps) {
        __vite__mapDeps.viteFileDeps = ["./D1GKVMkh.js", "./kzQ2YxOD.js", "./CJrNJHe2.js", "./DeDRPzjy.js", "./ZuwYCTpL.js", "./Dqfqtkbx.js", "./BwjMfCJ9.js", "./Do7bsGti.js", "./DnvamY80.js", "./index.9CoR1Opm.css", "./CpHqOkQN.js", "./privacy.CC1Tp0W6.css", "./DeZxFPLG.js", "./tos.Bb-WFyiZ.css", "./DHDguVmz.js", "./wtf.o69bQqfL.css", "./D0eSoN2t.js", "./ConnectWalletModal.BXZueGfx.css", "./Dn4Y3_gJ.js", "./AOrSYlDQ.js", "./g6v5y6dW.js", "./BsYmvPZw.js", "./Cu0h6SY2.js", "./KYTQi-wr.js", "./DPU2PXKN.js", "./CaVQExbI.js", "./CJZAWsTM.js", "./B4c7Ua3S.js", "./Bb3LV7NO.js", "./CeFiirrS.js", "./8LqkhGLL.js", "./DHiIC4D1.js", "./ProsePre.CchFRBtv.css", "./CkbLC2tE.js", "./YzQ7Yq7Z.js", "./IconCSS.BjSdL5Bl.css", "./B8pLC7Uw.js", "./sAPkX2kl.js", "./DvqQbgx0.js", "./BDy-5V57.js", "./DDJ9bMxJ.js"]
    }
    return indexes.map( (i) => __vite__mapDeps.viteFileDeps[i])
}
var J6 = Object.defineProperty;
var X6 = (e, t, r) => t in e ? J6(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r;
var Xt = (e, t, r) => (X6(e, typeof t != "symbol" ? t + "" : t, r),
r)
  , Hd = (e, t, r) => {
    if (!t.has(e))
        throw TypeError("Cannot " + r)
}
;
var le = (e, t, r) => (Hd(e, t, "read from private field"),
r ? r.call(e) : t.get(e))
  , Xe = (e, t, r) => {
    if (t.has(e))
        throw TypeError("Cannot add the same private member more than once");
    t instanceof WeakSet ? t.add(e) : t.set(e, r)
}
  , Fe = (e, t, r, n) => (Hd(e, t, "write to private field"),
n ? n.call(e, r) : t.set(e, r),
r);
var bc = (e, t, r, n) => ({
    set _(i) {
        Fe(e, t, i, r)
    },
    get _() {
        return le(e, t, n)
    }
})
  , fr = (e, t, r) => (Hd(e, t, "access private method"),
r);
/**
* @vue/shared v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Fp(e, t) {
    const r = new Set(e.split(","));
    return t ? n => r.has(n.toLowerCase()) : n => r.has(n)
}
const mt = {}
  , wo = []
  , un = () => {}
  , eE = () => !1
  , Ku = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97)
  , Hp = e => e.startsWith("onUpdate:")
  , Zt = Object.assign
  , qp = (e, t) => {
    const r = e.indexOf(t);
    r > -1 && e.splice(r, 1)
}
  , tE = Object.prototype.hasOwnProperty
  , Ye = (e, t) => tE.call(e, t)
  , Oe = Array.isArray
  , vo = e => Gu(e) === "[object Map]"
  , jw = e => Gu(e) === "[object Set]"
  , rE = e => Gu(e) === "[object RegExp]"
  , Pe = e => typeof e == "function"
  , xt = e => typeof e == "string"
  , aa = e => typeof e == "symbol"
  , lt = e => e !== null && typeof e == "object"
  , Wp = e => (lt(e) || Pe(e)) && Pe(e.then) && Pe(e.catch)
  , Dw = Object.prototype.toString
  , Gu = e => Dw.call(e)
  , nE = e => Gu(e).slice(8, -1)
  , Uw = e => Gu(e) === "[object Object]"
  , Vp = e => xt(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e
  , xo = Fp(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , _f = e => {
    const t = Object.create(null);
    return r => t[r] || (t[r] = e(r))
}
  , iE = /-(\w)/g
  , Hn = _f(e => e.replace(iE, (t, r) => r ? r.toUpperCase() : ""))
  , sE = /\B([A-Z])/g
  , Ys = _f(e => e.replace(sE, "-$1").toLowerCase())
  , Af = _f(e => e.charAt(0).toUpperCase() + e.slice(1))
  , qd = _f(e => e ? `on${Af(e)}` : "")
  , rs = (e, t) => !Object.is(e, t)
  , Fa = (e, t) => {
    for (let r = 0; r < e.length; r++)
        e[r](t)
}
  , kl = (e, t, r) => {
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !1,
        value: r
    })
}
  , oE = e => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
}
  , zw = e => {
    const t = xt(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t
}
;
let Jm;
const $w = () => Jm || (Jm = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function zs(e) {
    if (Oe(e)) {
        const t = {};
        for (let r = 0; r < e.length; r++) {
            const n = e[r]
              , i = xt(n) ? lE(n) : zs(n);
            if (i)
                for (const s in i)
                    t[s] = i[s]
        }
        return t
    } else if (xt(e) || lt(e))
        return e
}
const aE = /;(?![^(]*\))/g
  , uE = /:([^]+)/
  , cE = /\/\*[^]*?\*\//g;
function lE(e) {
    const t = {};
    return e.replace(cE, "").split(aE).forEach(r => {
        if (r) {
            const n = r.split(uE);
            n.length > 1 && (t[n[0].trim()] = n[1].trim())
        }
    }
    ),
    t
}
function ot(e) {
    let t = "";
    if (xt(e))
        t = e;
    else if (Oe(e))
        for (let r = 0; r < e.length; r++) {
            const n = ot(e[r]);
            n && (t += n + " ")
        }
    else if (lt(e))
        for (const r in e)
            e[r] && (t += r + " ");
    return t.trim()
}
function Q0(e) {
    if (!e)
        return null;
    let {class: t, style: r} = e;
    return t && !xt(t) && (e.class = ot(t)),
    r && (e.style = zs(r)),
    e
}
const fE = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , dE = Fp(fE);
function Fw(e) {
    return !!e || e === ""
}
const Ns = e => xt(e) ? e : e == null ? "" : Oe(e) || lt(e) && (e.toString === Dw || !Pe(e.toString)) ? JSON.stringify(e, Hw, 2) : String(e)
  , Hw = (e, t) => t && t.__v_isRef ? Hw(e, t.value) : vo(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce( (r, [n,i], s) => (r[Wd(n, s) + " =>"] = i,
    r), {})
} : jw(t) ? {
    [`Set(${t.size})`]: [...t.values()].map(r => Wd(r))
} : aa(t) ? Wd(t) : lt(t) && !Oe(t) && !Uw(t) ? String(t) : t
  , Wd = (e, t="") => {
    var r;
    return aa(e) ? `Symbol(${(r = e.description) != null ? r : t})` : e
}
;
/**
* @vue/reactivity v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let qr;
class qw {
    constructor(t=!1) {
        this.detached = t,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this.parent = qr,
        !t && qr && (this.index = (qr.scopes || (qr.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(t) {
        if (this._active) {
            const r = qr;
            try {
                return qr = this,
                t()
            } finally {
                qr = r
            }
        }
    }
    on() {
        qr = this
    }
    off() {
        qr = this.parent
    }
    stop(t) {
        if (this._active) {
            let r, n;
            for (r = 0,
            n = this.effects.length; r < n; r++)
                this.effects[r].stop();
            for (r = 0,
            n = this.cleanups.length; r < n; r++)
                this.cleanups[r]();
            if (this.scopes)
                for (r = 0,
                n = this.scopes.length; r < n; r++)
                    this.scopes[r].stop(!0);
            if (!this.detached && this.parent && !t) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i,
                i.index = this.index)
            }
            this.parent = void 0,
            this._active = !1
        }
    }
}
function Mf(e) {
    return new qw(e)
}
function hE(e, t=qr) {
    t && t.active && t.effects.push(e)
}
function If() {
    return qr
}
function Kp(e) {
    qr && qr.cleanups.push(e)
}
let Rs;
class Gp {
    constructor(t, r, n, i) {
        this.fn = t,
        this.trigger = r,
        this.scheduler = n,
        this.active = !0,
        this.deps = [],
        this._dirtyLevel = 4,
        this._trackId = 0,
        this._runnings = 0,
        this._shouldSchedule = !1,
        this._depsLength = 0,
        hE(this, i)
    }
    get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1,
            Zs();
            for (let t = 0; t < this._depsLength; t++) {
                const r = this.deps[t];
                if (r.computed && (pE(r.computed),
                this._dirtyLevel >= 4))
                    break
            }
            this._dirtyLevel === 1 && (this._dirtyLevel = 0),
            Js()
        }
        return this._dirtyLevel >= 4
    }
    set dirty(t) {
        this._dirtyLevel = t ? 4 : 0
    }
    run() {
        if (this._dirtyLevel = 0,
        !this.active)
            return this.fn();
        let t = Qi
          , r = Rs;
        try {
            return Qi = !0,
            Rs = this,
            this._runnings++,
            Xm(this),
            this.fn()
        } finally {
            e1(this),
            this._runnings--,
            Rs = r,
            Qi = t
        }
    }
    stop() {
        var t;
        this.active && (Xm(this),
        e1(this),
        (t = this.onStop) == null || t.call(this),
        this.active = !1)
    }
}
function pE(e) {
    return e.value
}
function Xm(e) {
    e._trackId++,
    e._depsLength = 0
}
function e1(e) {
    if (e.deps.length > e._depsLength) {
        for (let t = e._depsLength; t < e.deps.length; t++)
            Ww(e.deps[t], e);
        e.deps.length = e._depsLength
    }
}
function Ww(e, t) {
    const r = e.get(t);
    r !== void 0 && t._trackId !== r && (e.delete(t),
    e.size === 0 && e.cleanup())
}
let Qi = !0
  , Y0 = 0;
const Vw = [];
function Zs() {
    Vw.push(Qi),
    Qi = !1
}
function Js() {
    const e = Vw.pop();
    Qi = e === void 0 ? !0 : e
}
function Qp() {
    Y0++
}
function Yp() {
    for (Y0--; !Y0 && Z0.length; )
        Z0.shift()()
}
function Kw(e, t, r) {
    if (t.get(e) !== e._trackId) {
        t.set(e, e._trackId);
        const n = e.deps[e._depsLength];
        n !== t ? (n && Ww(n, e),
        e.deps[e._depsLength++] = t) : e._depsLength++
    }
}
const Z0 = [];
function Gw(e, t, r) {
    Qp();
    for (const n of e.keys()) {
        let i;
        n._dirtyLevel < t && (i ?? (i = e.get(n) === n._trackId)) && (n._shouldSchedule || (n._shouldSchedule = n._dirtyLevel === 0),
        n._dirtyLevel = t),
        n._shouldSchedule && (i ?? (i = e.get(n) === n._trackId)) && (n.trigger(),
        (!n._runnings || n.allowRecurse) && n._dirtyLevel !== 2 && (n._shouldSchedule = !1,
        n.scheduler && Z0.push(n.scheduler)))
    }
    Yp()
}
const Qw = (e, t) => {
    const r = new Map;
    return r.cleanup = e,
    r.computed = t,
    r
}
  , Ll = new WeakMap
  , Bs = Symbol("")
  , J0 = Symbol("");
function Br(e, t, r) {
    if (Qi && Rs) {
        let n = Ll.get(e);
        n || Ll.set(e, n = new Map);
        let i = n.get(r);
        i || n.set(r, i = Qw( () => n.delete(r))),
        Kw(Rs, i)
    }
}
function di(e, t, r, n, i, s) {
    const o = Ll.get(e);
    if (!o)
        return;
    let a = [];
    if (t === "clear")
        a = [...o.values()];
    else if (r === "length" && Oe(e)) {
        const u = Number(n);
        o.forEach( (c, l) => {
            (l === "length" || !aa(l) && l >= u) && a.push(c)
        }
        )
    } else
        switch (r !== void 0 && a.push(o.get(r)),
        t) {
        case "add":
            Oe(e) ? Vp(r) && a.push(o.get("length")) : (a.push(o.get(Bs)),
            vo(e) && a.push(o.get(J0)));
            break;
        case "delete":
            Oe(e) || (a.push(o.get(Bs)),
            vo(e) && a.push(o.get(J0)));
            break;
        case "set":
            vo(e) && a.push(o.get(Bs));
            break
        }
    Qp();
    for (const u of a)
        u && Gw(u, 4);
    Yp()
}
function gE(e, t) {
    var r;
    return (r = Ll.get(e)) == null ? void 0 : r.get(t)
}
const mE = Fp("__proto__,__v_isRef,__isVue")
  , Yw = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(aa))
  , t1 = yE();
function yE() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(t => {
        e[t] = function(...r) {
            const n = Ke(this);
            for (let s = 0, o = this.length; s < o; s++)
                Br(n, "get", s + "");
            const i = n[t](...r);
            return i === -1 || i === !1 ? n[t](...r.map(Ke)) : i
        }
    }
    ),
    ["push", "pop", "shift", "unshift", "splice"].forEach(t => {
        e[t] = function(...r) {
            Zs(),
            Qp();
            const n = Ke(this)[t].apply(this, r);
            return Yp(),
            Js(),
            n
        }
    }
    ),
    e
}
function bE(e) {
    const t = Ke(this);
    return Br(t, "has", e),
    t.hasOwnProperty(e)
}
class Zw {
    constructor(t=!1, r=!1) {
        this._isReadonly = t,
        this._isShallow = r
    }
    get(t, r, n) {
        const i = this._isReadonly
          , s = this._isShallow;
        if (r === "__v_isReactive")
            return !i;
        if (r === "__v_isReadonly")
            return i;
        if (r === "__v_isShallow")
            return s;
        if (r === "__v_raw")
            return n === (i ? s ? LE : tv : s ? ev : Xw).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(n) ? t : void 0;
        const o = Oe(t);
        if (!i) {
            if (o && Ye(t1, r))
                return Reflect.get(t1, r, n);
            if (r === "hasOwnProperty")
                return bE
        }
        const a = Reflect.get(t, r, n);
        return (aa(r) ? Yw.has(r) : mE(r)) || (i || Br(t, "get", r),
        s) ? a : bt(a) ? o && Vp(r) ? a : a.value : lt(a) ? i ? Yu(a) : Vn(a) : a
    }
}
class Jw extends Zw {
    constructor(t=!1) {
        super(!1, t)
    }
    set(t, r, n, i) {
        let s = t[r];
        if (!this._isShallow) {
            const u = $s(s);
            if (!Ol(n) && !$s(n) && (s = Ke(s),
            n = Ke(n)),
            !Oe(t) && bt(s) && !bt(n))
                return u ? !1 : (s.value = n,
                !0)
        }
        const o = Oe(t) && Vp(r) ? Number(r) < t.length : Ye(t, r)
          , a = Reflect.set(t, r, n, i);
        return t === Ke(i) && (o ? rs(n, s) && di(t, "set", r, n) : di(t, "add", r, n)),
        a
    }
    deleteProperty(t, r) {
        const n = Ye(t, r);
        t[r];
        const i = Reflect.deleteProperty(t, r);
        return i && n && di(t, "delete", r, void 0),
        i
    }
    has(t, r) {
        const n = Reflect.has(t, r);
        return (!aa(r) || !Yw.has(r)) && Br(t, "has", r),
        n
    }
    ownKeys(t) {
        return Br(t, "iterate", Oe(t) ? "length" : Bs),
        Reflect.ownKeys(t)
    }
}
class wE extends Zw {
    constructor(t=!1) {
        super(!0, t)
    }
    set(t, r) {
        return !0
    }
    deleteProperty(t, r) {
        return !0
    }
}
const vE = new Jw
  , xE = new wE
  , EE = new Jw(!0)
  , Zp = e => e
  , Tf = e => Reflect.getPrototypeOf(e);
function wc(e, t, r=!1, n=!1) {
    e = e.__v_raw;
    const i = Ke(e)
      , s = Ke(t);
    r || (rs(t, s) && Br(i, "get", t),
    Br(i, "get", s));
    const {has: o} = Tf(i)
      , a = n ? Zp : r ? eg : iu;
    if (o.call(i, t))
        return a(e.get(t));
    if (o.call(i, s))
        return a(e.get(s));
    e !== i && e.get(t)
}
function vc(e, t=!1) {
    const r = this.__v_raw
      , n = Ke(r)
      , i = Ke(e);
    return t || (rs(e, i) && Br(n, "has", e),
    Br(n, "has", i)),
    e === i ? r.has(e) : r.has(e) || r.has(i)
}
function xc(e, t=!1) {
    return e = e.__v_raw,
    !t && Br(Ke(e), "iterate", Bs),
    Reflect.get(e, "size", e)
}
function r1(e) {
    e = Ke(e);
    const t = Ke(this);
    return Tf(t).has.call(t, e) || (t.add(e),
    di(t, "add", e, e)),
    this
}
function n1(e, t) {
    t = Ke(t);
    const r = Ke(this)
      , {has: n, get: i} = Tf(r);
    let s = n.call(r, e);
    s || (e = Ke(e),
    s = n.call(r, e));
    const o = i.call(r, e);
    return r.set(e, t),
    s ? rs(t, o) && di(r, "set", e, t) : di(r, "add", e, t),
    this
}
function i1(e) {
    const t = Ke(this)
      , {has: r, get: n} = Tf(t);
    let i = r.call(t, e);
    i || (e = Ke(e),
    i = r.call(t, e)),
    n && n.call(t, e);
    const s = t.delete(e);
    return i && di(t, "delete", e, void 0),
    s
}
function s1() {
    const e = Ke(this)
      , t = e.size !== 0
      , r = e.clear();
    return t && di(e, "clear", void 0, void 0),
    r
}
function Ec(e, t) {
    return function(n, i) {
        const s = this
          , o = s.__v_raw
          , a = Ke(o)
          , u = t ? Zp : e ? eg : iu;
        return !e && Br(a, "iterate", Bs),
        o.forEach( (c, l) => n.call(i, u(c), u(l), s))
    }
}
function Sc(e, t, r) {
    return function(...n) {
        const i = this.__v_raw
          , s = Ke(i)
          , o = vo(s)
          , a = e === "entries" || e === Symbol.iterator && o
          , u = e === "keys" && o
          , c = i[e](...n)
          , l = r ? Zp : t ? eg : iu;
        return !t && Br(s, "iterate", u ? J0 : Bs),
        {
            next() {
                const {value: p, done: h} = c.next();
                return h ? {
                    value: p,
                    done: h
                } : {
                    value: a ? [l(p[0]), l(p[1])] : l(p),
                    done: h
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function Ei(e) {
    return function(...t) {
        return e === "delete" ? !1 : e === "clear" ? void 0 : this
    }
}
function SE() {
    const e = {
        get(s) {
            return wc(this, s)
        },
        get size() {
            return xc(this)
        },
        has: vc,
        add: r1,
        set: n1,
        delete: i1,
        clear: s1,
        forEach: Ec(!1, !1)
    }
      , t = {
        get(s) {
            return wc(this, s, !1, !0)
        },
        get size() {
            return xc(this)
        },
        has: vc,
        add: r1,
        set: n1,
        delete: i1,
        clear: s1,
        forEach: Ec(!1, !0)
    }
      , r = {
        get(s) {
            return wc(this, s, !0)
        },
        get size() {
            return xc(this, !0)
        },
        has(s) {
            return vc.call(this, s, !0)
        },
        add: Ei("add"),
        set: Ei("set"),
        delete: Ei("delete"),
        clear: Ei("clear"),
        forEach: Ec(!0, !1)
    }
      , n = {
        get(s) {
            return wc(this, s, !0, !0)
        },
        get size() {
            return xc(this, !0)
        },
        has(s) {
            return vc.call(this, s, !0)
        },
        add: Ei("add"),
        set: Ei("set"),
        delete: Ei("delete"),
        clear: Ei("clear"),
        forEach: Ec(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        e[s] = Sc(s, !1, !1),
        r[s] = Sc(s, !0, !1),
        t[s] = Sc(s, !1, !0),
        n[s] = Sc(s, !0, !0)
    }
    ),
    [e, r, t, n]
}
const [_E,AE,ME,IE] = SE();
function Jp(e, t) {
    const r = t ? e ? IE : ME : e ? AE : _E;
    return (n, i, s) => i === "__v_isReactive" ? !e : i === "__v_isReadonly" ? e : i === "__v_raw" ? n : Reflect.get(Ye(r, i) && i in n ? r : n, i, s)
}
const TE = {
    get: Jp(!1, !1)
}
  , CE = {
    get: Jp(!1, !0)
}
  , kE = {
    get: Jp(!0, !1)
}
  , Xw = new WeakMap
  , ev = new WeakMap
  , tv = new WeakMap
  , LE = new WeakMap;
function OE(e) {
    switch (e) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function NE(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : OE(nE(e))
}
function Vn(e) {
    return $s(e) ? e : Xp(e, !1, vE, TE, Xw)
}
function Qu(e) {
    return Xp(e, !1, EE, CE, ev)
}
function Yu(e) {
    return Xp(e, !0, xE, kE, tv)
}
function Xp(e, t, r, n, i) {
    if (!lt(e) || e.__v_raw && !(t && e.__v_isReactive))
        return e;
    const s = i.get(e);
    if (s)
        return s;
    const o = NE(e);
    if (o === 0)
        return e;
    const a = new Proxy(e,o === 2 ? n : r);
    return i.set(e, a),
    a
}
function hi(e) {
    return $s(e) ? hi(e.__v_raw) : !!(e && e.__v_isReactive)
}
function $s(e) {
    return !!(e && e.__v_isReadonly)
}
function Ol(e) {
    return !!(e && e.__v_isShallow)
}
function rv(e) {
    return hi(e) || $s(e)
}
function Ke(e) {
    const t = e && e.__v_raw;
    return t ? Ke(t) : e
}
function Cf(e) {
    return Object.isExtensible(e) && kl(e, "__v_skip", !0),
    e
}
const iu = e => lt(e) ? Vn(e) : e
  , eg = e => lt(e) ? Yu(e) : e;
class nv {
    constructor(t, r, n, i) {
        this.getter = t,
        this._setter = r,
        this.dep = void 0,
        this.__v_isRef = !0,
        this.__v_isReadonly = !1,
        this.effect = new Gp( () => t(this._value), () => Ha(this, this.effect._dirtyLevel === 2 ? 2 : 3)),
        this.effect.computed = this,
        this.effect.active = this._cacheable = !i,
        this.__v_isReadonly = n
    }
    get value() {
        const t = Ke(this);
        return (!t._cacheable || t.effect.dirty) && rs(t._value, t._value = t.effect.run()) && Ha(t, 4),
        tg(t),
        t.effect._dirtyLevel >= 2 && Ha(t, 2),
        t._value
    }
    set value(t) {
        this._setter(t)
    }
    get _dirty() {
        return this.effect.dirty
    }
    set _dirty(t) {
        this.effect.dirty = t
    }
}
function RE(e, t, r=!1) {
    let n, i;
    const s = Pe(e);
    return s ? (n = e,
    i = un) : (n = e.get,
    i = e.set),
    new nv(n,i,s || !i,r)
}
function tg(e) {
    var t;
    Qi && Rs && (e = Ke(e),
    Kw(Rs, (t = e.dep) != null ? t : e.dep = Qw( () => e.dep = void 0, e instanceof nv ? e : void 0)))
}
function Ha(e, t=4, r) {
    e = Ke(e);
    const n = e.dep;
    n && Gw(n, t)
}
function bt(e) {
    return !!(e && e.__v_isRef === !0)
}
function Ue(e) {
    return iv(e, !1)
}
function Pr(e) {
    return iv(e, !0)
}
function iv(e, t) {
    return bt(e) ? e : new BE(e,t)
}
class BE {
    constructor(t, r) {
        this.__v_isShallow = r,
        this.dep = void 0,
        this.__v_isRef = !0,
        this._rawValue = r ? t : Ke(t),
        this._value = r ? t : iu(t)
    }
    get value() {
        return tg(this),
        this._value
    }
    set value(t) {
        const r = this.__v_isShallow || Ol(t) || $s(t);
        t = r ? t : Ke(t),
        rs(t, this._rawValue) && (this._rawValue = t,
        this._value = r ? t : iu(t),
        Ha(this, 4))
    }
}
function ct(e) {
    return bt(e) ? e.value : e
}
function Vd(e) {
    return Pe(e) ? e() : ct(e)
}
const PE = {
    get: (e, t, r) => ct(Reflect.get(e, t, r)),
    set: (e, t, r, n) => {
        const i = e[t];
        return bt(i) && !bt(r) ? (i.value = r,
        !0) : Reflect.set(e, t, r, n)
    }
};
function sv(e) {
    return hi(e) ? e : new Proxy(e,PE)
}
class jE {
    constructor(t) {
        this.dep = void 0,
        this.__v_isRef = !0;
        const {get: r, set: n} = t( () => tg(this), () => Ha(this));
        this._get = r,
        this._set = n
    }
    get value() {
        return this._get()
    }
    set value(t) {
        this._set(t)
    }
}
function K$(e) {
    return new jE(e)
}
function ov(e) {
    const t = Oe(e) ? new Array(e.length) : {};
    for (const r in e)
        t[r] = av(e, r);
    return t
}
class DE {
    constructor(t, r, n) {
        this._object = t,
        this._key = r,
        this._defaultValue = n,
        this.__v_isRef = !0
    }
    get value() {
        const t = this._object[this._key];
        return t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
    get dep() {
        return gE(Ke(this._object), this._key)
    }
}
class UE {
    constructor(t) {
        this._getter = t,
        this.__v_isRef = !0,
        this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}
function Xs(e, t, r) {
    return bt(e) ? e : Pe(e) ? new UE(e) : lt(e) && arguments.length > 1 ? av(e, t, r) : Ue(e)
}
function av(e, t, r) {
    const n = e[t];
    return bt(n) ? n : new DE(e,t,r)
}
/**
* @vue/runtime-core v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Yi(e, t, r, n) {
    try {
        return n ? e(...n) : e()
    } catch (i) {
        ua(i, t, r)
    }
}
function dn(e, t, r, n) {
    if (Pe(e)) {
        const s = Yi(e, t, r, n);
        return s && Wp(s) && s.catch(o => {
            ua(o, t, r)
        }
        ),
        s
    }
    const i = [];
    for (let s = 0; s < e.length; s++)
        i.push(dn(e[s], t, r, n));
    return i
}
function ua(e, t, r, n=!0) {
    const i = t ? t.vnode : null;
    if (t) {
        let s = t.parent;
        const o = t.proxy
          , a = `https://vuejs.org/error-reference/#runtime-${r}`;
        for (; s; ) {
            const c = s.ec;
            if (c) {
                for (let l = 0; l < c.length; l++)
                    if (c[l](e, o, a) === !1)
                        return
            }
            s = s.parent
        }
        const u = t.appContext.config.errorHandler;
        if (u) {
            Yi(u, null, 10, [e, o, a]);
            return
        }
    }
    zE(e, r, i, n)
}
function zE(e, t, r, n=!0) {
    console.error(e)
}
let su = !1
  , X0 = !1;
const yr = [];
let Pn = 0;
const Eo = [];
let Bi = null
  , ys = 0;
const uv = Promise.resolve();
let rg = null;
function Kn(e) {
    const t = rg || uv;
    return e ? t.then(this ? e.bind(this) : e) : t
}
function $E(e) {
    let t = Pn + 1
      , r = yr.length;
    for (; t < r; ) {
        const n = t + r >>> 1
          , i = yr[n]
          , s = ou(i);
        s < e || s === e && i.pre ? t = n + 1 : r = n
    }
    return t
}
function kf(e) {
    (!yr.length || !yr.includes(e, su && e.allowRecurse ? Pn + 1 : Pn)) && (e.id == null ? yr.push(e) : yr.splice($E(e.id), 0, e),
    cv())
}
function cv() {
    !su && !X0 && (X0 = !0,
    rg = uv.then(lv))
}
function FE(e) {
    const t = yr.indexOf(e);
    t > Pn && yr.splice(t, 1)
}
function eh(e) {
    Oe(e) ? Eo.push(...e) : (!Bi || !Bi.includes(e, e.allowRecurse ? ys + 1 : ys)) && Eo.push(e),
    cv()
}
function o1(e, t, r=su ? Pn + 1 : 0) {
    for (; r < yr.length; r++) {
        const n = yr[r];
        if (n && n.pre) {
            if (e && n.id !== e.uid)
                continue;
            yr.splice(r, 1),
            r--,
            n()
        }
    }
}
function Nl(e) {
    if (Eo.length) {
        const t = [...new Set(Eo)].sort( (r, n) => ou(r) - ou(n));
        if (Eo.length = 0,
        Bi) {
            Bi.push(...t);
            return
        }
        for (Bi = t,
        ys = 0; ys < Bi.length; ys++)
            Bi[ys]();
        Bi = null,
        ys = 0
    }
}
const ou = e => e.id == null ? 1 / 0 : e.id
  , HE = (e, t) => {
    const r = ou(e) - ou(t);
    if (r === 0) {
        if (e.pre && !t.pre)
            return -1;
        if (t.pre && !e.pre)
            return 1
    }
    return r
}
;
function lv(e) {
    X0 = !1,
    su = !0,
    yr.sort(HE);
    try {
        for (Pn = 0; Pn < yr.length; Pn++) {
            const t = yr[Pn];
            t && t.active !== !1 && Yi(t, null, 14)
        }
    } finally {
        Pn = 0,
        yr.length = 0,
        Nl(),
        su = !1,
        rg = null,
        (yr.length || Eo.length) && lv()
    }
}
function qE(e, t, ...r) {
    if (e.isUnmounted)
        return;
    const n = e.vnode.props || mt;
    let i = r;
    const s = t.startsWith("update:")
      , o = s && t.slice(7);
    if (o && o in n) {
        const l = `${o === "modelValue" ? "model" : o}Modifiers`
          , {number: p, trim: h} = n[l] || mt;
        h && (i = r.map(g => xt(g) ? g.trim() : g)),
        p && (i = r.map(oE))
    }
    let a, u = n[a = qd(t)] || n[a = qd(Hn(t))];
    !u && s && (u = n[a = qd(Ys(t))]),
    u && dn(u, e, 6, i);
    const c = n[a + "Once"];
    if (c) {
        if (!e.emitted)
            e.emitted = {};
        else if (e.emitted[a])
            return;
        e.emitted[a] = !0,
        dn(c, e, 6, i)
    }
}
function fv(e, t, r=!1) {
    const n = t.emitsCache
      , i = n.get(e);
    if (i !== void 0)
        return i;
    const s = e.emits;
    let o = {}
      , a = !1;
    if (!Pe(e)) {
        const u = c => {
            const l = fv(c, t, !0);
            l && (a = !0,
            Zt(o, l))
        }
        ;
        !r && t.mixins.length && t.mixins.forEach(u),
        e.extends && u(e.extends),
        e.mixins && e.mixins.forEach(u)
    }
    return !s && !a ? (lt(e) && n.set(e, null),
    null) : (Oe(s) ? s.forEach(u => o[u] = null) : Zt(o, s),
    lt(e) && n.set(e, o),
    o)
}
function Lf(e, t) {
    return !e || !Ku(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""),
    Ye(e, t[0].toLowerCase() + t.slice(1)) || Ye(e, Ys(t)) || Ye(e, t))
}
let Vt = null
  , Of = null;
function Rl(e) {
    const t = Vt;
    return Vt = e,
    Of = e && e.type.__scopeId || null,
    t
}
function G$(e) {
    Of = e
}
function Q$() {
    Of = null
}
function qn(e, t=Vt, r) {
    if (!t || e._n)
        return e;
    const n = (...i) => {
        n._d && x1(-1);
        const s = Rl(t);
        let o;
        try {
            o = e(...i)
        } finally {
            Rl(s),
            n._d && x1(1)
        }
        return o
    }
    ;
    return n._n = !0,
    n._c = !0,
    n._d = !0,
    n
}
function Kd(e) {
    const {type: t, vnode: r, proxy: n, withProxy: i, props: s, propsOptions: [o], slots: a, attrs: u, emit: c, render: l, renderCache: p, data: h, setupState: g, ctx: S, inheritAttrs: x} = e;
    let v, I;
    const M = Rl(e);
    try {
        if (r.shapeFlag & 4) {
            const k = i || n
              , L = k;
            v = an(l.call(L, k, p, s, g, h, S)),
            I = u
        } else {
            const k = t;
            v = an(k.length > 1 ? k(s, {
                attrs: u,
                slots: a,
                emit: c
            }) : k(s, null)),
            I = t.props ? u : VE(u)
        }
    } catch (k) {
        Va.length = 0,
        ua(k, e, 1),
        v = at(Cr)
    }
    let A = v;
    if (I && x !== !1) {
        const k = Object.keys(I)
          , {shapeFlag: L} = A;
        k.length && L & 7 && (o && k.some(Hp) && (I = KE(I, o)),
        A = gi(A, I))
    }
    return r.dirs && (A = gi(A),
    A.dirs = A.dirs ? A.dirs.concat(r.dirs) : r.dirs),
    r.transition && (A.transition = r.transition),
    v = A,
    Rl(M),
    v
}
function WE(e, t=!0) {
    let r;
    for (let n = 0; n < e.length; n++) {
        const i = e[n];
        if (zo(i)) {
            if (i.type !== Cr || i.children === "v-if") {
                if (r)
                    return;
                r = i
            }
        } else
            return
    }
    return r
}
const VE = e => {
    let t;
    for (const r in e)
        (r === "class" || r === "style" || Ku(r)) && ((t || (t = {}))[r] = e[r]);
    return t
}
  , KE = (e, t) => {
    const r = {};
    for (const n in e)
        (!Hp(n) || !(n.slice(9)in t)) && (r[n] = e[n]);
    return r
}
;
function GE(e, t, r) {
    const {props: n, children: i, component: s} = e
      , {props: o, children: a, patchFlag: u} = t
      , c = s.emitsOptions;
    if (t.dirs || t.transition)
        return !0;
    if (r && u >= 0) {
        if (u & 1024)
            return !0;
        if (u & 16)
            return n ? a1(n, o, c) : !!o;
        if (u & 8) {
            const l = t.dynamicProps;
            for (let p = 0; p < l.length; p++) {
                const h = l[p];
                if (o[h] !== n[h] && !Lf(c, h))
                    return !0
            }
        }
    } else
        return (i || a) && (!a || !a.$stable) ? !0 : n === o ? !1 : n ? o ? a1(n, o, c) : !0 : !!o;
    return !1
}
function a1(e, t, r) {
    const n = Object.keys(t);
    if (n.length !== Object.keys(e).length)
        return !0;
    for (let i = 0; i < n.length; i++) {
        const s = n[i];
        if (t[s] !== e[s] && !Lf(r, s))
            return !0
    }
    return !1
}
function ng({vnode: e, parent: t}, r) {
    for (; t; ) {
        const n = t.subTree;
        if (n.suspense && n.suspense.activeBranch === e && (n.el = e.el),
        n === e)
            (e = t.vnode).el = r,
            t = t.parent;
        else
            break
    }
}
const ig = "components"
  , QE = "directives";
function YE(e, t) {
    return sg(ig, e, !0, t) || e
}
const dv = Symbol.for("v-ndc");
function Nf(e) {
    return xt(e) ? sg(ig, e, !1) || e : e || dv
}
function ZE(e) {
    return sg(QE, e)
}
function sg(e, t, r=!0, n=!1) {
    const i = Vt || Yt;
    if (i) {
        const s = i.type;
        if (e === ig) {
            const a = fh(s, !1);
            if (a && (a === t || a === Hn(t) || a === Af(Hn(t))))
                return s
        }
        const o = u1(i[e] || s[e], t) || u1(i.appContext[e], t);
        return !o && n ? s : o
    }
}
function u1(e, t) {
    return e && (e[t] || e[Hn(t)] || e[Af(Hn(t))])
}
const hv = e => e.__isSuspense;
let th = 0;
const JE = {
    name: "Suspense",
    __isSuspense: !0,
    process(e, t, r, n, i, s, o, a, u, c) {
        if (e == null)
            XE(t, r, n, i, s, o, a, u, c);
        else {
            if (s && s.deps > 0 && !e.suspense.isInFallback) {
                t.suspense = e.suspense,
                t.suspense.vnode = t,
                t.el = e.el;
                return
            }
            eS(e, t, r, n, i, o, a, u, c)
        }
    },
    hydrate: tS,
    create: ag,
    normalize: rS
}
  , og = JE;
function au(e, t) {
    const r = e.props && e.props[t];
    Pe(r) && r()
}
function XE(e, t, r, n, i, s, o, a, u) {
    const {p: c, o: {createElement: l}} = u
      , p = l("div")
      , h = e.suspense = ag(e, i, n, t, p, r, s, o, a, u);
    c(null, h.pendingBranch = e.ssContent, p, null, n, h, s, o),
    h.deps > 0 ? (au(e, "onPending"),
    au(e, "onFallback"),
    c(null, e.ssFallback, t, r, n, null, s, o),
    So(h, e.ssFallback)) : h.resolve(!1, !0)
}
function eS(e, t, r, n, i, s, o, a, {p: u, um: c, o: {createElement: l}}) {
    const p = t.suspense = e.suspense;
    p.vnode = t,
    t.el = e.el;
    const h = t.ssContent
      , g = t.ssFallback
      , {activeBranch: S, pendingBranch: x, isInFallback: v, isHydrating: I} = p;
    if (x)
        p.pendingBranch = h,
        _n(h, x) ? (u(x, h, p.hiddenContainer, null, i, p, s, o, a),
        p.deps <= 0 ? p.resolve() : v && (I || (u(S, g, r, n, i, null, s, o, a),
        So(p, g)))) : (p.pendingId = th++,
        I ? (p.isHydrating = !1,
        p.activeBranch = x) : c(x, i, p),
        p.deps = 0,
        p.effects.length = 0,
        p.hiddenContainer = l("div"),
        v ? (u(null, h, p.hiddenContainer, null, i, p, s, o, a),
        p.deps <= 0 ? p.resolve() : (u(S, g, r, n, i, null, s, o, a),
        So(p, g))) : S && _n(h, S) ? (u(S, h, r, n, i, p, s, o, a),
        p.resolve(!0)) : (u(null, h, p.hiddenContainer, null, i, p, s, o, a),
        p.deps <= 0 && p.resolve()));
    else if (S && _n(h, S))
        u(S, h, r, n, i, p, s, o, a),
        So(p, h);
    else if (au(t, "onPending"),
    p.pendingBranch = h,
    h.shapeFlag & 512 ? p.pendingId = h.component.suspenseId : p.pendingId = th++,
    u(null, h, p.hiddenContainer, null, i, p, s, o, a),
    p.deps <= 0)
        p.resolve();
    else {
        const {timeout: M, pendingId: A} = p;
        M > 0 ? setTimeout( () => {
            p.pendingId === A && p.fallback(g)
        }
        , M) : M === 0 && p.fallback(g)
    }
}
function ag(e, t, r, n, i, s, o, a, u, c, l=!1) {
    const {p, m: h, um: g, n: S, o: {parentNode: x, remove: v}} = c;
    let I;
    const M = nS(e);
    M && t != null && t.pendingBranch && (I = t.pendingId,
    t.deps++);
    const A = e.props ? zw(e.props.timeout) : void 0
      , k = s
      , L = {
        vnode: e,
        parent: t,
        parentComponent: r,
        namespace: o,
        container: n,
        hiddenContainer: i,
        deps: 0,
        pendingId: th++,
        timeout: typeof A == "number" ? A : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !l,
        isHydrating: l,
        isUnmounted: !1,
        effects: [],
        resolve(O=!1, $=!1) {
            const {vnode: D, activeBranch: K, pendingBranch: G, pendingId: F, effects: q, parentComponent: B, container: y} = L;
            let b = !1;
            L.isHydrating ? L.isHydrating = !1 : O || (b = K && G.transition && G.transition.mode === "out-in",
            b && (K.transition.afterLeave = () => {
                F === L.pendingId && (h(G, y, s === k ? S(K) : s, 0),
                eh(q))
            }
            ),
            K && (x(K.el) !== L.hiddenContainer && (s = S(K)),
            g(K, B, L, !0)),
            b || h(G, y, s, 0)),
            So(L, G),
            L.pendingBranch = null,
            L.isInFallback = !1;
            let _ = L.parent
              , T = !1;
            for (; _; ) {
                if (_.pendingBranch) {
                    _.effects.push(...q),
                    T = !0;
                    break
                }
                _ = _.parent
            }
            !T && !b && eh(q),
            L.effects = [],
            M && t && t.pendingBranch && I === t.pendingId && (t.deps--,
            t.deps === 0 && !$ && t.resolve()),
            au(D, "onResolve")
        },
        fallback(O) {
            if (!L.pendingBranch)
                return;
            const {vnode: $, activeBranch: D, parentComponent: K, container: G, namespace: F} = L;
            au($, "onFallback");
            const q = S(D)
              , B = () => {
                L.isInFallback && (p(null, O, G, q, K, null, F, a, u),
                So(L, O))
            }
              , y = O.transition && O.transition.mode === "out-in";
            y && (D.transition.afterLeave = B),
            L.isInFallback = !0,
            g(D, K, null, !0),
            y || B()
        },
        move(O, $, D) {
            L.activeBranch && h(L.activeBranch, O, $, D),
            L.container = O
        },
        next() {
            return L.activeBranch && S(L.activeBranch)
        },
        registerDep(O, $) {
            const D = !!L.pendingBranch;
            D && L.deps++;
            const K = O.vnode.el;
            O.asyncDep.catch(G => {
                ua(G, O, 0)
            }
            ).then(G => {
                if (O.isUnmounted || L.isUnmounted || L.pendingId !== O.suspenseId)
                    return;
                O.asyncResolved = !0;
                const {vnode: F} = O;
                lh(O, G, !1),
                K && (F.el = K);
                const q = !K && O.subTree.el;
                $(O, F, x(K || O.subTree.el), K ? null : S(O.subTree), L, o, u),
                q && v(q),
                ng(O, F.el),
                D && --L.deps === 0 && L.resolve()
            }
            )
        },
        unmount(O, $) {
            L.isUnmounted = !0,
            L.activeBranch && g(L.activeBranch, r, O, $),
            L.pendingBranch && g(L.pendingBranch, r, O, $)
        }
    };
    return L
}
function tS(e, t, r, n, i, s, o, a, u) {
    const c = t.suspense = ag(t, n, r, e.parentNode, document.createElement("div"), null, i, s, o, a, !0)
      , l = u(e, c.pendingBranch = t.ssContent, r, c, s, o);
    return c.deps === 0 && c.resolve(!1, !0),
    l
}
function rS(e) {
    const {shapeFlag: t, children: r} = e
      , n = t & 32;
    e.ssContent = c1(n ? r.default : r),
    e.ssFallback = n ? c1(r.fallback) : at(Cr)
}
function c1(e) {
    let t;
    if (Pe(e)) {
        const r = Uo && e._c;
        r && (e._d = !1,
        je()),
        e = e(),
        r && (e._d = !0,
        t = cn,
        jv())
    }
    return Oe(e) && (e = WE(e)),
    e = an(e),
    t && !e.dynamicChildren && (e.dynamicChildren = t.filter(r => r !== e)),
    e
}
function pv(e, t) {
    t && t.pendingBranch ? Oe(e) ? t.effects.push(...e) : t.effects.push(e) : eh(e)
}
function So(e, t) {
    e.activeBranch = t;
    const {vnode: r, parentComponent: n} = e;
    let i = t.el;
    for (; !i && t.component; )
        t = t.component.subTree,
        i = t.el;
    r.el = i,
    n && n.subTree === r && (n.vnode.el = i,
    ng(n, i))
}
function nS(e) {
    var t;
    return ((t = e.props) == null ? void 0 : t.suspensible) != null && e.props.suspensible !== !1
}
const iS = Symbol.for("v-scx")
  , sS = () => Kt(iS);
function Cn(e, t) {
    return Rf(e, null, t)
}
function oS(e, t) {
    return Rf(e, null, {
        flush: "post"
    })
}
const _c = {};
function vt(e, t, r) {
    return Rf(e, t, r)
}
function Rf(e, t, {immediate: r, deep: n, flush: i, once: s, onTrack: o, onTrigger: a}=mt) {
    if (t && s) {
        const O = t;
        t = (...$) => {
            O(...$),
            L()
        }
    }
    const u = Yt
      , c = O => n === !0 ? O : Es(O, n === !1 ? 1 : void 0);
    let l, p = !1, h = !1;
    if (bt(e) ? (l = () => e.value,
    p = Ol(e)) : hi(e) ? (l = () => c(e),
    p = !0) : Oe(e) ? (h = !0,
    p = e.some(O => hi(O) || Ol(O)),
    l = () => e.map(O => {
        if (bt(O))
            return O.value;
        if (hi(O))
            return c(O);
        if (Pe(O))
            return Yi(O, u, 2)
    }
    )) : Pe(e) ? t ? l = () => Yi(e, u, 2) : l = () => (g && g(),
    dn(e, u, 3, [S])) : l = un,
    t && n) {
        const O = l;
        l = () => Es(O())
    }
    let g, S = O => {
        g = A.onStop = () => {
            Yi(O, u, 4),
            g = A.onStop = void 0
        }
    }
    , x;
    if (Xu)
        if (S = un,
        t ? r && dn(t, u, 3, [l(), h ? [] : void 0, S]) : l(),
        i === "sync") {
            const O = sS();
            x = O.__watcherHandles || (O.__watcherHandles = [])
        } else
            return un;
    let v = h ? new Array(e.length).fill(_c) : _c;
    const I = () => {
        if (!(!A.active || !A.dirty))
            if (t) {
                const O = A.run();
                (n || p || (h ? O.some( ($, D) => rs($, v[D])) : rs(O, v))) && (g && g(),
                dn(t, u, 3, [O, v === _c ? void 0 : h && v[0] === _c ? [] : v, S]),
                v = O)
            } else
                A.run()
    }
    ;
    I.allowRecurse = !!t;
    let M;
    i === "sync" ? M = I : i === "post" ? M = () => or(I, u && u.suspense) : (I.pre = !0,
    u && (I.id = u.uid),
    M = () => kf(I));
    const A = new Gp(l,un,M)
      , k = If()
      , L = () => {
        A.stop(),
        k && qp(k.effects, A)
    }
    ;
    return t ? r ? I() : v = A.run() : i === "post" ? or(A.run.bind(A), u && u.suspense) : A.run(),
    x && x.push(L),
    L
}
function aS(e, t, r) {
    const n = this.proxy
      , i = xt(e) ? e.includes(".") ? gv(n, e) : () => n[e] : e.bind(n, n);
    let s;
    Pe(t) ? s = t : (s = t.handler,
    r = t);
    const o = Fs(this)
      , a = Rf(i, s.bind(n), r);
    return o(),
    a
}
function gv(e, t) {
    const r = t.split(".");
    return () => {
        let n = e;
        for (let i = 0; i < r.length && n; i++)
            n = n[r[i]];
        return n
    }
}
function Es(e, t, r=0, n) {
    if (!lt(e) || e.__v_skip)
        return e;
    if (t && t > 0) {
        if (r >= t)
            return e;
        r++
    }
    if (n = n || new Set,
    n.has(e))
        return e;
    if (n.add(e),
    bt(e))
        Es(e.value, t, r, n);
    else if (Oe(e))
        for (let i = 0; i < e.length; i++)
            Es(e[i], t, r, n);
    else if (jw(e) || vo(e))
        e.forEach(i => {
            Es(i, t, r, n)
        }
        );
    else if (Uw(e))
        for (const i in e)
            Es(e[i], t, r, n);
    return e
}
function uS(e, t) {
    if (Vt === null)
        return e;
    const r = jf(Vt) || Vt.proxy
      , n = e.dirs || (e.dirs = []);
    for (let i = 0; i < t.length; i++) {
        let[s,o,a,u=mt] = t[i];
        s && (Pe(s) && (s = {
            mounted: s,
            updated: s
        }),
        s.deep && Es(o),
        n.push({
            dir: s,
            instance: r,
            value: o,
            oldValue: void 0,
            arg: a,
            modifiers: u
        }))
    }
    return e
}
function On(e, t, r, n) {
    const i = e.dirs
      , s = t && t.dirs;
    for (let o = 0; o < i.length; o++) {
        const a = i[o];
        s && (a.oldValue = s[o].value);
        let u = a.dir[n];
        u && (Zs(),
        dn(u, r, 8, [e.el, a, e, t]),
        Js())
    }
}
const Pi = Symbol("_leaveCb")
  , Ac = Symbol("_enterCb");
function cS() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return vi( () => {
        e.isMounted = !0
    }
    ),
    Ju( () => {
        e.isUnmounting = !0
    }
    ),
    e
}
const en = [Function, Array]
  , mv = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: en,
    onEnter: en,
    onAfterEnter: en,
    onEnterCancelled: en,
    onBeforeLeave: en,
    onLeave: en,
    onAfterLeave: en,
    onLeaveCancelled: en,
    onBeforeAppear: en,
    onAppear: en,
    onAfterAppear: en,
    onAppearCancelled: en
}
  , lS = {
    name: "BaseTransition",
    props: mv,
    setup(e, {slots: t}) {
        const r = Gn()
          , n = cS();
        return () => {
            const i = t.default && bv(t.default(), !0);
            if (!i || !i.length)
                return;
            let s = i[0];
            if (i.length > 1) {
                for (const h of i)
                    if (h.type !== Cr) {
                        s = h;
                        break
                    }
            }
            const o = Ke(e)
              , {mode: a} = o;
            if (n.isLeaving)
                return Gd(s);
            const u = l1(s);
            if (!u)
                return Gd(s);
            const c = rh(u, o, n, r);
            Bl(u, c);
            const l = r.subTree
              , p = l && l1(l);
            if (p && p.type !== Cr && !_n(u, p)) {
                const h = rh(p, o, n, r);
                if (Bl(p, h),
                a === "out-in")
                    return n.isLeaving = !0,
                    h.afterLeave = () => {
                        n.isLeaving = !1,
                        r.update.active !== !1 && (r.effect.dirty = !0,
                        r.update())
                    }
                    ,
                    Gd(s);
                a === "in-out" && u.type !== Cr && (h.delayLeave = (g, S, x) => {
                    const v = yv(n, p);
                    v[String(p.key)] = p,
                    g[Pi] = () => {
                        S(),
                        g[Pi] = void 0,
                        delete c.delayedLeave
                    }
                    ,
                    c.delayedLeave = x
                }
                )
            }
            return s
        }
    }
}
  , fS = lS;
function yv(e, t) {
    const {leavingVNodes: r} = e;
    let n = r.get(t.type);
    return n || (n = Object.create(null),
    r.set(t.type, n)),
    n
}
function rh(e, t, r, n) {
    const {appear: i, mode: s, persisted: o=!1, onBeforeEnter: a, onEnter: u, onAfterEnter: c, onEnterCancelled: l, onBeforeLeave: p, onLeave: h, onAfterLeave: g, onLeaveCancelled: S, onBeforeAppear: x, onAppear: v, onAfterAppear: I, onAppearCancelled: M} = t
      , A = String(e.key)
      , k = yv(r, e)
      , L = (D, K) => {
        D && dn(D, n, 9, K)
    }
      , O = (D, K) => {
        const G = K[1];
        L(D, K),
        Oe(D) ? D.every(F => F.length <= 1) && G() : D.length <= 1 && G()
    }
      , $ = {
        mode: s,
        persisted: o,
        beforeEnter(D) {
            let K = a;
            if (!r.isMounted)
                if (i)
                    K = x || a;
                else
                    return;
            D[Pi] && D[Pi](!0);
            const G = k[A];
            G && _n(e, G) && G.el[Pi] && G.el[Pi](),
            L(K, [D])
        },
        enter(D) {
            let K = u
              , G = c
              , F = l;
            if (!r.isMounted)
                if (i)
                    K = v || u,
                    G = I || c,
                    F = M || l;
                else
                    return;
            let q = !1;
            const B = D[Ac] = y => {
                q || (q = !0,
                y ? L(F, [D]) : L(G, [D]),
                $.delayedLeave && $.delayedLeave(),
                D[Ac] = void 0)
            }
            ;
            K ? O(K, [D, B]) : B()
        },
        leave(D, K) {
            const G = String(e.key);
            if (D[Ac] && D[Ac](!0),
            r.isUnmounting)
                return K();
            L(p, [D]);
            let F = !1;
            const q = D[Pi] = B => {
                F || (F = !0,
                K(),
                B ? L(S, [D]) : L(g, [D]),
                D[Pi] = void 0,
                k[G] === e && delete k[G])
            }
            ;
            k[G] = e,
            h ? O(h, [D, q]) : q()
        },
        clone(D) {
            return rh(D, t, r, n)
        }
    };
    return $
}
function Gd(e) {
    if (Zu(e))
        return e = gi(e),
        e.children = null,
        e
}
function l1(e) {
    return Zu(e) ? e.children ? e.children[0] : void 0 : e
}
function Bl(e, t) {
    e.shapeFlag & 6 && e.component ? Bl(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent),
    e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function bv(e, t=!1, r) {
    let n = []
      , i = 0;
    for (let s = 0; s < e.length; s++) {
        let o = e[s];
        const a = r == null ? o.key : String(r) + String(o.key != null ? o.key : s);
        o.type === tr ? (o.patchFlag & 128 && i++,
        n = n.concat(bv(o.children, t, a))) : (t || o.type !== Cr) && n.push(a != null ? gi(o, {
            key: a
        }) : o)
    }
    if (i > 1)
        for (let s = 0; s < n.length; s++)
            n[s].patchFlag = -2;
    return n
}
/*! #__NO_SIDE_EFFECTS__ */
function lr(e, t) {
    return Pe(e) ? Zt({
        name: e.name
    }, t, {
        setup: e
    }) : e
}
const Ps = e => !!e.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
function qe(e) {
    Pe(e) && (e = {
        loader: e
    });
    const {loader: t, loadingComponent: r, errorComponent: n, delay: i=200, timeout: s, suspensible: o=!0, onError: a} = e;
    let u = null, c, l = 0;
    const p = () => (l++,
    u = null,
    h())
      , h = () => {
        let g;
        return u || (g = u = t().catch(S => {
            if (S = S instanceof Error ? S : new Error(String(S)),
            a)
                return new Promise( (x, v) => {
                    a(S, () => x(p()), () => v(S), l + 1)
                }
                );
            throw S
        }
        ).then(S => g !== u && u ? u : (S && (S.__esModule || S[Symbol.toStringTag] === "Module") && (S = S.default),
        c = S,
        S)))
    }
    ;
    return lr({
        name: "AsyncComponentWrapper",
        __asyncLoader: h,
        get __asyncResolved() {
            return c
        },
        setup() {
            const g = Yt;
            if (c)
                return () => Qd(c, g);
            const S = M => {
                u = null,
                ua(M, g, 13, !n)
            }
            ;
            if (o && g.suspense || Xu)
                return h().then(M => () => Qd(M, g)).catch(M => (S(M),
                () => n ? at(n, {
                    error: M
                }) : null));
            const x = Ue(!1)
              , v = Ue()
              , I = Ue(!!i);
            return i && setTimeout( () => {
                I.value = !1
            }
            , i),
            s != null && setTimeout( () => {
                if (!x.value && !v.value) {
                    const M = new Error(`Async component timed out after ${s}ms.`);
                    S(M),
                    v.value = M
                }
            }
            , s),
            h().then( () => {
                x.value = !0,
                g.parent && Zu(g.parent.vnode) && (g.parent.effect.dirty = !0,
                kf(g.parent.update))
            }
            ).catch(M => {
                S(M),
                v.value = M
            }
            ),
            () => {
                if (x.value && c)
                    return Qd(c, g);
                if (v.value && n)
                    return at(n, {
                        error: v.value
                    });
                if (r && !I.value)
                    return at(r)
            }
        }
    })
}
function Qd(e, t) {
    const {ref: r, props: n, children: i, ce: s} = t.vnode
      , o = at(e, n, i);
    return o.ref = r,
    o.ce = s,
    delete t.vnode.ce,
    o
}
const Zu = e => e.type.__isKeepAlive
  , dS = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(e, {slots: t}) {
        const r = Gn()
          , n = r.ctx;
        if (!n.renderer)
            return () => {
                const M = t.default && t.default();
                return M && M.length === 1 ? M[0] : M
            }
            ;
        const i = new Map
          , s = new Set;
        let o = null;
        const a = r.suspense
          , {renderer: {p: u, m: c, um: l, o: {createElement: p}}} = n
          , h = p("div");
        n.activate = (M, A, k, L, O) => {
            const $ = M.component;
            c(M, A, k, 0, a),
            u($.vnode, M, A, k, $, a, L, M.slotScopeIds, O),
            or( () => {
                $.isDeactivated = !1,
                $.a && Fa($.a);
                const D = M.props && M.props.onVnodeMounted;
                D && kr(D, $.parent, M)
            }
            , a)
        }
        ,
        n.deactivate = M => {
            const A = M.component;
            c(M, h, null, 1, a),
            or( () => {
                A.da && Fa(A.da);
                const k = M.props && M.props.onVnodeUnmounted;
                k && kr(k, A.parent, M),
                A.isDeactivated = !0
            }
            , a)
        }
        ;
        function g(M) {
            Yd(M),
            l(M, r, a, !0)
        }
        function S(M) {
            i.forEach( (A, k) => {
                const L = fh(A.type);
                L && (!M || !M(L)) && x(k)
            }
            )
        }
        function x(M) {
            const A = i.get(M);
            !o || !_n(A, o) ? g(A) : o && Yd(o),
            i.delete(M),
            s.delete(M)
        }
        vt( () => [e.include, e.exclude], ([M,A]) => {
            M && S(k => Pa(M, k)),
            A && S(k => !Pa(A, k))
        }
        , {
            flush: "post",
            deep: !0
        });
        let v = null;
        const I = () => {
            v != null && i.set(v, Zd(r.subTree))
        }
        ;
        return vi(I),
        Ev(I),
        Ju( () => {
            i.forEach(M => {
                const {subTree: A, suspense: k} = r
                  , L = Zd(A);
                if (M.type === L.type && M.key === L.key) {
                    Yd(L);
                    const O = L.component.da;
                    O && or(O, k);
                    return
                }
                g(M)
            }
            )
        }
        ),
        () => {
            if (v = null,
            !t.default)
                return null;
            const M = t.default()
              , A = M[0];
            if (M.length > 1)
                return o = null,
                M;
            if (!zo(A) || !(A.shapeFlag & 4) && !(A.shapeFlag & 128))
                return o = null,
                A;
            let k = Zd(A);
            const L = k.type
              , O = fh(Ps(k) ? k.type.__asyncResolved || {} : L)
              , {include: $, exclude: D, max: K} = e;
            if ($ && (!O || !Pa($, O)) || D && O && Pa(D, O))
                return o = k,
                A;
            const G = k.key == null ? L : k.key
              , F = i.get(G);
            return k.el && (k = gi(k),
            A.shapeFlag & 128 && (A.ssContent = k)),
            v = G,
            F ? (k.el = F.el,
            k.component = F.component,
            k.transition && Bl(k, k.transition),
            k.shapeFlag |= 512,
            s.delete(G),
            s.add(G)) : (s.add(G),
            K && s.size > parseInt(K, 10) && x(s.values().next().value)),
            k.shapeFlag |= 256,
            o = k,
            hv(A.type) ? A : k
        }
    }
}
  , hS = dS;
function Pa(e, t) {
    return Oe(e) ? e.some(r => Pa(r, t)) : xt(e) ? e.split(",").includes(t) : rE(e) ? e.test(t) : !1
}
function wv(e, t) {
    xv(e, "a", t)
}
function vv(e, t) {
    xv(e, "da", t)
}
function xv(e, t, r=Yt) {
    const n = e.__wdc || (e.__wdc = () => {
        let i = r;
        for (; i; ) {
            if (i.isDeactivated)
                return;
            i = i.parent
        }
        return e()
    }
    );
    if (Bf(t, n, r),
    r) {
        let i = r.parent;
        for (; i && i.parent; )
            Zu(i.parent.vnode) && pS(n, t, r, i),
            i = i.parent
    }
}
function pS(e, t, r, n) {
    const i = Bf(t, e, n, !0);
    ca( () => {
        qp(n[t], i)
    }
    , r)
}
function Yd(e) {
    e.shapeFlag &= -257,
    e.shapeFlag &= -513
}
function Zd(e) {
    return e.shapeFlag & 128 ? e.ssContent : e
}
function Bf(e, t, r=Yt, n=!1) {
    if (r) {
        const i = r[e] || (r[e] = [])
          , s = t.__weh || (t.__weh = (...o) => {
            if (r.isUnmounted)
                return;
            Zs();
            const a = Fs(r)
              , u = dn(t, r, e, o);
            return a(),
            Js(),
            u
        }
        );
        return n ? i.unshift(s) : i.push(s),
        s
    }
}
const wi = e => (t, r=Yt) => (!Xu || e === "sp") && Bf(e, (...n) => t(...n), r)
  , gS = wi("bm")
  , vi = wi("m")
  , mS = wi("bu")
  , Ev = wi("u")
  , Ju = wi("bum")
  , ca = wi("um")
  , yS = wi("sp")
  , bS = wi("rtg")
  , wS = wi("rtc");
function Sv(e, t=Yt) {
    Bf("ec", e, t)
}
function Pl(e, t, r, n) {
    let i;
    const s = r && r[n];
    if (Oe(e) || xt(e)) {
        i = new Array(e.length);
        for (let o = 0, a = e.length; o < a; o++)
            i[o] = t(e[o], o, void 0, s && s[o])
    } else if (typeof e == "number") {
        i = new Array(e);
        for (let o = 0; o < e; o++)
            i[o] = t(o + 1, o, void 0, s && s[o])
    } else if (lt(e))
        if (e[Symbol.iterator])
            i = Array.from(e, (o, a) => t(o, a, void 0, s && s[a]));
        else {
            const o = Object.keys(e);
            i = new Array(o.length);
            for (let a = 0, u = o.length; a < u; a++) {
                const c = o[a];
                i[a] = t(e[c], c, a, s && s[a])
            }
        }
    else
        i = [];
    return r && (r[n] = i),
    i
}
function vS(e, t) {
    for (let r = 0; r < t.length; r++) {
        const n = t[r];
        if (Oe(n))
            for (let i = 0; i < n.length; i++)
                e[n[i].name] = n[i].fn;
        else
            n && (e[n.name] = n.key ? (...i) => {
                const s = n.fn(...i);
                return s && (s.key = n.key),
                s
            }
            : n.fn)
    }
    return e
}
function $n(e, t, r={}, n, i) {
    if (Vt.isCE || Vt.parent && Ps(Vt.parent) && Vt.parent.isCE)
        return t !== "default" && (r.name = t),
        at("slot", r, n && n());
    let s = e[t];
    s && s._c && (s._d = !1),
    je();
    const o = s && _v(s(r))
      , a = yt(tr, {
        key: r.key || o && o.key || `_${t}`
    }, o || (n ? n() : []), o && e._ === 1 ? 64 : -2);
    return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]),
    s && s._c && (s._d = !0),
    a
}
function _v(e) {
    return e.some(t => zo(t) ? !(t.type === Cr || t.type === tr && !_v(t.children)) : !0) ? e : null
}
const nh = e => e ? zv(e) ? jf(e) || e.proxy : nh(e.parent) : null
  , qa = Zt(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => nh(e.parent),
    $root: e => nh(e.root),
    $emit: e => e.emit,
    $options: e => ug(e),
    $forceUpdate: e => e.f || (e.f = () => {
        e.effect.dirty = !0,
        kf(e.update)
    }
    ),
    $nextTick: e => e.n || (e.n = Kn.bind(e.proxy)),
    $watch: e => aS.bind(e)
})
  , Jd = (e, t) => e !== mt && !e.__isScriptSetup && Ye(e, t)
  , xS = {
    get({_: e}, t) {
        const {ctx: r, setupState: n, data: i, props: s, accessCache: o, type: a, appContext: u} = e;
        let c;
        if (t[0] !== "$") {
            const g = o[t];
            if (g !== void 0)
                switch (g) {
                case 1:
                    return n[t];
                case 2:
                    return i[t];
                case 4:
                    return r[t];
                case 3:
                    return s[t]
                }
            else {
                if (Jd(n, t))
                    return o[t] = 1,
                    n[t];
                if (i !== mt && Ye(i, t))
                    return o[t] = 2,
                    i[t];
                if ((c = e.propsOptions[0]) && Ye(c, t))
                    return o[t] = 3,
                    s[t];
                if (r !== mt && Ye(r, t))
                    return o[t] = 4,
                    r[t];
                ih && (o[t] = 0)
            }
        }
        const l = qa[t];
        let p, h;
        if (l)
            return t === "$attrs" && Br(e, "get", t),
            l(e);
        if ((p = a.__cssModules) && (p = p[t]))
            return p;
        if (r !== mt && Ye(r, t))
            return o[t] = 4,
            r[t];
        if (h = u.config.globalProperties,
        Ye(h, t))
            return h[t]
    },
    set({_: e}, t, r) {
        const {data: n, setupState: i, ctx: s} = e;
        return Jd(i, t) ? (i[t] = r,
        !0) : n !== mt && Ye(n, t) ? (n[t] = r,
        !0) : Ye(e.props, t) || t[0] === "$" && t.slice(1)in e ? !1 : (s[t] = r,
        !0)
    },
    has({_: {data: e, setupState: t, accessCache: r, ctx: n, appContext: i, propsOptions: s}}, o) {
        let a;
        return !!r[o] || e !== mt && Ye(e, o) || Jd(t, o) || (a = s[0]) && Ye(a, o) || Ye(n, o) || Ye(qa, o) || Ye(i.config.globalProperties, o)
    },
    defineProperty(e, t, r) {
        return r.get != null ? e._.accessCache[t] = 0 : Ye(r, "value") && this.set(e, t, r.value, null),
        Reflect.defineProperty(e, t, r)
    }
};
function Y$() {
    return Av().slots
}
function ES() {
    return Av().attrs
}
function Av() {
    const e = Gn();
    return e.setupContext || (e.setupContext = Fv(e))
}
function f1(e) {
    return Oe(e) ? e.reduce( (t, r) => (t[r] = null,
    t), {}) : e
}
function SS(e) {
    const t = Gn();
    let r = e();
    return ch(),
    Wp(r) && (r = r.catch(n => {
        throw Fs(t),
        n
    }
    )),
    [r, () => Fs(t)]
}
let ih = !0;
function _S(e) {
    const t = ug(e)
      , r = e.proxy
      , n = e.ctx;
    ih = !1,
    t.beforeCreate && d1(t.beforeCreate, e, "bc");
    const {data: i, computed: s, methods: o, watch: a, provide: u, inject: c, created: l, beforeMount: p, mounted: h, beforeUpdate: g, updated: S, activated: x, deactivated: v, beforeDestroy: I, beforeUnmount: M, destroyed: A, unmounted: k, render: L, renderTracked: O, renderTriggered: $, errorCaptured: D, serverPrefetch: K, expose: G, inheritAttrs: F, components: q, directives: B, filters: y} = t;
    if (c && AS(c, n, null),
    o)
        for (const T in o) {
            const C = o[T];
            Pe(C) && (n[T] = C.bind(r))
        }
    if (i) {
        const T = i.call(r, r);
        lt(T) && (e.data = Vn(T))
    }
    if (ih = !0,
    s)
        for (const T in s) {
            const C = s[T]
              , P = Pe(C) ? C.bind(r, r) : Pe(C.get) ? C.get.bind(r, r) : un
              , W = !Pe(C) && Pe(C.set) ? C.set.bind(r) : un
              , N = Se({
                get: P,
                set: W
            });
            Object.defineProperty(n, T, {
                enumerable: !0,
                configurable: !0,
                get: () => N.value,
                set: w => N.value = w
            })
        }
    if (a)
        for (const T in a)
            Mv(a[T], n, r, T);
    if (u) {
        const T = Pe(u) ? u.call(r) : u;
        Reflect.ownKeys(T).forEach(C => {
            Zi(C, T[C])
        }
        )
    }
    l && d1(l, e, "c");
    function _(T, C) {
        Oe(C) ? C.forEach(P => T(P.bind(r))) : C && T(C.bind(r))
    }
    if (_(gS, p),
    _(vi, h),
    _(mS, g),
    _(Ev, S),
    _(wv, x),
    _(vv, v),
    _(Sv, D),
    _(wS, O),
    _(bS, $),
    _(Ju, M),
    _(ca, k),
    _(yS, K),
    Oe(G))
        if (G.length) {
            const T = e.exposed || (e.exposed = {});
            G.forEach(C => {
                Object.defineProperty(T, C, {
                    get: () => r[C],
                    set: P => r[C] = P
                })
            }
            )
        } else
            e.exposed || (e.exposed = {});
    L && e.render === un && (e.render = L),
    F != null && (e.inheritAttrs = F),
    q && (e.components = q),
    B && (e.directives = B)
}
function AS(e, t, r=un) {
    Oe(e) && (e = sh(e));
    for (const n in e) {
        const i = e[n];
        let s;
        lt(i) ? "default"in i ? s = Kt(i.from || n, i.default, !0) : s = Kt(i.from || n) : s = Kt(i),
        bt(s) ? Object.defineProperty(t, n, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: o => s.value = o
        }) : t[n] = s
    }
}
function d1(e, t, r) {
    dn(Oe(e) ? e.map(n => n.bind(t.proxy)) : e.bind(t.proxy), t, r)
}
function Mv(e, t, r, n) {
    const i = n.includes(".") ? gv(r, n) : () => r[n];
    if (xt(e)) {
        const s = t[e];
        Pe(s) && vt(i, s)
    } else if (Pe(e))
        vt(i, e.bind(r));
    else if (lt(e))
        if (Oe(e))
            e.forEach(s => Mv(s, t, r, n));
        else {
            const s = Pe(e.handler) ? e.handler.bind(r) : t[e.handler];
            Pe(s) && vt(i, s, e)
        }
}
function ug(e) {
    const t = e.type
      , {mixins: r, extends: n} = t
      , {mixins: i, optionsCache: s, config: {optionMergeStrategies: o}} = e.appContext
      , a = s.get(t);
    let u;
    return a ? u = a : !i.length && !r && !n ? u = t : (u = {},
    i.length && i.forEach(c => jl(u, c, o, !0)),
    jl(u, t, o)),
    lt(t) && s.set(t, u),
    u
}
function jl(e, t, r, n=!1) {
    const {mixins: i, extends: s} = t;
    s && jl(e, s, r, !0),
    i && i.forEach(o => jl(e, o, r, !0));
    for (const o in t)
        if (!(n && o === "expose")) {
            const a = MS[o] || r && r[o];
            e[o] = a ? a(e[o], t[o]) : t[o]
        }
    return e
}
const MS = {
    data: h1,
    props: p1,
    emits: p1,
    methods: ja,
    computed: ja,
    beforeCreate: wr,
    created: wr,
    beforeMount: wr,
    mounted: wr,
    beforeUpdate: wr,
    updated: wr,
    beforeDestroy: wr,
    beforeUnmount: wr,
    destroyed: wr,
    unmounted: wr,
    activated: wr,
    deactivated: wr,
    errorCaptured: wr,
    serverPrefetch: wr,
    components: ja,
    directives: ja,
    watch: TS,
    provide: h1,
    inject: IS
};
function h1(e, t) {
    return t ? e ? function() {
        return Zt(Pe(e) ? e.call(this, this) : e, Pe(t) ? t.call(this, this) : t)
    }
    : t : e
}
function IS(e, t) {
    return ja(sh(e), sh(t))
}
function sh(e) {
    if (Oe(e)) {
        const t = {};
        for (let r = 0; r < e.length; r++)
            t[e[r]] = e[r];
        return t
    }
    return e
}
function wr(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function ja(e, t) {
    return e ? Zt(Object.create(null), e, t) : t
}
function p1(e, t) {
    return e ? Oe(e) && Oe(t) ? [...new Set([...e, ...t])] : Zt(Object.create(null), f1(e), f1(t ?? {})) : t
}
function TS(e, t) {
    if (!e)
        return t;
    if (!t)
        return e;
    const r = Zt(Object.create(null), e);
    for (const n in t)
        r[n] = wr(e[n], t[n]);
    return r
}
function Iv() {
    return {
        app: null,
        config: {
            isNativeTag: eE,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let CS = 0;
function kS(e, t) {
    return function(n, i=null) {
        Pe(n) || (n = Zt({}, n)),
        i != null && !lt(i) && (i = null);
        const s = Iv()
          , o = new WeakSet;
        let a = !1;
        const u = s.app = {
            _uid: CS++,
            _component: n,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: Hv,
            get config() {
                return s.config
            },
            set config(c) {},
            use(c, ...l) {
                return o.has(c) || (c && Pe(c.install) ? (o.add(c),
                c.install(u, ...l)) : Pe(c) && (o.add(c),
                c(u, ...l))),
                u
            },
            mixin(c) {
                return s.mixins.includes(c) || s.mixins.push(c),
                u
            },
            component(c, l) {
                return l ? (s.components[c] = l,
                u) : s.components[c]
            },
            directive(c, l) {
                return l ? (s.directives[c] = l,
                u) : s.directives[c]
            },
            mount(c, l, p) {
                if (!a) {
                    const h = at(n, i);
                    return h.appContext = s,
                    p === !0 ? p = "svg" : p === !1 && (p = void 0),
                    l && t ? t(h, c) : e(h, c, p),
                    a = !0,
                    u._container = c,
                    c.__vue_app__ = u,
                    jf(h.component) || h.component.proxy
                }
            },
            unmount() {
                a && (e(null, u._container),
                delete u._container.__vue_app__)
            },
            provide(c, l) {
                return s.provides[c] = l,
                u
            },
            runWithContext(c) {
                const l = _o;
                _o = u;
                try {
                    return c()
                } finally {
                    _o = l
                }
            }
        };
        return u
    }
}
let _o = null;
function Zi(e, t) {
    if (Yt) {
        let r = Yt.provides;
        const n = Yt.parent && Yt.parent.provides;
        n === r && (r = Yt.provides = Object.create(n)),
        r[e] = t
    }
}
function Kt(e, t, r=!1) {
    const n = Yt || Vt;
    if (n || _o) {
        const i = n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : _o._context.provides;
        if (i && e in i)
            return i[e];
        if (arguments.length > 1)
            return r && Pe(t) ? t.call(n && n.proxy) : t
    }
}
function cg() {
    return !!(Yt || Vt || _o)
}
function LS(e, t, r, n=!1) {
    const i = {}
      , s = {};
    kl(s, Pf, 1),
    e.propsDefaults = Object.create(null),
    Tv(e, t, i, s);
    for (const o in e.propsOptions[0])
        o in i || (i[o] = void 0);
    r ? e.props = n ? i : Qu(i) : e.type.props ? e.props = i : e.props = s,
    e.attrs = s
}
function OS(e, t, r, n) {
    const {props: i, attrs: s, vnode: {patchFlag: o}} = e
      , a = Ke(i)
      , [u] = e.propsOptions;
    let c = !1;
    if ((n || o > 0) && !(o & 16)) {
        if (o & 8) {
            const l = e.vnode.dynamicProps;
            for (let p = 0; p < l.length; p++) {
                let h = l[p];
                if (Lf(e.emitsOptions, h))
                    continue;
                const g = t[h];
                if (u)
                    if (Ye(s, h))
                        g !== s[h] && (s[h] = g,
                        c = !0);
                    else {
                        const S = Hn(h);
                        i[S] = oh(u, a, S, g, e, !1)
                    }
                else
                    g !== s[h] && (s[h] = g,
                    c = !0)
            }
        }
    } else {
        Tv(e, t, i, s) && (c = !0);
        let l;
        for (const p in a)
            (!t || !Ye(t, p) && ((l = Ys(p)) === p || !Ye(t, l))) && (u ? r && (r[p] !== void 0 || r[l] !== void 0) && (i[p] = oh(u, a, p, void 0, e, !0)) : delete i[p]);
        if (s !== a)
            for (const p in s)
                (!t || !Ye(t, p)) && (delete s[p],
                c = !0)
    }
    c && di(e, "set", "$attrs")
}
function Tv(e, t, r, n) {
    const [i,s] = e.propsOptions;
    let o = !1, a;
    if (t)
        for (let u in t) {
            if (xo(u))
                continue;
            const c = t[u];
            let l;
            i && Ye(i, l = Hn(u)) ? !s || !s.includes(l) ? r[l] = c : (a || (a = {}))[l] = c : Lf(e.emitsOptions, u) || (!(u in n) || c !== n[u]) && (n[u] = c,
            o = !0)
        }
    if (s) {
        const u = Ke(r)
          , c = a || mt;
        for (let l = 0; l < s.length; l++) {
            const p = s[l];
            r[p] = oh(i, u, p, c[p], e, !Ye(c, p))
        }
    }
    return o
}
function oh(e, t, r, n, i, s) {
    const o = e[r];
    if (o != null) {
        const a = Ye(o, "default");
        if (a && n === void 0) {
            const u = o.default;
            if (o.type !== Function && !o.skipFactory && Pe(u)) {
                const {propsDefaults: c} = i;
                if (r in c)
                    n = c[r];
                else {
                    const l = Fs(i);
                    n = c[r] = u.call(null, t),
                    l()
                }
            } else
                n = u
        }
        o[0] && (s && !a ? n = !1 : o[1] && (n === "" || n === Ys(r)) && (n = !0))
    }
    return n
}
function Cv(e, t, r=!1) {
    const n = t.propsCache
      , i = n.get(e);
    if (i)
        return i;
    const s = e.props
      , o = {}
      , a = [];
    let u = !1;
    if (!Pe(e)) {
        const l = p => {
            u = !0;
            const [h,g] = Cv(p, t, !0);
            Zt(o, h),
            g && a.push(...g)
        }
        ;
        !r && t.mixins.length && t.mixins.forEach(l),
        e.extends && l(e.extends),
        e.mixins && e.mixins.forEach(l)
    }
    if (!s && !u)
        return lt(e) && n.set(e, wo),
        wo;
    if (Oe(s))
        for (let l = 0; l < s.length; l++) {
            const p = Hn(s[l]);
            g1(p) && (o[p] = mt)
        }
    else if (s)
        for (const l in s) {
            const p = Hn(l);
            if (g1(p)) {
                const h = s[l]
                  , g = o[p] = Oe(h) || Pe(h) ? {
                    type: h
                } : Zt({}, h);
                if (g) {
                    const S = b1(Boolean, g.type)
                      , x = b1(String, g.type);
                    g[0] = S > -1,
                    g[1] = x < 0 || S < x,
                    (S > -1 || Ye(g, "default")) && a.push(p)
                }
            }
        }
    const c = [o, a];
    return lt(e) && n.set(e, c),
    c
}
function g1(e) {
    return e[0] !== "$" && !xo(e)
}
function m1(e) {
    return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || ""
}
function y1(e, t) {
    return m1(e) === m1(t)
}
function b1(e, t) {
    return Oe(t) ? t.findIndex(r => y1(r, e)) : Pe(t) && y1(t, e) ? 0 : -1
}
const kv = e => e[0] === "_" || e === "$stable"
  , lg = e => Oe(e) ? e.map(an) : [an(e)]
  , NS = (e, t, r) => {
    if (t._n)
        return t;
    const n = qn( (...i) => lg(t(...i)), r);
    return n._c = !1,
    n
}
  , Lv = (e, t, r) => {
    const n = e._ctx;
    for (const i in e) {
        if (kv(i))
            continue;
        const s = e[i];
        if (Pe(s))
            t[i] = NS(i, s, n);
        else if (s != null) {
            const o = lg(s);
            t[i] = () => o
        }
    }
}
  , Ov = (e, t) => {
    const r = lg(t);
    e.slots.default = () => r
}
  , RS = (e, t) => {
    if (e.vnode.shapeFlag & 32) {
        const r = t._;
        r ? (e.slots = Ke(t),
        kl(t, "_", r)) : Lv(t, e.slots = {})
    } else
        e.slots = {},
        t && Ov(e, t);
    kl(e.slots, Pf, 1)
}
  , BS = (e, t, r) => {
    const {vnode: n, slots: i} = e;
    let s = !0
      , o = mt;
    if (n.shapeFlag & 32) {
        const a = t._;
        a ? r && a === 1 ? s = !1 : (Zt(i, t),
        !r && a === 1 && delete i._) : (s = !t.$stable,
        Lv(t, i)),
        o = t
    } else
        t && (Ov(e, t),
        o = {
            default: 1
        });
    if (s)
        for (const a in i)
            !kv(a) && o[a] == null && delete i[a]
}
;
function Dl(e, t, r, n, i=!1) {
    if (Oe(e)) {
        e.forEach( (h, g) => Dl(h, t && (Oe(t) ? t[g] : t), r, n, i));
        return
    }
    if (Ps(n) && !i)
        return;
    const s = n.shapeFlag & 4 ? jf(n.component) || n.component.proxy : n.el
      , o = i ? null : s
      , {i: a, r: u} = e
      , c = t && t.r
      , l = a.refs === mt ? a.refs = {} : a.refs
      , p = a.setupState;
    if (c != null && c !== u && (xt(c) ? (l[c] = null,
    Ye(p, c) && (p[c] = null)) : bt(c) && (c.value = null)),
    Pe(u))
        Yi(u, a, 12, [o, l]);
    else {
        const h = xt(u)
          , g = bt(u);
        if (h || g) {
            const S = () => {
                if (e.f) {
                    const x = h ? Ye(p, u) ? p[u] : l[u] : u.value;
                    i ? Oe(x) && qp(x, s) : Oe(x) ? x.includes(s) || x.push(s) : h ? (l[u] = [s],
                    Ye(p, u) && (p[u] = l[u])) : (u.value = [s],
                    e.k && (l[e.k] = u.value))
                } else
                    h ? (l[u] = o,
                    Ye(p, u) && (p[u] = o)) : g && (u.value = o,
                    e.k && (l[e.k] = o))
            }
            ;
            o ? (S.id = -1,
            or(S, r)) : S()
        }
    }
}
let Si = !1;
const PS = e => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject"
  , jS = e => e.namespaceURI.includes("MathML")
  , Mc = e => {
    if (PS(e))
        return "svg";
    if (jS(e))
        return "mathml"
}
  , Ic = e => e.nodeType === 8;
function DS(e) {
    const {mt: t, p: r, o: {patchProp: n, createText: i, nextSibling: s, parentNode: o, remove: a, insert: u, createComment: c}} = e
      , l = (A, k) => {
        if (!k.hasChildNodes()) {
            r(null, A, k),
            Nl(),
            k._vnode = A;
            return
        }
        Si = !1,
        p(k.firstChild, A, null, null, null),
        Nl(),
        k._vnode = A,
        Si && console.error("Hydration completed but contains mismatches.")
    }
      , p = (A, k, L, O, $, D=!1) => {
        const K = Ic(A) && A.data === "["
          , G = () => x(A, k, L, O, $, K)
          , {type: F, ref: q, shapeFlag: B, patchFlag: y} = k;
        let b = A.nodeType;
        k.el = A,
        y === -2 && (D = !1,
        k.dynamicChildren = null);
        let _ = null;
        switch (F) {
        case Do:
            b !== 3 ? k.children === "" ? (u(k.el = i(""), o(A), A),
            _ = A) : _ = G() : (A.data !== k.children && (Si = !0,
            A.data = k.children),
            _ = s(A));
            break;
        case Cr:
            M(A) ? (_ = s(A),
            I(k.el = A.content.firstChild, A, L)) : b !== 8 || K ? _ = G() : _ = s(A);
            break;
        case Ao:
            if (K && (A = s(A),
            b = A.nodeType),
            b === 1 || b === 3) {
                _ = A;
                const T = !k.children.length;
                for (let C = 0; C < k.staticCount; C++)
                    T && (k.children += _.nodeType === 1 ? _.outerHTML : _.data),
                    C === k.staticCount - 1 && (k.anchor = _),
                    _ = s(_);
                return K ? s(_) : _
            } else
                G();
            break;
        case tr:
            K ? _ = S(A, k, L, O, $, D) : _ = G();
            break;
        default:
            if (B & 1)
                (b !== 1 || k.type.toLowerCase() !== A.tagName.toLowerCase()) && !M(A) ? _ = G() : _ = h(A, k, L, O, $, D);
            else if (B & 6) {
                k.slotScopeIds = $;
                const T = o(A);
                if (K ? _ = v(A) : Ic(A) && A.data === "teleport start" ? _ = v(A, A.data, "teleport end") : _ = s(A),
                t(k, T, null, L, O, Mc(T), D),
                Ps(k)) {
                    let C;
                    K ? (C = at(tr),
                    C.anchor = _ ? _.previousSibling : T.lastChild) : C = A.nodeType === 3 ? uu("") : at("div"),
                    C.el = A,
                    k.component.subTree = C
                }
            } else
                B & 64 ? b !== 8 ? _ = G() : _ = k.type.hydrate(A, k, L, O, $, D, e, g) : B & 128 && (_ = k.type.hydrate(A, k, L, O, Mc(o(A)), $, D, e, p))
        }
        return q != null && Dl(q, null, O, k),
        _
    }
      , h = (A, k, L, O, $, D) => {
        D = D || !!k.dynamicChildren;
        const {type: K, props: G, patchFlag: F, shapeFlag: q, dirs: B, transition: y} = k
          , b = K === "input" || K === "option";
        if (b || F !== -1) {
            B && On(k, null, L, "created");
            let _ = !1;
            if (M(A)) {
                _ = Rv(O, y) && L && L.vnode.props && L.vnode.props.appear;
                const C = A.content.firstChild;
                _ && y.beforeEnter(C),
                I(C, A, L),
                k.el = A = C
            }
            if (q & 16 && !(G && (G.innerHTML || G.textContent))) {
                let C = g(A.firstChild, k, A, L, O, $, D);
                for (; C; ) {
                    Si = !0;
                    const P = C;
                    C = C.nextSibling,
                    a(P)
                }
            } else
                q & 8 && A.textContent !== k.children && (Si = !0,
                A.textContent = k.children);
            if (G)
                if (b || !D || F & 48)
                    for (const C in G)
                        (b && (C.endsWith("value") || C === "indeterminate") || Ku(C) && !xo(C) || C[0] === ".") && n(A, C, null, G[C], void 0, void 0, L);
                else
                    G.onClick && n(A, "onClick", null, G.onClick, void 0, void 0, L);
            let T;
            (T = G && G.onVnodeBeforeMount) && kr(T, L, k),
            B && On(k, null, L, "beforeMount"),
            ((T = G && G.onVnodeMounted) || B || _) && pv( () => {
                T && kr(T, L, k),
                _ && y.enter(A),
                B && On(k, null, L, "mounted")
            }
            , O)
        }
        return A.nextSibling
    }
      , g = (A, k, L, O, $, D, K) => {
        K = K || !!k.dynamicChildren;
        const G = k.children
          , F = G.length;
        for (let q = 0; q < F; q++) {
            const B = K ? G[q] : G[q] = an(G[q]);
            if (A)
                A = p(A, B, O, $, D, K);
            else {
                if (B.type === Do && !B.children)
                    continue;
                Si = !0,
                r(null, B, L, null, O, $, Mc(L), D)
            }
        }
        return A
    }
      , S = (A, k, L, O, $, D) => {
        const {slotScopeIds: K} = k;
        K && ($ = $ ? $.concat(K) : K);
        const G = o(A)
          , F = g(s(A), k, G, L, O, $, D);
        return F && Ic(F) && F.data === "]" ? s(k.anchor = F) : (Si = !0,
        u(k.anchor = c("]"), G, F),
        F)
    }
      , x = (A, k, L, O, $, D) => {
        if (Si = !0,
        k.el = null,
        D) {
            const F = v(A);
            for (; ; ) {
                const q = s(A);
                if (q && q !== F)
                    a(q);
                else
                    break
            }
        }
        const K = s(A)
          , G = o(A);
        return a(A),
        r(null, k, G, K, L, O, Mc(G), $),
        K
    }
      , v = (A, k="[", L="]") => {
        let O = 0;
        for (; A; )
            if (A = s(A),
            A && Ic(A) && (A.data === k && O++,
            A.data === L)) {
                if (O === 0)
                    return s(A);
                O--
            }
        return A
    }
      , I = (A, k, L) => {
        const O = k.parentNode;
        O && O.replaceChild(A, k);
        let $ = L;
        for (; $; )
            $.vnode.el === k && ($.vnode.el = $.subTree.el = A),
            $ = $.parent
    }
      , M = A => A.nodeType === 1 && A.tagName.toLowerCase() === "template";
    return [l, p]
}
const or = pv;
function US(e) {
    return Nv(e)
}
function zS(e) {
    return Nv(e, DS)
}
function Nv(e, t) {
    const r = $w();
    r.__VUE__ = !0;
    const {insert: n, remove: i, patchProp: s, createElement: o, createText: a, createComment: u, setText: c, setElementText: l, parentNode: p, nextSibling: h, setScopeId: g=un, insertStaticContent: S} = e
      , x = (z, H, Y, se=null, X=null, ce=null, me=void 0, oe=null, ae=!!H.dynamicChildren) => {
        if (z === H)
            return;
        z && !_n(z, H) && (se = Q(z),
        w(z, X, ce, !0),
        z = null),
        H.patchFlag === -2 && (ae = !1,
        H.dynamicChildren = null);
        const {type: ne, ref: de, shapeFlag: ye} = H;
        switch (ne) {
        case Do:
            v(z, H, Y, se);
            break;
        case Cr:
            I(z, H, Y, se);
            break;
        case Ao:
            z == null && M(H, Y, se, me);
            break;
        case tr:
            q(z, H, Y, se, X, ce, me, oe, ae);
            break;
        default:
            ye & 1 ? L(z, H, Y, se, X, ce, me, oe, ae) : ye & 6 ? B(z, H, Y, se, X, ce, me, oe, ae) : (ye & 64 || ye & 128) && ne.process(z, H, Y, se, X, ce, me, oe, ae, he)
        }
        de != null && X && Dl(de, z && z.ref, ce, H || z, !H)
    }
      , v = (z, H, Y, se) => {
        if (z == null)
            n(H.el = a(H.children), Y, se);
        else {
            const X = H.el = z.el;
            H.children !== z.children && c(X, H.children)
        }
    }
      , I = (z, H, Y, se) => {
        z == null ? n(H.el = u(H.children || ""), Y, se) : H.el = z.el
    }
      , M = (z, H, Y, se) => {
        [z.el,z.anchor] = S(z.children, H, Y, se, z.el, z.anchor)
    }
      , A = ({el: z, anchor: H}, Y, se) => {
        let X;
        for (; z && z !== H; )
            X = h(z),
            n(z, Y, se),
            z = X;
        n(H, Y, se)
    }
      , k = ({el: z, anchor: H}) => {
        let Y;
        for (; z && z !== H; )
            Y = h(z),
            i(z),
            z = Y;
        i(H)
    }
      , L = (z, H, Y, se, X, ce, me, oe, ae) => {
        H.type === "svg" ? me = "svg" : H.type === "math" && (me = "mathml"),
        z == null ? O(H, Y, se, X, ce, me, oe, ae) : K(z, H, X, ce, me, oe, ae)
    }
      , O = (z, H, Y, se, X, ce, me, oe) => {
        let ae, ne;
        const {props: de, shapeFlag: ye, transition: ve, dirs: Ee} = z;
        if (ae = z.el = o(z.type, ce, de && de.is, de),
        ye & 8 ? l(ae, z.children) : ye & 16 && D(z.children, ae, null, se, X, Xd(z, ce), me, oe),
        Ee && On(z, null, se, "created"),
        $(ae, z, z.scopeId, me, se),
        de) {
            for (const f in de)
                f !== "value" && !xo(f) && s(ae, f, null, de[f], ce, z.children, se, X, ue);
            "value"in de && s(ae, "value", null, de.value, ce),
            (ne = de.onVnodeBeforeMount) && kr(ne, se, z)
        }
        Ee && On(z, null, se, "beforeMount");
        const m = Rv(X, ve);
        m && ve.beforeEnter(ae),
        n(ae, H, Y),
        ((ne = de && de.onVnodeMounted) || m || Ee) && or( () => {
            ne && kr(ne, se, z),
            m && ve.enter(ae),
            Ee && On(z, null, se, "mounted")
        }
        , X)
    }
      , $ = (z, H, Y, se, X) => {
        if (Y && g(z, Y),
        se)
            for (let ce = 0; ce < se.length; ce++)
                g(z, se[ce]);
        if (X) {
            let ce = X.subTree;
            if (H === ce) {
                const me = X.vnode;
                $(z, me, me.scopeId, me.slotScopeIds, X.parent)
            }
        }
    }
      , D = (z, H, Y, se, X, ce, me, oe, ae=0) => {
        for (let ne = ae; ne < z.length; ne++) {
            const de = z[ne] = oe ? ji(z[ne]) : an(z[ne]);
            x(null, de, H, Y, se, X, ce, me, oe)
        }
    }
      , K = (z, H, Y, se, X, ce, me) => {
        const oe = H.el = z.el;
        let {patchFlag: ae, dynamicChildren: ne, dirs: de} = H;
        ae |= z.patchFlag & 16;
        const ye = z.props || mt
          , ve = H.props || mt;
        let Ee;
        if (Y && cs(Y, !1),
        (Ee = ve.onVnodeBeforeUpdate) && kr(Ee, Y, H, z),
        de && On(H, z, Y, "beforeUpdate"),
        Y && cs(Y, !0),
        ne ? G(z.dynamicChildren, ne, oe, Y, se, Xd(H, X), ce) : me || C(z, H, oe, null, Y, se, Xd(H, X), ce, !1),
        ae > 0) {
            if (ae & 16)
                F(oe, H, ye, ve, Y, se, X);
            else if (ae & 2 && ye.class !== ve.class && s(oe, "class", null, ve.class, X),
            ae & 4 && s(oe, "style", ye.style, ve.style, X),
            ae & 8) {
                const m = H.dynamicProps;
                for (let f = 0; f < m.length; f++) {
                    const d = m[f]
                      , E = ye[d]
                      , R = ve[d];
                    (R !== E || d === "value") && s(oe, d, E, R, X, z.children, Y, se, ue)
                }
            }
            ae & 1 && z.children !== H.children && l(oe, H.children)
        } else
            !me && ne == null && F(oe, H, ye, ve, Y, se, X);
        ((Ee = ve.onVnodeUpdated) || de) && or( () => {
            Ee && kr(Ee, Y, H, z),
            de && On(H, z, Y, "updated")
        }
        , se)
    }
      , G = (z, H, Y, se, X, ce, me) => {
        for (let oe = 0; oe < H.length; oe++) {
            const ae = z[oe]
              , ne = H[oe]
              , de = ae.el && (ae.type === tr || !_n(ae, ne) || ae.shapeFlag & 70) ? p(ae.el) : Y;
            x(ae, ne, de, null, se, X, ce, me, !0)
        }
    }
      , F = (z, H, Y, se, X, ce, me) => {
        if (Y !== se) {
            if (Y !== mt)
                for (const oe in Y)
                    !xo(oe) && !(oe in se) && s(z, oe, Y[oe], null, me, H.children, X, ce, ue);
            for (const oe in se) {
                if (xo(oe))
                    continue;
                const ae = se[oe]
                  , ne = Y[oe];
                ae !== ne && oe !== "value" && s(z, oe, ne, ae, me, H.children, X, ce, ue)
            }
            "value"in se && s(z, "value", Y.value, se.value, me)
        }
    }
      , q = (z, H, Y, se, X, ce, me, oe, ae) => {
        const ne = H.el = z ? z.el : a("")
          , de = H.anchor = z ? z.anchor : a("");
        let {patchFlag: ye, dynamicChildren: ve, slotScopeIds: Ee} = H;
        Ee && (oe = oe ? oe.concat(Ee) : Ee),
        z == null ? (n(ne, Y, se),
        n(de, Y, se),
        D(H.children || [], Y, de, X, ce, me, oe, ae)) : ye > 0 && ye & 64 && ve && z.dynamicChildren ? (G(z.dynamicChildren, ve, Y, X, ce, me, oe),
        (H.key != null || X && H === X.subTree) && fg(z, H, !0)) : C(z, H, Y, de, X, ce, me, oe, ae)
    }
      , B = (z, H, Y, se, X, ce, me, oe, ae) => {
        H.slotScopeIds = oe,
        z == null ? H.shapeFlag & 512 ? X.ctx.activate(H, Y, se, me, ae) : y(H, Y, se, X, ce, me, ae) : b(z, H, ae)
    }
      , y = (z, H, Y, se, X, ce, me) => {
        const oe = z.component = QS(z, se, X);
        if (Zu(z) && (oe.ctx.renderer = he),
        YS(oe),
        oe.asyncDep) {
            if (X && X.registerDep(oe, _),
            !z.el) {
                const ae = oe.subTree = at(Cr);
                I(null, ae, H, Y)
            }
        } else
            _(oe, z, H, Y, X, ce, me)
    }
      , b = (z, H, Y) => {
        const se = H.component = z.component;
        if (GE(z, H, Y))
            if (se.asyncDep && !se.asyncResolved) {
                T(se, H, Y);
                return
            } else
                se.next = H,
                FE(se.update),
                se.effect.dirty = !0,
                se.update();
        else
            H.el = z.el,
            se.vnode = H
    }
      , _ = (z, H, Y, se, X, ce, me) => {
        const oe = () => {
            if (z.isMounted) {
                let {next: de, bu: ye, u: ve, parent: Ee, vnode: m} = z;
                {
                    const j = Bv(z);
                    if (j) {
                        de && (de.el = m.el,
                        T(z, de, me)),
                        j.asyncDep.then( () => {
                            z.isUnmounted || oe()
                        }
                        );
                        return
                    }
                }
                let f = de, d;
                cs(z, !1),
                de ? (de.el = m.el,
                T(z, de, me)) : de = m,
                ye && Fa(ye),
                (d = de.props && de.props.onVnodeBeforeUpdate) && kr(d, Ee, de, m),
                cs(z, !0);
                const E = Kd(z)
                  , R = z.subTree;
                z.subTree = E,
                x(R, E, p(R.el), Q(R), z, X, ce),
                de.el = E.el,
                f === null && ng(z, E.el),
                ve && or(ve, X),
                (d = de.props && de.props.onVnodeUpdated) && or( () => kr(d, Ee, de, m), X)
            } else {
                let de;
                const {el: ye, props: ve} = H
                  , {bm: Ee, m, parent: f} = z
                  , d = Ps(H);
                if (cs(z, !1),
                Ee && Fa(Ee),
                !d && (de = ve && ve.onVnodeBeforeMount) && kr(de, f, H),
                cs(z, !0),
                ye && Ae) {
                    const E = () => {
                        z.subTree = Kd(z),
                        Ae(ye, z.subTree, z, X, null)
                    }
                    ;
                    d ? H.type.__asyncLoader().then( () => !z.isUnmounted && E()) : E()
                } else {
                    const E = z.subTree = Kd(z);
                    x(null, E, Y, se, z, X, ce),
                    H.el = E.el
                }
                if (m && or(m, X),
                !d && (de = ve && ve.onVnodeMounted)) {
                    const E = H;
                    or( () => kr(de, f, E), X)
                }
                (H.shapeFlag & 256 || f && Ps(f.vnode) && f.vnode.shapeFlag & 256) && z.a && or(z.a, X),
                z.isMounted = !0,
                H = Y = se = null
            }
        }
          , ae = z.effect = new Gp(oe,un, () => kf(ne),z.scope)
          , ne = z.update = () => {
            ae.dirty && ae.run()
        }
        ;
        ne.id = z.uid,
        cs(z, !0),
        ne()
    }
      , T = (z, H, Y) => {
        H.component = z;
        const se = z.vnode.props;
        z.vnode = H,
        z.next = null,
        OS(z, H.props, se, Y),
        BS(z, H.children, Y),
        Zs(),
        o1(z),
        Js()
    }
      , C = (z, H, Y, se, X, ce, me, oe, ae=!1) => {
        const ne = z && z.children
          , de = z ? z.shapeFlag : 0
          , ye = H.children
          , {patchFlag: ve, shapeFlag: Ee} = H;
        if (ve > 0) {
            if (ve & 128) {
                W(ne, ye, Y, se, X, ce, me, oe, ae);
                return
            } else if (ve & 256) {
                P(ne, ye, Y, se, X, ce, me, oe, ae);
                return
            }
        }
        Ee & 8 ? (de & 16 && ue(ne, X, ce),
        ye !== ne && l(Y, ye)) : de & 16 ? Ee & 16 ? W(ne, ye, Y, se, X, ce, me, oe, ae) : ue(ne, X, ce, !0) : (de & 8 && l(Y, ""),
        Ee & 16 && D(ye, Y, se, X, ce, me, oe, ae))
    }
      , P = (z, H, Y, se, X, ce, me, oe, ae) => {
        z = z || wo,
        H = H || wo;
        const ne = z.length
          , de = H.length
          , ye = Math.min(ne, de);
        let ve;
        for (ve = 0; ve < ye; ve++) {
            const Ee = H[ve] = ae ? ji(H[ve]) : an(H[ve]);
            x(z[ve], Ee, Y, null, X, ce, me, oe, ae)
        }
        ne > de ? ue(z, X, ce, !0, !1, ye) : D(H, Y, se, X, ce, me, oe, ae, ye)
    }
      , W = (z, H, Y, se, X, ce, me, oe, ae) => {
        let ne = 0;
        const de = H.length;
        let ye = z.length - 1
          , ve = de - 1;
        for (; ne <= ye && ne <= ve; ) {
            const Ee = z[ne]
              , m = H[ne] = ae ? ji(H[ne]) : an(H[ne]);
            if (_n(Ee, m))
                x(Ee, m, Y, null, X, ce, me, oe, ae);
            else
                break;
            ne++
        }
        for (; ne <= ye && ne <= ve; ) {
            const Ee = z[ye]
              , m = H[ve] = ae ? ji(H[ve]) : an(H[ve]);
            if (_n(Ee, m))
                x(Ee, m, Y, null, X, ce, me, oe, ae);
            else
                break;
            ye--,
            ve--
        }
        if (ne > ye) {
            if (ne <= ve) {
                const Ee = ve + 1
                  , m = Ee < de ? H[Ee].el : se;
                for (; ne <= ve; )
                    x(null, H[ne] = ae ? ji(H[ne]) : an(H[ne]), Y, m, X, ce, me, oe, ae),
                    ne++
            }
        } else if (ne > ve)
            for (; ne <= ye; )
                w(z[ne], X, ce, !0),
                ne++;
        else {
            const Ee = ne
              , m = ne
              , f = new Map;
            for (ne = m; ne <= ve; ne++) {
                const ge = H[ne] = ae ? ji(H[ne]) : an(H[ne]);
                ge.key != null && f.set(ge.key, ne)
            }
            let d, E = 0;
            const R = ve - m + 1;
            let j = !1
              , V = 0;
            const pe = new Array(R);
            for (ne = 0; ne < R; ne++)
                pe[ne] = 0;
            for (ne = Ee; ne <= ye; ne++) {
                const ge = z[ne];
                if (E >= R) {
                    w(ge, X, ce, !0);
                    continue
                }
                let Ce;
                if (ge.key != null)
                    Ce = f.get(ge.key);
                else
                    for (d = m; d <= ve; d++)
                        if (pe[d - m] === 0 && _n(ge, H[d])) {
                            Ce = d;
                            break
                        }
                Ce === void 0 ? w(ge, X, ce, !0) : (pe[Ce - m] = ne + 1,
                Ce >= V ? V = Ce : j = !0,
                x(ge, H[Ce], Y, null, X, ce, me, oe, ae),
                E++)
            }
            const _e = j ? $S(pe) : wo;
            for (d = _e.length - 1,
            ne = R - 1; ne >= 0; ne--) {
                const ge = m + ne
                  , Ce = H[ge]
                  , we = ge + 1 < de ? H[ge + 1].el : se;
                pe[ne] === 0 ? x(null, Ce, Y, we, X, ce, me, oe, ae) : j && (d < 0 || ne !== _e[d] ? N(Ce, Y, we, 2) : d--)
            }
        }
    }
      , N = (z, H, Y, se, X=null) => {
        const {el: ce, type: me, transition: oe, children: ae, shapeFlag: ne} = z;
        if (ne & 6) {
            N(z.component.subTree, H, Y, se);
            return
        }
        if (ne & 128) {
            z.suspense.move(H, Y, se);
            return
        }
        if (ne & 64) {
            me.move(z, H, Y, he);
            return
        }
        if (me === tr) {
            n(ce, H, Y);
            for (let ye = 0; ye < ae.length; ye++)
                N(ae[ye], H, Y, se);
            n(z.anchor, H, Y);
            return
        }
        if (me === Ao) {
            A(z, H, Y);
            return
        }
        if (se !== 2 && ne & 1 && oe)
            if (se === 0)
                oe.beforeEnter(ce),
                n(ce, H, Y),
                or( () => oe.enter(ce), X);
            else {
                const {leave: ye, delayLeave: ve, afterLeave: Ee} = oe
                  , m = () => n(ce, H, Y)
                  , f = () => {
                    ye(ce, () => {
                        m(),
                        Ee && Ee()
                    }
                    )
                }
                ;
                ve ? ve(ce, m, f) : f()
            }
        else
            n(ce, H, Y)
    }
      , w = (z, H, Y, se=!1, X=!1) => {
        const {type: ce, props: me, ref: oe, children: ae, dynamicChildren: ne, shapeFlag: de, patchFlag: ye, dirs: ve} = z;
        if (oe != null && Dl(oe, null, Y, z, !0),
        de & 256) {
            H.ctx.deactivate(z);
            return
        }
        const Ee = de & 1 && ve
          , m = !Ps(z);
        let f;
        if (m && (f = me && me.onVnodeBeforeUnmount) && kr(f, H, z),
        de & 6)
            ie(z.component, Y, se);
        else {
            if (de & 128) {
                z.suspense.unmount(Y, se);
                return
            }
            Ee && On(z, null, H, "beforeUnmount"),
            de & 64 ? z.type.remove(z, H, Y, X, he, se) : ne && (ce !== tr || ye > 0 && ye & 64) ? ue(ne, H, Y, !1, !0) : (ce === tr && ye & 384 || !X && de & 16) && ue(ae, H, Y),
            se && U(z)
        }
        (m && (f = me && me.onVnodeUnmounted) || Ee) && or( () => {
            f && kr(f, H, z),
            Ee && On(z, null, H, "unmounted")
        }
        , Y)
    }
      , U = z => {
        const {type: H, el: Y, anchor: se, transition: X} = z;
        if (H === tr) {
            re(Y, se);
            return
        }
        if (H === Ao) {
            k(z);
            return
        }
        const ce = () => {
            i(Y),
            X && !X.persisted && X.afterLeave && X.afterLeave()
        }
        ;
        if (z.shapeFlag & 1 && X && !X.persisted) {
            const {leave: me, delayLeave: oe} = X
              , ae = () => me(Y, ce);
            oe ? oe(z.el, ce, ae) : ae()
        } else
            ce()
    }
      , re = (z, H) => {
        let Y;
        for (; z !== H; )
            Y = h(z),
            i(z),
            z = Y;
        i(H)
    }
      , ie = (z, H, Y) => {
        const {bum: se, scope: X, update: ce, subTree: me, um: oe} = z;
        se && Fa(se),
        X.stop(),
        ce && (ce.active = !1,
        w(me, z, H, Y)),
        oe && or(oe, H),
        or( () => {
            z.isUnmounted = !0
        }
        , H),
        H && H.pendingBranch && !H.isUnmounted && z.asyncDep && !z.asyncResolved && z.suspenseId === H.pendingId && (H.deps--,
        H.deps === 0 && H.resolve())
    }
      , ue = (z, H, Y, se=!1, X=!1, ce=0) => {
        for (let me = ce; me < z.length; me++)
            w(z[me], H, Y, se, X)
    }
      , Q = z => z.shapeFlag & 6 ? Q(z.component.subTree) : z.shapeFlag & 128 ? z.suspense.next() : h(z.anchor || z.el);
    let ee = !1;
    const te = (z, H, Y) => {
        z == null ? H._vnode && w(H._vnode, null, null, !0) : x(H._vnode || null, z, H, null, null, null, Y),
        ee || (ee = !0,
        o1(),
        Nl(),
        ee = !1),
        H._vnode = z
    }
      , he = {
        p: x,
        um: w,
        m: N,
        r: U,
        mt: y,
        mc: D,
        pc: C,
        pbc: G,
        n: Q,
        o: e
    };
    let xe, Ae;
    return t && ([xe,Ae] = t(he)),
    {
        render: te,
        hydrate: xe,
        createApp: kS(te, xe)
    }
}
function Xd({type: e, props: t}, r) {
    return r === "svg" && e === "foreignObject" || r === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : r
}
function cs({effect: e, update: t}, r) {
    e.allowRecurse = t.allowRecurse = r
}
function Rv(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted
}
function fg(e, t, r=!1) {
    const n = e.children
      , i = t.children;
    if (Oe(n) && Oe(i))
        for (let s = 0; s < n.length; s++) {
            const o = n[s];
            let a = i[s];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[s] = ji(i[s]),
            a.el = o.el),
            r || fg(o, a)),
            a.type === Do && (a.el = o.el)
        }
}
function $S(e) {
    const t = e.slice()
      , r = [0];
    let n, i, s, o, a;
    const u = e.length;
    for (n = 0; n < u; n++) {
        const c = e[n];
        if (c !== 0) {
            if (i = r[r.length - 1],
            e[i] < c) {
                t[n] = i,
                r.push(n);
                continue
            }
            for (s = 0,
            o = r.length - 1; s < o; )
                a = s + o >> 1,
                e[r[a]] < c ? s = a + 1 : o = a;
            c < e[r[s]] && (s > 0 && (t[n] = r[s - 1]),
            r[s] = n)
        }
    }
    for (s = r.length,
    o = r[s - 1]; s-- > 0; )
        r[s] = o,
        o = t[o];
    return r
}
function Bv(e) {
    const t = e.subTree.component;
    if (t)
        return t.asyncDep && !t.asyncResolved ? t : Bv(t)
}
const FS = e => e.__isTeleport
  , Wa = e => e && (e.disabled || e.disabled === "")
  , w1 = e => typeof SVGElement < "u" && e instanceof SVGElement
  , v1 = e => typeof MathMLElement == "function" && e instanceof MathMLElement
  , ah = (e, t) => {
    const r = e && e.to;
    return xt(r) ? t ? t(r) : null : r
}
  , HS = {
    name: "Teleport",
    __isTeleport: !0,
    process(e, t, r, n, i, s, o, a, u, c) {
        const {mc: l, pc: p, pbc: h, o: {insert: g, querySelector: S, createText: x, createComment: v}} = c
          , I = Wa(t.props);
        let {shapeFlag: M, children: A, dynamicChildren: k} = t;
        if (e == null) {
            const L = t.el = x("")
              , O = t.anchor = x("");
            g(L, r, n),
            g(O, r, n);
            const $ = t.target = ah(t.props, S)
              , D = t.targetAnchor = x("");
            $ && (g(D, $),
            o === "svg" || w1($) ? o = "svg" : (o === "mathml" || v1($)) && (o = "mathml"));
            const K = (G, F) => {
                M & 16 && l(A, G, F, i, s, o, a, u)
            }
            ;
            I ? K(r, O) : $ && K($, D)
        } else {
            t.el = e.el;
            const L = t.anchor = e.anchor
              , O = t.target = e.target
              , $ = t.targetAnchor = e.targetAnchor
              , D = Wa(e.props)
              , K = D ? r : O
              , G = D ? L : $;
            if (o === "svg" || w1(O) ? o = "svg" : (o === "mathml" || v1(O)) && (o = "mathml"),
            k ? (h(e.dynamicChildren, k, K, i, s, o, a),
            fg(e, t, !0)) : u || p(e, t, K, G, i, s, o, a, !1),
            I)
                D ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Tc(t, r, L, c, 1);
            else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                const F = t.target = ah(t.props, S);
                F && Tc(t, F, null, c, 0)
            } else
                D && Tc(t, O, $, c, 1)
        }
        Pv(t)
    },
    remove(e, t, r, n, {um: i, o: {remove: s}}, o) {
        const {shapeFlag: a, children: u, anchor: c, targetAnchor: l, target: p, props: h} = e;
        if (p && s(l),
        o && s(c),
        a & 16) {
            const g = o || !Wa(h);
            for (let S = 0; S < u.length; S++) {
                const x = u[S];
                i(x, t, r, g, !!x.dynamicChildren)
            }
        }
    },
    move: Tc,
    hydrate: qS
};
function Tc(e, t, r, {o: {insert: n}, m: i}, s=2) {
    s === 0 && n(e.targetAnchor, t, r);
    const {el: o, anchor: a, shapeFlag: u, children: c, props: l} = e
      , p = s === 2;
    if (p && n(o, t, r),
    (!p || Wa(l)) && u & 16)
        for (let h = 0; h < c.length; h++)
            i(c[h], t, r, 2);
    p && n(a, t, r)
}
function qS(e, t, r, n, i, s, {o: {nextSibling: o, parentNode: a, querySelector: u}}, c) {
    const l = t.target = ah(t.props, u);
    if (l) {
        const p = l._lpa || l.firstChild;
        if (t.shapeFlag & 16)
            if (Wa(t.props))
                t.anchor = c(o(e), t, a(e), r, n, i, s),
                t.targetAnchor = p;
            else {
                t.anchor = o(e);
                let h = p;
                for (; h; )
                    if (h = o(h),
                    h && h.nodeType === 8 && h.data === "teleport anchor") {
                        t.targetAnchor = h,
                        l._lpa = t.targetAnchor && o(t.targetAnchor);
                        break
                    }
                c(p, t, l, r, n, i, s)
            }
        Pv(t)
    }
    return t.anchor && o(t.anchor)
}
const WS = HS;
function Pv(e) {
    const t = e.ctx;
    if (t && t.ut) {
        let r = e.children[0].el;
        for (; r && r !== e.targetAnchor; )
            r.nodeType === 1 && r.setAttribute("data-v-owner", t.uid),
            r = r.nextSibling;
        t.ut()
    }
}
const tr = Symbol.for("v-fgt")
  , Do = Symbol.for("v-txt")
  , Cr = Symbol.for("v-cmt")
  , Ao = Symbol.for("v-stc")
  , Va = [];
let cn = null;
function je(e=!1) {
    Va.push(cn = e ? null : [])
}
function jv() {
    Va.pop(),
    cn = Va[Va.length - 1] || null
}
let Uo = 1;
function x1(e) {
    Uo += e
}
function Dv(e) {
    return e.dynamicChildren = Uo > 0 ? cn || wo : null,
    jv(),
    Uo > 0 && cn && cn.push(e),
    e
}
function Wt(e, t, r, n, i, s) {
    return Dv(zn(e, t, r, n, i, s, !0))
}
function yt(e, t, r, n, i) {
    return Dv(at(e, t, r, n, i, !0))
}
function zo(e) {
    return e ? e.__v_isVNode === !0 : !1
}
function _n(e, t) {
    return e.type === t.type && e.key === t.key
}
const Pf = "__vInternal"
  , Uv = ({key: e}) => e ?? null
  , ol = ({ref: e, ref_key: t, ref_for: r}) => (typeof e == "number" && (e = "" + e),
e != null ? xt(e) || bt(e) || Pe(e) ? {
    i: Vt,
    r: e,
    k: t,
    f: !!r
} : e : null);
function zn(e, t=null, r=null, n=0, i=null, s=e === tr ? 0 : 1, o=!1, a=!1) {
    const u = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && Uv(t),
        ref: t && ol(t),
        scopeId: Of,
        slotScopeIds: null,
        children: r,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: n,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
        ctx: Vt
    };
    return a ? (dg(u, r),
    s & 128 && e.normalize(u)) : r && (u.shapeFlag |= xt(r) ? 8 : 16),
    Uo > 0 && !o && cn && (u.patchFlag > 0 || s & 6) && u.patchFlag !== 32 && cn.push(u),
    u
}
const at = VS;
function VS(e, t=null, r=null, n=0, i=null, s=!1) {
    if ((!e || e === dv) && (e = Cr),
    zo(e)) {
        const a = gi(e, t, !0);
        return r && dg(a, r),
        Uo > 0 && !s && cn && (a.shapeFlag & 6 ? cn[cn.indexOf(e)] = a : cn.push(a)),
        a.patchFlag |= -2,
        a
    }
    if (XS(e) && (e = e.__vccOpts),
    t) {
        t = Ul(t);
        let {class: a, style: u} = t;
        a && !xt(a) && (t.class = ot(a)),
        lt(u) && (rv(u) && !Oe(u) && (u = Zt({}, u)),
        t.style = zs(u))
    }
    const o = xt(e) ? 1 : hv(e) ? 128 : FS(e) ? 64 : lt(e) ? 4 : Pe(e) ? 2 : 0;
    return zn(e, t, r, n, i, o, s, !0)
}
function Ul(e) {
    return e ? rv(e) || Pf in e ? Zt({}, e) : e : null
}
function gi(e, t, r=!1) {
    const {props: n, ref: i, patchFlag: s, children: o} = e
      , a = t ? Sr(n || {}, t) : n;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: a,
        key: a && Uv(a),
        ref: t && t.ref ? r && i ? Oe(i) ? i.concat(ol(t)) : [i, ol(t)] : ol(t) : i,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: o,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== tr ? s === -1 ? 16 : s | 16 : s,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && gi(e.ssContent),
        ssFallback: e.ssFallback && gi(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    }
}
function uu(e=" ", t=0) {
    return at(Do, null, e, t)
}
function Z$(e, t) {
    const r = at(Ao, null, e);
    return r.staticCount = t,
    r
}
function Er(e="", t=!1) {
    return t ? (je(),
    yt(Cr, null, e)) : at(Cr, null, e)
}
function an(e) {
    return e == null || typeof e == "boolean" ? at(Cr) : Oe(e) ? at(tr, null, e.slice()) : typeof e == "object" ? ji(e) : at(Do, null, String(e))
}
function ji(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : gi(e)
}
function dg(e, t) {
    let r = 0;
    const {shapeFlag: n} = e;
    if (t == null)
        t = null;
    else if (Oe(t))
        r = 16;
    else if (typeof t == "object")
        if (n & 65) {
            const i = t.default;
            i && (i._c && (i._d = !1),
            dg(e, i()),
            i._c && (i._d = !0));
            return
        } else {
            r = 32;
            const i = t._;
            !i && !(Pf in t) ? t._ctx = Vt : i === 3 && Vt && (Vt.slots._ === 1 ? t._ = 1 : (t._ = 2,
            e.patchFlag |= 1024))
        }
    else
        Pe(t) ? (t = {
            default: t,
            _ctx: Vt
        },
        r = 32) : (t = String(t),
        n & 64 ? (r = 16,
        t = [uu(t)]) : r = 8);
    e.children = t,
    e.shapeFlag |= r
}
function Sr(...e) {
    const t = {};
    for (let r = 0; r < e.length; r++) {
        const n = e[r];
        for (const i in n)
            if (i === "class")
                t.class !== n.class && (t.class = ot([t.class, n.class]));
            else if (i === "style")
                t.style = zs([t.style, n.style]);
            else if (Ku(i)) {
                const s = t[i]
                  , o = n[i];
                o && s !== o && !(Oe(s) && s.includes(o)) && (t[i] = s ? [].concat(s, o) : o)
            } else
                i !== "" && (t[i] = n[i])
    }
    return t
}
function kr(e, t, r, n=null) {
    dn(e, t, 7, [r, n])
}
const KS = Iv();
let GS = 0;
function QS(e, t, r) {
    const n = e.type
      , i = (t ? t.appContext : e.appContext) || KS
      , s = {
        uid: GS++,
        vnode: e,
        type: n,
        parent: t,
        appContext: i,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new qw(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(i.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: Cv(n, i),
        emitsOptions: fv(n, i),
        emit: null,
        emitted: null,
        propsDefaults: mt,
        inheritAttrs: n.inheritAttrs,
        ctx: mt,
        data: mt,
        props: mt,
        attrs: mt,
        slots: mt,
        refs: mt,
        setupState: mt,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        suspense: r,
        suspenseId: r ? r.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return s.ctx = {
        _: s
    },
    s.root = t ? t.root : s,
    s.emit = qE.bind(null, s),
    e.ce && e.ce(s),
    s
}
let Yt = null;
const Gn = () => Yt || Vt;
let zl, uh;
{
    const e = $w()
      , t = (r, n) => {
        let i;
        return (i = e[r]) || (i = e[r] = []),
        i.push(n),
        s => {
            i.length > 1 ? i.forEach(o => o(s)) : i[0](s)
        }
    }
    ;
    zl = t("__VUE_INSTANCE_SETTERS__", r => Yt = r),
    uh = t("__VUE_SSR_SETTERS__", r => Xu = r)
}
const Fs = e => {
    const t = Yt;
    return zl(e),
    e.scope.on(),
    () => {
        e.scope.off(),
        zl(t)
    }
}
  , ch = () => {
    Yt && Yt.scope.off(),
    zl(null)
}
;
function zv(e) {
    return e.vnode.shapeFlag & 4
}
let Xu = !1;
function YS(e, t=!1) {
    t && uh(t);
    const {props: r, children: n} = e.vnode
      , i = zv(e);
    LS(e, r, i, t),
    RS(e, n);
    const s = i ? ZS(e, t) : void 0;
    return t && uh(!1),
    s
}
function ZS(e, t) {
    const r = e.type;
    e.accessCache = Object.create(null),
    e.proxy = Cf(new Proxy(e.ctx,xS));
    const {setup: n} = r;
    if (n) {
        const i = e.setupContext = n.length > 1 ? Fv(e) : null
          , s = Fs(e);
        Zs();
        const o = Yi(n, e, 0, [e.props, i]);
        if (Js(),
        s(),
        Wp(o)) {
            if (o.then(ch, ch),
            t)
                return o.then(a => {
                    lh(e, a, t)
                }
                ).catch(a => {
                    ua(a, e, 0)
                }
                );
            e.asyncDep = o
        } else
            lh(e, o, t)
    } else
        $v(e, t)
}
function lh(e, t, r) {
    Pe(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : lt(t) && (e.setupState = sv(t)),
    $v(e, r)
}
let E1;
function $v(e, t, r) {
    const n = e.type;
    if (!e.render) {
        if (!t && E1 && !n.render) {
            const i = n.template || ug(e).template;
            if (i) {
                const {isCustomElement: s, compilerOptions: o} = e.appContext.config
                  , {delimiters: a, compilerOptions: u} = n
                  , c = Zt(Zt({
                    isCustomElement: s,
                    delimiters: a
                }, o), u);
                n.render = E1(i, c)
            }
        }
        e.render = n.render || un
    }
    {
        const i = Fs(e);
        Zs();
        try {
            _S(e)
        } finally {
            Js(),
            i()
        }
    }
}
function JS(e) {
    return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs,{
        get(t, r) {
            return Br(e, "get", "$attrs"),
            t[r]
        }
    }))
}
function Fv(e) {
    const t = r => {
        e.exposed = r || {}
    }
    ;
    return {
        get attrs() {
            return JS(e)
        },
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}
function jf(e) {
    if (e.exposed)
        return e.exposeProxy || (e.exposeProxy = new Proxy(sv(Cf(e.exposed)),{
            get(t, r) {
                if (r in t)
                    return t[r];
                if (r in qa)
                    return qa[r](e)
            },
            has(t, r) {
                return r in t || r in qa
            }
        }))
}
function fh(e, t=!0) {
    return Pe(e) ? e.displayName || e.name : e.name || t && e.__name
}
function XS(e) {
    return Pe(e) && "__vccOpts"in e
}
const Se = (e, t) => RE(e, t, Xu);
function cr(e, t, r) {
    const n = arguments.length;
    return n === 2 ? lt(t) && !Oe(t) ? zo(t) ? at(e, null, [t]) : at(e, t) : at(e, null, t) : (n > 3 ? r = Array.prototype.slice.call(arguments, 2) : n === 3 && zo(r) && (r = [r]),
    at(e, t, r))
}
const Hv = "3.4.21";
/**
* @vue/runtime-dom v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const e_ = "http://www.w3.org/2000/svg"
  , t_ = "http://www.w3.org/1998/Math/MathML"
  , Di = typeof document < "u" ? document : null
  , S1 = Di && Di.createElement("template")
  , r_ = {
    insert: (e, t, r) => {
        t.insertBefore(e, r || null)
    }
    ,
    remove: e => {
        const t = e.parentNode;
        t && t.removeChild(e)
    }
    ,
    createElement: (e, t, r, n) => {
        const i = t === "svg" ? Di.createElementNS(e_, e) : t === "mathml" ? Di.createElementNS(t_, e) : Di.createElement(e, r ? {
            is: r
        } : void 0);
        return e === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple),
        i
    }
    ,
    createText: e => Di.createTextNode(e),
    createComment: e => Di.createComment(e),
    setText: (e, t) => {
        e.nodeValue = t
    }
    ,
    setElementText: (e, t) => {
        e.textContent = t
    }
    ,
    parentNode: e => e.parentNode,
    nextSibling: e => e.nextSibling,
    querySelector: e => Di.querySelector(e),
    setScopeId(e, t) {
        e.setAttribute(t, "")
    },
    insertStaticContent(e, t, r, n, i, s) {
        const o = r ? r.previousSibling : t.lastChild;
        if (i && (i === s || i.nextSibling))
            for (; t.insertBefore(i.cloneNode(!0), r),
            !(i === s || !(i = i.nextSibling)); )
                ;
        else {
            S1.innerHTML = n === "svg" ? `<svg>${e}</svg>` : n === "mathml" ? `<math>${e}</math>` : e;
            const a = S1.content;
            if (n === "svg" || n === "mathml") {
                const u = a.firstChild;
                for (; u.firstChild; )
                    a.appendChild(u.firstChild);
                a.removeChild(u)
            }
            t.insertBefore(a, r)
        }
        return [o ? o.nextSibling : t.firstChild, r ? r.previousSibling : t.lastChild]
    }
}
  , _i = "transition"
  , Ea = "animation"
  , cu = Symbol("_vtc")
  , ec = (e, {slots: t}) => cr(fS, n_(e), t);
ec.displayName = "Transition";
const qv = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
ec.props = Zt({}, mv, qv);
const ls = (e, t=[]) => {
    Oe(e) ? e.forEach(r => r(...t)) : e && e(...t)
}
  , _1 = e => e ? Oe(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;
function n_(e) {
    const t = {};
    for (const q in e)
        q in qv || (t[q] = e[q]);
    if (e.css === !1)
        return t;
    const {name: r="v", type: n, duration: i, enterFromClass: s=`${r}-enter-from`, enterActiveClass: o=`${r}-enter-active`, enterToClass: a=`${r}-enter-to`, appearFromClass: u=s, appearActiveClass: c=o, appearToClass: l=a, leaveFromClass: p=`${r}-leave-from`, leaveActiveClass: h=`${r}-leave-active`, leaveToClass: g=`${r}-leave-to`} = e
      , S = i_(i)
      , x = S && S[0]
      , v = S && S[1]
      , {onBeforeEnter: I, onEnter: M, onEnterCancelled: A, onLeave: k, onLeaveCancelled: L, onBeforeAppear: O=I, onAppear: $=M, onAppearCancelled: D=A} = t
      , K = (q, B, y) => {
        fs(q, B ? l : a),
        fs(q, B ? c : o),
        y && y()
    }
      , G = (q, B) => {
        q._isLeaving = !1,
        fs(q, p),
        fs(q, g),
        fs(q, h),
        B && B()
    }
      , F = q => (B, y) => {
        const b = q ? $ : M
          , _ = () => K(B, q, y);
        ls(b, [B, _]),
        A1( () => {
            fs(B, q ? u : s),
            Ai(B, q ? l : a),
            _1(b) || M1(B, n, x, _)
        }
        )
    }
    ;
    return Zt(t, {
        onBeforeEnter(q) {
            ls(I, [q]),
            Ai(q, s),
            Ai(q, o)
        },
        onBeforeAppear(q) {
            ls(O, [q]),
            Ai(q, u),
            Ai(q, c)
        },
        onEnter: F(!1),
        onAppear: F(!0),
        onLeave(q, B) {
            q._isLeaving = !0;
            const y = () => G(q, B);
            Ai(q, p),
            a_(),
            Ai(q, h),
            A1( () => {
                q._isLeaving && (fs(q, p),
                Ai(q, g),
                _1(k) || M1(q, n, v, y))
            }
            ),
            ls(k, [q, y])
        },
        onEnterCancelled(q) {
            K(q, !1),
            ls(A, [q])
        },
        onAppearCancelled(q) {
            K(q, !0),
            ls(D, [q])
        },
        onLeaveCancelled(q) {
            G(q),
            ls(L, [q])
        }
    })
}
function i_(e) {
    if (e == null)
        return null;
    if (lt(e))
        return [e0(e.enter), e0(e.leave)];
    {
        const t = e0(e);
        return [t, t]
    }
}
function e0(e) {
    return zw(e)
}
function Ai(e, t) {
    t.split(/\s+/).forEach(r => r && e.classList.add(r)),
    (e[cu] || (e[cu] = new Set)).add(t)
}
function fs(e, t) {
    t.split(/\s+/).forEach(n => n && e.classList.remove(n));
    const r = e[cu];
    r && (r.delete(t),
    r.size || (e[cu] = void 0))
}
function A1(e) {
    requestAnimationFrame( () => {
        requestAnimationFrame(e)
    }
    )
}
let s_ = 0;
function M1(e, t, r, n) {
    const i = e._endId = ++s_
      , s = () => {
        i === e._endId && n()
    }
    ;
    if (r)
        return setTimeout(s, r);
    const {type: o, timeout: a, propCount: u} = o_(e, t);
    if (!o)
        return n();
    const c = o + "end";
    let l = 0;
    const p = () => {
        e.removeEventListener(c, h),
        s()
    }
      , h = g => {
        g.target === e && ++l >= u && p()
    }
    ;
    setTimeout( () => {
        l < u && p()
    }
    , a + 1),
    e.addEventListener(c, h)
}
function o_(e, t) {
    const r = window.getComputedStyle(e)
      , n = S => (r[S] || "").split(", ")
      , i = n(`${_i}Delay`)
      , s = n(`${_i}Duration`)
      , o = I1(i, s)
      , a = n(`${Ea}Delay`)
      , u = n(`${Ea}Duration`)
      , c = I1(a, u);
    let l = null
      , p = 0
      , h = 0;
    t === _i ? o > 0 && (l = _i,
    p = o,
    h = s.length) : t === Ea ? c > 0 && (l = Ea,
    p = c,
    h = u.length) : (p = Math.max(o, c),
    l = p > 0 ? o > c ? _i : Ea : null,
    h = l ? l === _i ? s.length : u.length : 0);
    const g = l === _i && /\b(transform|all)(,|$)/.test(n(`${_i}Property`).toString());
    return {
        type: l,
        timeout: p,
        propCount: h,
        hasTransform: g
    }
}
function I1(e, t) {
    for (; e.length < t.length; )
        e = e.concat(e);
    return Math.max(...t.map( (r, n) => T1(r) + T1(e[n])))
}
function T1(e) {
    return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3
}
function a_() {
    return document.body.offsetHeight
}
function u_(e, t, r) {
    const n = e[cu];
    n && (t = (t ? [t, ...n] : [...n]).join(" ")),
    t == null ? e.removeAttribute("class") : r ? e.setAttribute("class", t) : e.className = t
}
const $l = Symbol("_vod")
  , Wv = Symbol("_vsh")
  , J$ = {
    beforeMount(e, {value: t}, {transition: r}) {
        e[$l] = e.style.display === "none" ? "" : e.style.display,
        r && t ? r.beforeEnter(e) : Sa(e, t)
    },
    mounted(e, {value: t}, {transition: r}) {
        r && t && r.enter(e)
    },
    updated(e, {value: t, oldValue: r}, {transition: n}) {
        !t != !r && (n ? t ? (n.beforeEnter(e),
        Sa(e, !0),
        n.enter(e)) : n.leave(e, () => {
            Sa(e, !1)
        }
        ) : Sa(e, t))
    },
    beforeUnmount(e, {value: t}) {
        Sa(e, t)
    }
};
function Sa(e, t) {
    e.style.display = t ? e[$l] : "none",
    e[Wv] = !t
}
const Vv = Symbol("");
function X$(e) {
    const t = Gn();
    if (!t)
        return;
    const r = t.ut = (i=e(t.proxy)) => {
        Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(s => hh(s, i))
    }
      , n = () => {
        const i = e(t.proxy);
        dh(t.subTree, i),
        r(i)
    }
    ;
    oS(n),
    vi( () => {
        const i = new MutationObserver(n);
        i.observe(t.subTree.el.parentNode, {
            childList: !0
        }),
        ca( () => i.disconnect())
    }
    )
}
function dh(e, t) {
    if (e.shapeFlag & 128) {
        const r = e.suspense;
        e = r.activeBranch,
        r.pendingBranch && !r.isHydrating && r.effects.push( () => {
            dh(r.activeBranch, t)
        }
        )
    }
    for (; e.component; )
        e = e.component.subTree;
    if (e.shapeFlag & 1 && e.el)
        hh(e.el, t);
    else if (e.type === tr)
        e.children.forEach(r => dh(r, t));
    else if (e.type === Ao) {
        let {el: r, anchor: n} = e;
        for (; r && (hh(r, t),
        r !== n); )
            r = r.nextSibling
    }
}
function hh(e, t) {
    if (e.nodeType === 1) {
        const r = e.style;
        let n = "";
        for (const i in t)
            r.setProperty(`--${i}`, t[i]),
            n += `--${i}: ${t[i]};`;
        r[Vv] = n
    }
}
const c_ = /(^|;)\s*display\s*:/;
function l_(e, t, r) {
    const n = e.style
      , i = xt(r);
    let s = !1;
    if (r && !i) {
        if (t)
            if (xt(t))
                for (const o of t.split(";")) {
                    const a = o.slice(0, o.indexOf(":")).trim();
                    r[a] == null && al(n, a, "")
                }
            else
                for (const o in t)
                    r[o] == null && al(n, o, "");
        for (const o in r)
            o === "display" && (s = !0),
            al(n, o, r[o])
    } else if (i) {
        if (t !== r) {
            const o = n[Vv];
            o && (r += ";" + o),
            n.cssText = r,
            s = c_.test(r)
        }
    } else
        t && e.removeAttribute("style");
    $l in e && (e[$l] = s ? n.display : "",
    e[Wv] && (n.display = "none"))
}
const C1 = /\s*!important$/;
function al(e, t, r) {
    if (Oe(r))
        r.forEach(n => al(e, t, n));
    else if (r == null && (r = ""),
    t.startsWith("--"))
        e.setProperty(t, r);
    else {
        const n = f_(e, t);
        C1.test(r) ? e.setProperty(Ys(n), r.replace(C1, ""), "important") : e[n] = r
    }
}
const k1 = ["Webkit", "Moz", "ms"]
  , t0 = {};
function f_(e, t) {
    const r = t0[t];
    if (r)
        return r;
    let n = Hn(t);
    if (n !== "filter" && n in e)
        return t0[t] = n;
    n = Af(n);
    for (let i = 0; i < k1.length; i++) {
        const s = k1[i] + n;
        if (s in e)
            return t0[t] = s
    }
    return t
}
const L1 = "http://www.w3.org/1999/xlink";
function d_(e, t, r, n, i) {
    if (n && t.startsWith("xlink:"))
        r == null ? e.removeAttributeNS(L1, t.slice(6, t.length)) : e.setAttributeNS(L1, t, r);
    else {
        const s = dE(t);
        r == null || s && !Fw(r) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : r)
    }
}
function h_(e, t, r, n, i, s, o) {
    if (t === "innerHTML" || t === "textContent") {
        n && o(n, i, s),
        e[t] = r ?? "";
        return
    }
    const a = e.tagName;
    if (t === "value" && a !== "PROGRESS" && !a.includes("-")) {
        const c = a === "OPTION" ? e.getAttribute("value") || "" : e.value
          , l = r ?? "";
        (c !== l || !("_value"in e)) && (e.value = l),
        r == null && e.removeAttribute(t),
        e._value = r;
        return
    }
    let u = !1;
    if (r === "" || r == null) {
        const c = typeof e[t];
        c === "boolean" ? r = Fw(r) : r == null && c === "string" ? (r = "",
        u = !0) : c === "number" && (r = 0,
        u = !0)
    }
    try {
        e[t] = r
    } catch {}
    u && e.removeAttribute(t)
}
function p_(e, t, r, n) {
    e.addEventListener(t, r, n)
}
function g_(e, t, r, n) {
    e.removeEventListener(t, r, n)
}
const O1 = Symbol("_vei");
function m_(e, t, r, n, i=null) {
    const s = e[O1] || (e[O1] = {})
      , o = s[t];
    if (n && o)
        o.value = n;
    else {
        const [a,u] = y_(t);
        if (n) {
            const c = s[t] = v_(n, i);
            p_(e, a, c, u)
        } else
            o && (g_(e, a, o, u),
            s[t] = void 0)
    }
}
const N1 = /(?:Once|Passive|Capture)$/;
function y_(e) {
    let t;
    if (N1.test(e)) {
        t = {};
        let n;
        for (; n = e.match(N1); )
            e = e.slice(0, e.length - n[0].length),
            t[n[0].toLowerCase()] = !0
    }
    return [e[2] === ":" ? e.slice(3) : Ys(e.slice(2)), t]
}
let r0 = 0;
const b_ = Promise.resolve()
  , w_ = () => r0 || (b_.then( () => r0 = 0),
r0 = Date.now());
function v_(e, t) {
    const r = n => {
        if (!n._vts)
            n._vts = Date.now();
        else if (n._vts <= r.attached)
            return;
        dn(x_(n, r.value), t, 5, [n])
    }
    ;
    return r.value = e,
    r.attached = w_(),
    r
}
function x_(e, t) {
    if (Oe(t)) {
        const r = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = () => {
            r.call(e),
            e._stopped = !0
        }
        ,
        t.map(n => i => !i._stopped && n && n(i))
    } else
        return t
}
const R1 = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123
  , E_ = (e, t, r, n, i, s, o, a, u) => {
    const c = i === "svg";
    t === "class" ? u_(e, n, c) : t === "style" ? l_(e, r, n) : Ku(t) ? Hp(t) || m_(e, t, r, n, o) : (t[0] === "." ? (t = t.slice(1),
    !0) : t[0] === "^" ? (t = t.slice(1),
    !1) : S_(e, t, n, c)) ? h_(e, t, n, s, o, a, u) : (t === "true-value" ? e._trueValue = n : t === "false-value" && (e._falseValue = n),
    d_(e, t, n, c))
}
;
function S_(e, t, r, n) {
    if (n)
        return !!(t === "innerHTML" || t === "textContent" || t in e && R1(t) && Pe(r));
    if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
        return !1;
    if (t === "width" || t === "height") {
        const i = e.tagName;
        if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
            return !1
    }
    return R1(t) && xt(r) ? !1 : t in e
}
const __ = ["ctrl", "shift", "alt", "meta"]
  , A_ = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => "button"in e && e.button !== 0,
    middle: e => "button"in e && e.button !== 1,
    right: e => "button"in e && e.button !== 2,
    exact: (e, t) => __.some(r => e[`${r}Key`] && !t.includes(r))
}
  , n0 = (e, t) => {
    const r = e._withMods || (e._withMods = {})
      , n = t.join(".");
    return r[n] || (r[n] = (i, ...s) => {
        for (let o = 0; o < t.length; o++) {
            const a = A_[t[o]];
            if (a && a(i, t))
                return
        }
        return e(i, ...s)
    }
    )
}
  , M_ = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}
  , eF = (e, t) => {
    const r = e._withKeys || (e._withKeys = {})
      , n = t.join(".");
    return r[n] || (r[n] = i => {
        if (!("key"in i))
            return;
        const s = Ys(i.key);
        if (t.some(o => o === s || M_[o] === s))
            return e(i)
    }
    )
}
  , Kv = Zt({
    patchProp: E_
}, r_);
let Ka, B1 = !1;
function I_() {
    return Ka || (Ka = US(Kv))
}
function T_() {
    return Ka = B1 ? Ka : zS(Kv),
    B1 = !0,
    Ka
}
const C_ = (...e) => {
    const t = I_().createApp(...e)
      , {mount: r} = t;
    return t.mount = n => {
        const i = Qv(n);
        if (!i)
            return;
        const s = t._component;
        !Pe(s) && !s.render && !s.template && (s.template = i.innerHTML),
        i.innerHTML = "";
        const o = r(i, !1, Gv(i));
        return i instanceof Element && (i.removeAttribute("v-cloak"),
        i.setAttribute("data-v-app", "")),
        o
    }
    ,
    t
}
  , k_ = (...e) => {
    const t = T_().createApp(...e)
      , {mount: r} = t;
    return t.mount = n => {
        const i = Qv(n);
        if (i)
            return r(i, !0, Gv(i))
    }
    ,
    t
}
;
function Gv(e) {
    if (e instanceof SVGElement)
        return "svg";
    if (typeof MathMLElement == "function" && e instanceof MathMLElement)
        return "mathml"
}
function Qv(e) {
    return xt(e) ? document.querySelector(e) : e
}
const L_ = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
  , O_ = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
  , N_ = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function R_(e, t) {
    if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype"in t) {
        B_(e);
        return
    }
    return t
}
function B_(e) {
    console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)
}
function Fl(e, t={}) {
    if (typeof e != "string")
        return e;
    const r = e.trim();
    if (e[0] === '"' && e.endsWith('"') && !e.includes("\\"))
        return r.slice(1, -1);
    if (r.length <= 9) {
        const n = r.toLowerCase();
        if (n === "true")
            return !0;
        if (n === "false")
            return !1;
        if (n === "undefined")
            return;
        if (n === "null")
            return null;
        if (n === "nan")
            return Number.NaN;
        if (n === "infinity")
            return Number.POSITIVE_INFINITY;
        if (n === "-infinity")
            return Number.NEGATIVE_INFINITY
    }
    if (!N_.test(e)) {
        if (t.strict)
            throw new SyntaxError("[destr] Invalid JSON");
        return e
    }
    try {
        if (L_.test(e) || O_.test(e)) {
            if (t.strict)
                throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(e, R_)
        }
        return JSON.parse(e)
    } catch (n) {
        if (t.strict)
            throw n;
        return e
    }
}
const P_ = /#/g
  , j_ = /&/g
  , D_ = /\//g
  , U_ = /=/g
  , hg = /\+/g
  , z_ = /%5e/gi
  , $_ = /%60/gi
  , F_ = /%7c/gi
  , H_ = /%20/gi;
function q_(e) {
    return encodeURI("" + e).replace(F_, "|")
}
function ph(e) {
    return q_(typeof e == "string" ? e : JSON.stringify(e)).replace(hg, "%2B").replace(H_, "+").replace(P_, "%23").replace(j_, "%26").replace($_, "`").replace(z_, "^").replace(D_, "%2F")
}
function i0(e) {
    return ph(e).replace(U_, "%3D")
}
function Hl(e="") {
    try {
        return decodeURIComponent("" + e)
    } catch {
        return "" + e
    }
}
function W_(e) {
    return Hl(e.replace(hg, " "))
}
function V_(e) {
    return Hl(e.replace(hg, " "))
}
function Yv(e="") {
    const t = {};
    e[0] === "?" && (e = e.slice(1));
    for (const r of e.split("&")) {
        const n = r.match(/([^=]+)=?(.*)/) || [];
        if (n.length < 2)
            continue;
        const i = W_(n[1]);
        if (i === "__proto__" || i === "constructor")
            continue;
        const s = V_(n[2] || "");
        t[i] === void 0 ? t[i] = s : Array.isArray(t[i]) ? t[i].push(s) : t[i] = [t[i], s]
    }
    return t
}
function K_(e, t) {
    return (typeof t == "number" || typeof t == "boolean") && (t = String(t)),
    t ? Array.isArray(t) ? t.map(r => `${i0(e)}=${ph(r)}`).join("&") : `${i0(e)}=${ph(t)}` : i0(e)
}
function G_(e) {
    return Object.keys(e).filter(t => e[t] !== void 0).map(t => K_(t, e[t])).filter(Boolean).join("&")
}
const Q_ = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/
  , Y_ = /^[\s\w\0+.-]{2,}:([/\\]{2})?/
  , Z_ = /^([/\\]\s*){2,}[^/\\]/
  , J_ = /^[\s\0]*(blob|data|javascript|vbscript):$/i
  , X_ = /\/$|\/\?|\/#/
  , e8 = /^\.?\//;
function xi(e, t={}) {
    return typeof t == "boolean" && (t = {
        acceptRelative: t
    }),
    t.strict ? Q_.test(e) : Y_.test(e) || (t.acceptRelative ? Z_.test(e) : !1)
}
function t8(e) {
    return !!e && J_.test(e)
}
function gh(e="", t) {
    return t ? X_.test(e) : e.endsWith("/")
}
function Df(e="", t) {
    if (!t)
        return (gh(e) ? e.slice(0, -1) : e) || "/";
    if (!gh(e, !0))
        return e || "/";
    let r = e
      , n = "";
    const i = e.indexOf("#");
    i >= 0 && (r = e.slice(0, i),
    n = e.slice(i));
    const [s,...o] = r.split("?");
    return ((s.endsWith("/") ? s.slice(0, -1) : s) || "/") + (o.length > 0 ? `?${o.join("?")}` : "") + n
}
function ql(e="", t) {
    if (!t)
        return e.endsWith("/") ? e : e + "/";
    if (gh(e, !0))
        return e || "/";
    let r = e
      , n = "";
    const i = e.indexOf("#");
    if (i >= 0 && (r = e.slice(0, i),
    n = e.slice(i),
    !r))
        return n;
    const [s,...o] = r.split("?");
    return s + "/" + (o.length > 0 ? `?${o.join("?")}` : "") + n
}
function r8(e="") {
    return e.startsWith("/")
}
function P1(e="") {
    return r8(e) ? e : "/" + e
}
function n8(e, t) {
    if (Zv(t) || xi(e))
        return e;
    const r = Df(t);
    return e.startsWith(r) ? e : zf(r, e)
}
function j1(e, t) {
    if (Zv(t))
        return e;
    const r = Df(t);
    if (!e.startsWith(r))
        return e;
    const n = e.slice(r.length);
    return n[0] === "/" ? n : "/" + n
}
function Uf(e, t) {
    const r = tc(e)
      , n = {
        ...Yv(r.search),
        ...t
    };
    return r.search = G_(n),
    o8(r)
}
function Zv(e) {
    return !e || e === "/"
}
function i8(e) {
    return e && e !== "/"
}
function zf(e, ...t) {
    let r = e || "";
    for (const n of t.filter(i => i8(i)))
        if (r) {
            const i = n.replace(e8, "");
            r = ql(r) + i
        } else
            r = n;
    return r
}
function Jv(...e) {
    var o, a, u, c;
    const t = /\/(?!\/)/
      , r = e.filter(Boolean)
      , n = [];
    let i = 0;
    for (const l of r)
        if (!(!l || l === "/")) {
            for (const [p,h] of l.split(t).entries())
                if (!(!h || h === ".")) {
                    if (h === "..") {
                        if (n.length === 1 && xi(n[0]))
                            continue;
                        n.pop(),
                        i--;
                        continue
                    }
                    if (p === 1 && ((o = n[n.length - 1]) != null && o.endsWith(":/"))) {
                        n[n.length - 1] += "/" + h;
                        continue
                    }
                    n.push(h),
                    i++
                }
        }
    let s = n.join("/");
    return i >= 0 ? (a = r[0]) != null && a.startsWith("/") && !s.startsWith("/") ? s = "/" + s : (u = r[0]) != null && u.startsWith("./") && !s.startsWith("./") && (s = "./" + s) : s = "../".repeat(-1 * i) + s,
    (c = r[r.length - 1]) != null && c.endsWith("/") && !s.endsWith("/") && (s += "/"),
    s
}
function s8(e, t, r={}) {
    return r.trailingSlash || (e = ql(e),
    t = ql(t)),
    r.leadingSlash || (e = P1(e),
    t = P1(t)),
    r.encoding || (e = Hl(e),
    t = Hl(t)),
    e === t
}
const Xv = Symbol.for("ufo:protocolRelative");
function tc(e="", t) {
    const r = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
    if (r) {
        const [,p,h=""] = r;
        return {
            protocol: p.toLowerCase(),
            pathname: h,
            href: p + h,
            auth: "",
            host: "",
            search: "",
            hash: ""
        }
    }
    if (!xi(e, {
        acceptRelative: !0
    }))
        return t ? tc(t + e) : D1(e);
    const [,n="",i,s=""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || []
      , [,o="",a=""] = s.match(/([^#/?]*)(.*)?/) || []
      , {pathname: u, search: c, hash: l} = D1(a.replace(/\/(?=[A-Za-z]:)/, ""));
    return {
        protocol: n.toLowerCase(),
        auth: i ? i.slice(0, Math.max(0, i.length - 1)) : "",
        host: o,
        pathname: u,
        search: c,
        hash: l,
        [Xv]: !n
    }
}
function D1(e="") {
    const [t="",r="",n=""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
    return {
        pathname: t,
        search: r,
        hash: n
    }
}
function o8(e) {
    const t = e.pathname || ""
      , r = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : ""
      , n = e.hash || ""
      , i = e.auth ? e.auth + "@" : ""
      , s = e.host || "";
    return (e.protocol || e[Xv] ? (e.protocol || "") + "//" : "") + i + s + t + r + n
}
class a8 extends Error {
    constructor(t, r) {
        super(t, r),
        this.name = "FetchError",
        r != null && r.cause && !this.cause && (this.cause = r.cause)
    }
}
function u8(e) {
    var u, c, l, p, h;
    const t = ((u = e.error) == null ? void 0 : u.message) || ((c = e.error) == null ? void 0 : c.toString()) || ""
      , r = ((l = e.request) == null ? void 0 : l.method) || ((p = e.options) == null ? void 0 : p.method) || "GET"
      , n = ((h = e.request) == null ? void 0 : h.url) || String(e.request) || "/"
      , i = `[${r}] ${JSON.stringify(n)}`
      , s = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>"
      , o = `${i}: ${s}${t ? ` ${t}` : ""}`
      , a = new a8(o,e.error ? {
        cause: e.error
    } : void 0);
    for (const g of ["request", "options", "response"])
        Object.defineProperty(a, g, {
            get() {
                return e[g]
            }
        });
    for (const [g,S] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]])
        Object.defineProperty(a, g, {
            get() {
                return e.response && e.response[S]
            }
        });
    return a
}
const c8 = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
function U1(e="GET") {
    return c8.has(e.toUpperCase())
}
function l8(e) {
    if (e === void 0)
        return !1;
    const t = typeof e;
    return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function"
}
const f8 = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"])
  , d8 = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function h8(e="") {
    if (!e)
        return "json";
    const t = e.split(";").shift() || "";
    return d8.test(t) ? "json" : f8.has(t) || t.startsWith("text/") ? "text" : "blob"
}
function p8(e, t, r=globalThis.Headers) {
    const n = {
        ...t,
        ...e
    };
    if (t != null && t.params && (e != null && e.params) && (n.params = {
        ...t == null ? void 0 : t.params,
        ...e == null ? void 0 : e.params
    }),
    t != null && t.query && (e != null && e.query) && (n.query = {
        ...t == null ? void 0 : t.query,
        ...e == null ? void 0 : e.query
    }),
    t != null && t.headers && (e != null && e.headers)) {
        n.headers = new r((t == null ? void 0 : t.headers) || {});
        for (const [i,s] of new r((e == null ? void 0 : e.headers) || {}))
            n.headers.set(i, s)
    }
    return n
}
const g8 = new Set([408, 409, 425, 429, 500, 502, 503, 504])
  , m8 = new Set([101, 204, 205, 304]);
function e2(e={}) {
    const {fetch: t=globalThis.fetch, Headers: r=globalThis.Headers, AbortController: n=globalThis.AbortController} = e;
    async function i(a) {
        const u = a.error && a.error.name === "AbortError" && !a.options.timeout || !1;
        if (a.options.retry !== !1 && !u) {
            let l;
            typeof a.options.retry == "number" ? l = a.options.retry : l = U1(a.options.method) ? 0 : 1;
            const p = a.response && a.response.status || 500;
            if (l > 0 && (Array.isArray(a.options.retryStatusCodes) ? a.options.retryStatusCodes.includes(p) : g8.has(p))) {
                const h = a.options.retryDelay || 0;
                return h > 0 && await new Promise(g => setTimeout(g, h)),
                s(a.request, {
                    ...a.options,
                    retry: l - 1
                })
            }
        }
        const c = u8(a);
        throw Error.captureStackTrace && Error.captureStackTrace(c, s),
        c
    }
    const s = async function(u, c={}) {
        var g;
        const l = {
            request: u,
            options: p8(c, e.defaults, r),
            response: void 0,
            error: void 0
        };
        l.options.method = (g = l.options.method) == null ? void 0 : g.toUpperCase(),
        l.options.onRequest && await l.options.onRequest(l),
        typeof l.request == "string" && (l.options.baseURL && (l.request = n8(l.request, l.options.baseURL)),
        (l.options.query || l.options.params) && (l.request = Uf(l.request, {
            ...l.options.params,
            ...l.options.query
        }))),
        l.options.body && U1(l.options.method) && (l8(l.options.body) ? (l.options.body = typeof l.options.body == "string" ? l.options.body : JSON.stringify(l.options.body),
        l.options.headers = new r(l.options.headers || {}),
        l.options.headers.has("content-type") || l.options.headers.set("content-type", "application/json"),
        l.options.headers.has("accept") || l.options.headers.set("accept", "application/json")) : ("pipeTo"in l.options.body && typeof l.options.body.pipeTo == "function" || typeof l.options.body.pipe == "function") && ("duplex"in l.options || (l.options.duplex = "half")));
        let p;
        if (!l.options.signal && l.options.timeout) {
            const S = new n;
            p = setTimeout( () => S.abort(), l.options.timeout),
            l.options.signal = S.signal
        }
        try {
            l.response = await t(l.request, l.options)
        } catch (S) {
            return l.error = S,
            l.options.onRequestError && await l.options.onRequestError(l),
            await i(l)
        } finally {
            p && clearTimeout(p)
        }
        if (l.response.body && !m8.has(l.response.status) && l.options.method !== "HEAD") {
            const S = (l.options.parseResponse ? "json" : l.options.responseType) || h8(l.response.headers.get("content-type") || "");
            switch (S) {
            case "json":
                {
                    const x = await l.response.text()
                      , v = l.options.parseResponse || Fl;
                    l.response._data = v(x);
                    break
                }
            case "stream":
                {
                    l.response._data = l.response.body;
                    break
                }
            default:
                l.response._data = await l.response[S]()
            }
        }
        return l.options.onResponse && await l.options.onResponse(l),
        !l.options.ignoreResponseError && l.response.status >= 400 && l.response.status < 600 ? (l.options.onResponseError && await l.options.onResponseError(l),
        await i(l)) : l.response
    }
      , o = async function(u, c) {
        return (await s(u, c))._data
    };
    return o.raw = s,
    o.native = (...a) => t(...a),
    o.create = (a={}) => e2({
        ...e,
        defaults: {
            ...e.defaults,
            ...a
        }
    }),
    o
}
const pg = function() {
    if (typeof globalThis < "u")
        return globalThis;
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global < "u")
        return global;
    throw new Error("unable to locate global object")
}()
  , y8 = pg.fetch || ( () => Promise.reject(new Error("[ofetch] global.fetch is not supported!")))
  , b8 = pg.Headers
  , w8 = pg.AbortController
  , v8 = e2({
    fetch: y8,
    Headers: b8,
    AbortController: w8
})
  , x8 = v8
  , E8 = () => {
    var e;
    return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {}
}
  , Wl = E8().app
  , S8 = () => Wl.baseURL
  , _8 = () => Wl.buildAssetsDir
  , gg = (...e) => Jv(t2(), _8(), ...e)
  , t2 = (...e) => {
    const t = Wl.cdnURL || Wl.baseURL;
    return e.length ? Jv(t, ...e) : t
}
;
globalThis.__buildAssetsURL = gg,
globalThis.__publicAssetsURL = t2;
globalThis.$fetch || (globalThis.$fetch = x8.create({
    baseURL: S8()
}));
function mh(e, t={}, r) {
    for (const n in e) {
        const i = e[n]
          , s = r ? `${r}:${n}` : n;
        typeof i == "object" && i !== null ? mh(i, t, s) : typeof i == "function" && (t[s] = i)
    }
    return t
}
const A8 = {
    run: e => e()
}
  , M8 = () => A8
  , r2 = typeof console.createTask < "u" ? console.createTask : M8;
function I8(e, t) {
    const r = t.shift()
      , n = r2(r);
    return e.reduce( (i, s) => i.then( () => n.run( () => s(...t))), Promise.resolve())
}
function T8(e, t) {
    const r = t.shift()
      , n = r2(r);
    return Promise.all(e.map(i => n.run( () => i(...t))))
}
function s0(e, t) {
    for (const r of [...e])
        r(t)
}
class C8 {
    constructor() {
        this._hooks = {},
        this._before = void 0,
        this._after = void 0,
        this._deprecatedMessages = void 0,
        this._deprecatedHooks = {},
        this.hook = this.hook.bind(this),
        this.callHook = this.callHook.bind(this),
        this.callHookWith = this.callHookWith.bind(this)
    }
    hook(t, r, n={}) {
        if (!t || typeof r != "function")
            return () => {}
            ;
        const i = t;
        let s;
        for (; this._deprecatedHooks[t]; )
            s = this._deprecatedHooks[t],
            t = s.to;
        if (s && !n.allowDeprecated) {
            let o = s.message;
            o || (o = `${i} hook has been deprecated` + (s.to ? `, please use ${s.to}` : "")),
            this._deprecatedMessages || (this._deprecatedMessages = new Set),
            this._deprecatedMessages.has(o) || (console.warn(o),
            this._deprecatedMessages.add(o))
        }
        if (!r.name)
            try {
                Object.defineProperty(r, "name", {
                    get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb",
                    configurable: !0
                })
            } catch {}
        return this._hooks[t] = this._hooks[t] || [],
        this._hooks[t].push(r),
        () => {
            r && (this.removeHook(t, r),
            r = void 0)
        }
    }
    hookOnce(t, r) {
        let n, i = (...s) => (typeof n == "function" && n(),
        n = void 0,
        i = void 0,
        r(...s));
        return n = this.hook(t, i),
        n
    }
    removeHook(t, r) {
        if (this._hooks[t]) {
            const n = this._hooks[t].indexOf(r);
            n !== -1 && this._hooks[t].splice(n, 1),
            this._hooks[t].length === 0 && delete this._hooks[t]
        }
    }
    deprecateHook(t, r) {
        this._deprecatedHooks[t] = typeof r == "string" ? {
            to: r
        } : r;
        const n = this._hooks[t] || [];
        delete this._hooks[t];
        for (const i of n)
            this.hook(t, i)
    }
    deprecateHooks(t) {
        Object.assign(this._deprecatedHooks, t);
        for (const r in t)
            this.deprecateHook(r, t[r])
    }
    addHooks(t) {
        const r = mh(t)
          , n = Object.keys(r).map(i => this.hook(i, r[i]));
        return () => {
            for (const i of n.splice(0, n.length))
                i()
        }
    }
    removeHooks(t) {
        const r = mh(t);
        for (const n in r)
            this.removeHook(n, r[n])
    }
    removeAllHooks() {
        for (const t in this._hooks)
            delete this._hooks[t]
    }
    callHook(t, ...r) {
        return r.unshift(t),
        this.callHookWith(I8, t, ...r)
    }
    callHookParallel(t, ...r) {
        return r.unshift(t),
        this.callHookWith(T8, t, ...r)
    }
    callHookWith(t, r, ...n) {
        const i = this._before || this._after ? {
            name: r,
            args: n,
            context: {}
        } : void 0;
        this._before && s0(this._before, i);
        const s = t(r in this._hooks ? [...this._hooks[r]] : [], n);
        return s instanceof Promise ? s.finally( () => {
            this._after && i && s0(this._after, i)
        }
        ) : (this._after && i && s0(this._after, i),
        s)
    }
    beforeEach(t) {
        return this._before = this._before || [],
        this._before.push(t),
        () => {
            if (this._before !== void 0) {
                const r = this._before.indexOf(t);
                r !== -1 && this._before.splice(r, 1)
            }
        }
    }
    afterEach(t) {
        return this._after = this._after || [],
        this._after.push(t),
        () => {
            if (this._after !== void 0) {
                const r = this._after.indexOf(t);
                r !== -1 && this._after.splice(r, 1)
            }
        }
    }
}
function n2() {
    return new C8
}
function k8(e={}) {
    let t, r = !1;
    const n = o => {
        if (t && t !== o)
            throw new Error("Context conflict")
    }
    ;
    let i;
    if (e.asyncContext) {
        const o = e.AsyncLocalStorage || globalThis.AsyncLocalStorage;
        o ? i = new o : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
    }
    const s = () => {
        if (i && t === void 0) {
            const o = i.getStore();
            if (o !== void 0)
                return o
        }
        return t
    }
    ;
    return {
        use: () => {
            const o = s();
            if (o === void 0)
                throw new Error("Context is not available");
            return o
        }
        ,
        tryUse: () => s(),
        set: (o, a) => {
            a || n(o),
            t = o,
            r = !0
        }
        ,
        unset: () => {
            t = void 0,
            r = !1
        }
        ,
        call: (o, a) => {
            n(o),
            t = o;
            try {
                return i ? i.run(o, a) : a()
            } finally {
                r || (t = void 0)
            }
        }
        ,
        async callAsync(o, a) {
            t = o;
            const u = () => {
                t = o
            }
              , c = () => t === o ? u : void 0;
            yh.add(c);
            try {
                const l = i ? i.run(o, a) : a();
                return r || (t = void 0),
                await l
            } finally {
                yh.delete(c)
            }
        }
    }
}
function L8(e={}) {
    const t = {};
    return {
        get(r, n={}) {
            return t[r] || (t[r] = k8({
                ...e,
                ...n
            })),
            t[r],
            t[r]
        }
    }
}
const Vl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {}
  , z1 = "__unctx__"
  , O8 = Vl[z1] || (Vl[z1] = L8())
  , N8 = (e, t={}) => O8.get(e, t)
  , $1 = "__unctx_async_handlers__"
  , yh = Vl[$1] || (Vl[$1] = new Set);
function lu(e) {
    const t = [];
    for (const i of yh) {
        const s = i();
        s && t.push(s)
    }
    const r = () => {
        for (const i of t)
            i()
    }
    ;
    let n = e();
    return n && typeof n == "object" && "catch"in n && (n = n.catch(i => {
        throw r(),
        i
    }
    )),
    [n, r]
}
const i2 = N8("nuxt-app", {
    asyncContext: !1
})
  , R8 = "__nuxt_plugin";
function B8(e) {
    let t = 0;
    const r = {
        _scope: Mf(),
        provide: void 0,
        globalName: "nuxt",
        versions: {
            get nuxt() {
                return "3.11.2"
            },
            get vue() {
                return r.vueApp.version
            }
        },
        payload: Vn({
            data: {},
            state: {},
            once: new Set,
            _errors: {},
            ...window.__NUXT__ ?? {}
        }),
        static: {
            data: {}
        },
        runWithContext: i => r._scope.run( () => D8(r, i)),
        isHydrating: !0,
        deferHydration() {
            if (!r.isHydrating)
                return () => {}
                ;
            t++;
            let i = !1;
            return () => {
                if (!i && (i = !0,
                t--,
                t === 0))
                    return r.isHydrating = !1,
                    r.callHook("app:suspense:resolve")
            }
        },
        _asyncDataPromises: {},
        _asyncData: {},
        _payloadRevivers: {},
        ...e
    };
    r.hooks = n2(),
    r.hook = r.hooks.hook,
    r.callHook = r.hooks.callHook,
    r.provide = (i, s) => {
        const o = "$" + i;
        Cc(r, o, s),
        Cc(r.vueApp.config.globalProperties, o, s)
    }
    ,
    Cc(r.vueApp, "$nuxt", r),
    Cc(r.vueApp.config.globalProperties, "$nuxt", r);
    {
        window.addEventListener("nuxt.preloadError", s => {
            r.callHook("app:chunkError", {
                error: s.payload
            })
        }
        ),
        window.useNuxtApp = window.useNuxtApp || ut;
        const i = r.hook("app:error", (...s) => {
            console.error("[nuxt] error caught during app initialization", ...s)
        }
        );
        r.hook("app:mounted", i)
    }
    const n = r.payload.config;
    return r.provide("config", n),
    r
}
async function P8(e, t) {
    if (t.hooks && e.hooks.addHooks(t.hooks),
    typeof t == "function") {
        const {provide: r} = await e.runWithContext( () => t(e)) || {};
        if (r && typeof r == "object")
            for (const n in r)
                e.provide(n, r[n])
    }
}
async function j8(e, t) {
    const r = []
      , n = []
      , i = []
      , s = [];
    let o = 0;
    async function a(u) {
        var l;
        const c = ((l = u.dependsOn) == null ? void 0 : l.filter(p => t.some(h => h._name === p) && !r.includes(p))) ?? [];
        if (c.length > 0)
            n.push([new Set(c), u]);
        else {
            const p = P8(e, u).then(async () => {
                u._name && (r.push(u._name),
                await Promise.all(n.map(async ([h,g]) => {
                    h.has(u._name) && (h.delete(u._name),
                    h.size === 0 && (o++,
                    await a(g)))
                }
                )))
            }
            );
            u.parallel ? i.push(p.catch(h => s.push(h))) : await p
        }
    }
    for (const u of t)
        await a(u);
    if (await Promise.all(i),
    o)
        for (let u = 0; u < o; u++)
            await Promise.all(i);
    if (s.length)
        throw s[0]
}
function _t(e) {
    if (typeof e == "function")
        return e;
    const t = e._name || e.name;
    return delete e.name,
    Object.assign(e.setup || ( () => {}
    ), e, {
        [R8]: !0,
        _name: t
    })
}
function D8(e, t, r) {
    const n = () => r ? t(...r) : t();
    return i2.set(e),
    e.vueApp.runWithContext(n)
}
function U8() {
    var t;
    let e;
    return cg() && (e = (t = Gn()) == null ? void 0 : t.appContext.app.$nuxt),
    e = e || i2.tryUse(),
    e || null
}
function ut() {
    const e = U8();
    if (!e)
        throw new Error("[nuxt] instance unavailable");
    return e
}
function os(e) {
    return ut().$config
}
function Cc(e, t, r) {
    Object.defineProperty(e, t, {
        get: () => r
    })
}
const F1 = Object.freeze({
    ignoreUnknown: !1,
    respectType: !1,
    respectFunctionNames: !1,
    respectFunctionProperties: !1,
    unorderedObjects: !0,
    unorderedArrays: !1,
    unorderedSets: !1,
    excludeKeys: void 0,
    excludeValues: void 0,
    replacer: void 0
});
function bh(e, t) {
    t ? t = {
        ...F1,
        ...t
    } : t = F1;
    const r = s2(t);
    return r.dispatch(e),
    r.toString()
}
const z8 = Object.freeze(["prototype", "__proto__", "constructor"]);
function s2(e) {
    let t = ""
      , r = new Map;
    const n = i => {
        t += i
    }
    ;
    return {
        toString() {
            return t
        },
        getContext() {
            return r
        },
        dispatch(i) {
            return e.replacer && (i = e.replacer(i)),
            this[i === null ? "null" : typeof i](i)
        },
        object(i) {
            if (i && typeof i.toJSON == "function")
                return this.object(i.toJSON());
            const s = Object.prototype.toString.call(i);
            let o = "";
            const a = s.length;
            a < 10 ? o = "unknown:[" + s + "]" : o = s.slice(8, a - 1),
            o = o.toLowerCase();
            let u = null;
            if ((u = r.get(i)) === void 0)
                r.set(i, r.size);
            else
                return this.dispatch("[CIRCULAR:" + u + "]");
            if (typeof Buffer < "u" && Buffer.isBuffer && Buffer.isBuffer(i))
                return n("buffer:"),
                n(i.toString("utf8"));
            if (o !== "object" && o !== "function" && o !== "asyncfunction")
                this[o] ? this[o](i) : e.ignoreUnknown || this.unkown(i, o);
            else {
                let c = Object.keys(i);
                e.unorderedObjects && (c = c.sort());
                let l = [];
                e.respectType !== !1 && !H1(i) && (l = z8),
                e.excludeKeys && (c = c.filter(h => !e.excludeKeys(h)),
                l = l.filter(h => !e.excludeKeys(h))),
                n("object:" + (c.length + l.length) + ":");
                const p = h => {
                    this.dispatch(h),
                    n(":"),
                    e.excludeValues || this.dispatch(i[h]),
                    n(",")
                }
                ;
                for (const h of c)
                    p(h);
                for (const h of l)
                    p(h)
            }
        },
        array(i, s) {
            if (s = s === void 0 ? e.unorderedArrays !== !1 : s,
            n("array:" + i.length + ":"),
            !s || i.length <= 1) {
                for (const u of i)
                    this.dispatch(u);
                return
            }
            const o = new Map
              , a = i.map(u => {
                const c = s2(e);
                c.dispatch(u);
                for (const [l,p] of c.getContext())
                    o.set(l, p);
                return c.toString()
            }
            );
            return r = o,
            a.sort(),
            this.array(a, !1)
        },
        date(i) {
            return n("date:" + i.toJSON())
        },
        symbol(i) {
            return n("symbol:" + i.toString())
        },
        unkown(i, s) {
            if (n(s),
            !!i && (n(":"),
            i && typeof i.entries == "function"))
                return this.array(Array.from(i.entries()), !0)
        },
        error(i) {
            return n("error:" + i.toString())
        },
        boolean(i) {
            return n("bool:" + i)
        },
        string(i) {
            n("string:" + i.length + ":"),
            n(i)
        },
        function(i) {
            n("fn:"),
            H1(i) ? this.dispatch("[native]") : this.dispatch(i.toString()),
            e.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(i.name)),
            e.respectFunctionProperties && this.object(i)
        },
        number(i) {
            return n("number:" + i)
        },
        xml(i) {
            return n("xml:" + i.toString())
        },
        null() {
            return n("Null")
        },
        undefined() {
            return n("Undefined")
        },
        regexp(i) {
            return n("regex:" + i.toString())
        },
        uint8array(i) {
            return n("uint8array:"),
            this.dispatch(Array.prototype.slice.call(i))
        },
        uint8clampedarray(i) {
            return n("uint8clampedarray:"),
            this.dispatch(Array.prototype.slice.call(i))
        },
        int8array(i) {
            return n("int8array:"),
            this.dispatch(Array.prototype.slice.call(i))
        },
        uint16array(i) {
            return n("uint16array:"),
            this.dispatch(Array.prototype.slice.call(i))
        },
        int16array(i) {
            return n("int16array:"),
            this.dispatch(Array.prototype.slice.call(i))
        },
        uint32array(i) {
            return n("uint32array:"),
            this.dispatch(Array.prototype.slice.call(i))
        },
        int32array(i) {
            return n("int32array:"),
            this.dispatch(Array.prototype.slice.call(i))
        },
        float32array(i) {
            return n("float32array:"),
            this.dispatch(Array.prototype.slice.call(i))
        },
        float64array(i) {
            return n("float64array:"),
            this.dispatch(Array.prototype.slice.call(i))
        },
        arraybuffer(i) {
            return n("arraybuffer:"),
            this.dispatch(new Uint8Array(i))
        },
        url(i) {
            return n("url:" + i.toString())
        },
        map(i) {
            n("map:");
            const s = [...i];
            return this.array(s, e.unorderedSets !== !1)
        },
        set(i) {
            n("set:");
            const s = [...i];
            return this.array(s, e.unorderedSets !== !1)
        },
        file(i) {
            return n("file:"),
            this.dispatch([i.name, i.size, i.type, i.lastModfied])
        },
        blob() {
            if (e.ignoreUnknown)
                return n("[blob]");
            throw new Error(`Hashing Blob objects is currently not supported
Use "options.replacer" or "options.ignoreUnknown"
`)
        },
        domwindow() {
            return n("domwindow")
        },
        bigint(i) {
            return n("bigint:" + i.toString())
        },
        process() {
            return n("process")
        },
        timer() {
            return n("timer")
        },
        pipe() {
            return n("pipe")
        },
        tcp() {
            return n("tcp")
        },
        udp() {
            return n("udp")
        },
        tty() {
            return n("tty")
        },
        statwatcher() {
            return n("statwatcher")
        },
        securecontext() {
            return n("securecontext")
        },
        connection() {
            return n("connection")
        },
        zlib() {
            return n("zlib")
        },
        context() {
            return n("context")
        },
        nodescript() {
            return n("nodescript")
        },
        httpparser() {
            return n("httpparser")
        },
        dataview() {
            return n("dataview")
        },
        signal() {
            return n("signal")
        },
        fsevent() {
            return n("fsevent")
        },
        tlswrap() {
            return n("tlswrap")
        }
    }
}
const o2 = "[native code] }"
  , $8 = o2.length;
function H1(e) {
    return typeof e != "function" ? !1 : Function.prototype.toString.call(e).slice(-$8) === o2
}
class Ji {
    constructor(t, r) {
        t = this.words = t || [],
        this.sigBytes = r === void 0 ? t.length * 4 : r
    }
    toString(t) {
        return (t || F8).stringify(this)
    }
    concat(t) {
        if (this.clamp(),
        this.sigBytes % 4)
            for (let r = 0; r < t.sigBytes; r++) {
                const n = t.words[r >>> 2] >>> 24 - r % 4 * 8 & 255;
                this.words[this.sigBytes + r >>> 2] |= n << 24 - (this.sigBytes + r) % 4 * 8
            }
        else
            for (let r = 0; r < t.sigBytes; r += 4)
                this.words[this.sigBytes + r >>> 2] = t.words[r >>> 2];
        return this.sigBytes += t.sigBytes,
        this
    }
    clamp() {
        this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8,
        this.words.length = Math.ceil(this.sigBytes / 4)
    }
    clone() {
        return new Ji([...this.words])
    }
}
const F8 = {
    stringify(e) {
        const t = [];
        for (let r = 0; r < e.sigBytes; r++) {
            const n = e.words[r >>> 2] >>> 24 - r % 4 * 8 & 255;
            t.push((n >>> 4).toString(16), (n & 15).toString(16))
        }
        return t.join("")
    }
}
  , H8 = {
    stringify(e) {
        const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
          , r = [];
        for (let n = 0; n < e.sigBytes; n += 3) {
            const i = e.words[n >>> 2] >>> 24 - n % 4 * 8 & 255
              , s = e.words[n + 1 >>> 2] >>> 24 - (n + 1) % 4 * 8 & 255
              , o = e.words[n + 2 >>> 2] >>> 24 - (n + 2) % 4 * 8 & 255
              , a = i << 16 | s << 8 | o;
            for (let u = 0; u < 4 && n * 8 + u * 6 < e.sigBytes * 8; u++)
                r.push(t.charAt(a >>> 6 * (3 - u) & 63))
        }
        return r.join("")
    }
}
  , q8 = {
    parse(e) {
        const t = e.length
          , r = [];
        for (let n = 0; n < t; n++)
            r[n >>> 2] |= (e.charCodeAt(n) & 255) << 24 - n % 4 * 8;
        return new Ji(r,t)
    }
}
  , W8 = {
    parse(e) {
        return q8.parse(unescape(encodeURIComponent(e)))
    }
};
class V8 {
    constructor() {
        this._data = new Ji,
        this._nDataBytes = 0,
        this._minBufferSize = 0,
        this.blockSize = 512 / 32
    }
    reset() {
        this._data = new Ji,
        this._nDataBytes = 0
    }
    _append(t) {
        typeof t == "string" && (t = W8.parse(t)),
        this._data.concat(t),
        this._nDataBytes += t.sigBytes
    }
    _doProcessBlock(t, r) {}
    _process(t) {
        let r, n = this._data.sigBytes / (this.blockSize * 4);
        t ? n = Math.ceil(n) : n = Math.max((n | 0) - this._minBufferSize, 0);
        const i = n * this.blockSize
          , s = Math.min(i * 4, this._data.sigBytes);
        if (i) {
            for (let o = 0; o < i; o += this.blockSize)
                this._doProcessBlock(this._data.words, o);
            r = this._data.words.splice(0, i),
            this._data.sigBytes -= s
        }
        return new Ji(r,s)
    }
}
class K8 extends V8 {
    update(t) {
        return this._append(t),
        this._process(),
        this
    }
    finalize(t) {
        t && this._append(t)
    }
}
const q1 = [1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225]
  , G8 = [1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998]
  , ds = [];
let Q8 = class extends K8 {
    constructor() {
        super(...arguments),
        this._hash = new Ji([...q1])
    }
    reset() {
        super.reset(),
        this._hash = new Ji([...q1])
    }
    _doProcessBlock(t, r) {
        const n = this._hash.words;
        let i = n[0]
          , s = n[1]
          , o = n[2]
          , a = n[3]
          , u = n[4]
          , c = n[5]
          , l = n[6]
          , p = n[7];
        for (let h = 0; h < 64; h++) {
            if (h < 16)
                ds[h] = t[r + h] | 0;
            else {
                const A = ds[h - 15]
                  , k = (A << 25 | A >>> 7) ^ (A << 14 | A >>> 18) ^ A >>> 3
                  , L = ds[h - 2]
                  , O = (L << 15 | L >>> 17) ^ (L << 13 | L >>> 19) ^ L >>> 10;
                ds[h] = k + ds[h - 7] + O + ds[h - 16]
            }
            const g = u & c ^ ~u & l
              , S = i & s ^ i & o ^ s & o
              , x = (i << 30 | i >>> 2) ^ (i << 19 | i >>> 13) ^ (i << 10 | i >>> 22)
              , v = (u << 26 | u >>> 6) ^ (u << 21 | u >>> 11) ^ (u << 7 | u >>> 25)
              , I = p + v + g + G8[h] + ds[h]
              , M = x + S;
            p = l,
            l = c,
            c = u,
            u = a + I | 0,
            a = o,
            o = s,
            s = i,
            i = I + M | 0
        }
        n[0] = n[0] + i | 0,
        n[1] = n[1] + s | 0,
        n[2] = n[2] + o | 0,
        n[3] = n[3] + a | 0,
        n[4] = n[4] + u | 0,
        n[5] = n[5] + c | 0,
        n[6] = n[6] + l | 0,
        n[7] = n[7] + p | 0
    }
    finalize(t) {
        super.finalize(t);
        const r = this._nDataBytes * 8
          , n = this._data.sigBytes * 8;
        return this._data.words[n >>> 5] |= 128 << 24 - n % 32,
        this._data.words[(n + 64 >>> 9 << 4) + 14] = Math.floor(r / 4294967296),
        this._data.words[(n + 64 >>> 9 << 4) + 15] = r,
        this._data.sigBytes = this._data.words.length * 4,
        this._process(),
        this._hash
    }
}
;
function Y8(e) {
    return new Q8().finalize(e).toString(H8)
}
function rF(e, t={}) {
    const r = typeof e == "string" ? e : bh(e, t);
    return Y8(r).slice(0, 10)
}
function Z8(e, t, r={}) {
    return e === t || bh(e, r) === bh(t, r)
}
function J8(e, t) {
    return {
        ctx: {
            table: e
        },
        matchAll: r => u2(r, e, t)
    }
}
function a2(e) {
    const t = {};
    for (const r in e)
        t[r] = r === "dynamic" ? new Map(Object.entries(e[r]).map( ([n,i]) => [n, a2(i)])) : new Map(Object.entries(e[r]));
    return t
}
function X8(e) {
    return J8(a2(e))
}
function u2(e, t, r) {
    r !== !0 && e.endsWith("/") && (e = e.slice(0, -1) || "/");
    const n = [];
    for (const [s,o] of W1(t.wildcard))
        (e === s || e.startsWith(s + "/")) && n.push(o);
    for (const [s,o] of W1(t.dynamic))
        if (e.startsWith(s + "/")) {
            const a = "/" + e.slice(s.length).split("/").splice(2).join("/");
            n.push(...u2(a, o))
        }
    const i = t.static.get(e);
    return i && n.push(i),
    n.filter(Boolean)
}
function W1(e) {
    return [...e.entries()].sort( (t, r) => t[0].length - r[0].length)
}
function o0(e) {
    if (e === null || typeof e != "object")
        return !1;
    const t = Object.getPrototypeOf(e);
    return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0
}
function wh(e, t, r=".", n) {
    if (!o0(t))
        return wh(e, {}, r, n);
    const i = Object.assign({}, t);
    for (const s in e) {
        if (s === "__proto__" || s === "constructor")
            continue;
        const o = e[s];
        o != null && (n && n(i, s, o, r) || (Array.isArray(o) && Array.isArray(i[s]) ? i[s] = [...o, ...i[s]] : o0(o) && o0(i[s]) ? i[s] = wh(o, i[s], (r ? `${r}.` : "") + s.toString(), n) : i[s] = o))
    }
    return i
}
function mg(e) {
    return (...t) => t.reduce( (r, n) => wh(r, n, "", e), {})
}
const yg = mg()
  , e5 = mg( (e, t, r) => {
    if (e[t] !== void 0 && typeof r == "function")
        return e[t] = r(e[t]),
        !0
}
);
function t5(e, t) {
    try {
        return t in e
    } catch {
        return !1
    }
}
var r5 = Object.defineProperty
  , n5 = (e, t, r) => t in e ? r5(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r
  , ps = (e, t, r) => (n5(e, typeof t != "symbol" ? t + "" : t, r),
r);
class vh extends Error {
    constructor(t, r={}) {
        super(t, r),
        ps(this, "statusCode", 500),
        ps(this, "fatal", !1),
        ps(this, "unhandled", !1),
        ps(this, "statusMessage"),
        ps(this, "data"),
        ps(this, "cause"),
        r.cause && !this.cause && (this.cause = r.cause)
    }
    toJSON() {
        const t = {
            message: this.message,
            statusCode: Eh(this.statusCode, 500)
        };
        return this.statusMessage && (t.statusMessage = c2(this.statusMessage)),
        this.data !== void 0 && (t.data = this.data),
        t
    }
}
ps(vh, "__h3_error__", !0);
function xh(e) {
    if (typeof e == "string")
        return new vh(e);
    if (i5(e))
        return e;
    const t = new vh(e.message ?? e.statusMessage ?? "",{
        cause: e.cause || e
    });
    if (t5(e, "stack"))
        try {
            Object.defineProperty(t, "stack", {
                get() {
                    return e.stack
                }
            })
        } catch {
            try {
                t.stack = e.stack
            } catch {}
        }
    if (e.data && (t.data = e.data),
    e.statusCode ? t.statusCode = Eh(e.statusCode, t.statusCode) : e.status && (t.statusCode = Eh(e.status, t.statusCode)),
    e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText),
    t.statusMessage) {
        const r = t.statusMessage;
        c2(t.statusMessage) !== r && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
    }
    return e.fatal !== void 0 && (t.fatal = e.fatal),
    e.unhandled !== void 0 && (t.unhandled = e.unhandled),
    t
}
function i5(e) {
    var t;
    return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0
}
const s5 = /[^\u0009\u0020-\u007E]/g;
function c2(e="") {
    return e.replace(s5, "")
}
function Eh(e, t=200) {
    return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)),
    e < 100 || e > 999) ? t : e
}
const l2 = Symbol("layout-meta")
  , la = Symbol("route")
  , Ur = () => {
    var e;
    return (e = ut()) == null ? void 0 : e.$router
}
  , bg = () => cg() ? Kt(la, ut()._route) : ut()._route;
function nF(e) {
    return e
}
const o5 = () => {
    try {
        if (ut()._processingMiddleware)
            return !0
    } catch {
        return !1
    }
    return !1
}
  , a5 = (e, t) => {
    e || (e = "/");
    const r = typeof e == "string" ? e : Uf(e.path || "/", e.query || {}) + (e.hash || "");
    if (t != null && t.open) {
        const {target: a="_blank", windowFeatures: u={}} = t.open
          , c = Object.entries(u).filter( ([l,p]) => p !== void 0).map( ([l,p]) => `${l.toLowerCase()}=${p}`).join(", ");
        return open(r, a, c),
        Promise.resolve()
    }
    const n = (t == null ? void 0 : t.external) || xi(r, {
        acceptRelative: !0
    });
    if (n) {
        if (!(t != null && t.external))
            throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
        const a = tc(r).protocol;
        if (a && t8(a))
            throw new Error(`Cannot navigate to a URL with '${a}' protocol.`)
    }
    const i = o5();
    if (!n && i)
        return e;
    const s = Ur()
      , o = ut();
    return n ? (o._scope.stop(),
    t != null && t.replace ? location.replace(r) : location.href = r,
    i ? o.isHydrating ? new Promise( () => {}
    ) : !1 : Promise.resolve()) : t != null && t.replace ? s.replace(e) : s.push(e)
}
  , f2 = "__nuxt_error"
  , $f = () => Xs(ut().payload, "error")
  , ho = e => {
    const t = Ff(e);
    try {
        const r = ut()
          , n = $f();
        r.hooks.callHook("app:error", t),
        n.value = n.value || t
    } catch {
        throw t
    }
    return t
}
  , d2 = async (e={}) => {
    const t = ut()
      , r = $f();
    t.callHook("app:error:cleared", e),
    e.redirect && await Ur().replace(e.redirect),
    r.value = null
}
  , u5 = e => !!e && typeof e == "object" && f2 in e
  , Ff = e => {
    const t = xh(e);
    return Object.defineProperty(t, f2, {
        value: !0,
        configurable: !1,
        writable: !1
    }),
    t
}
  , c5 = "modulepreload"
  , l5 = function(e, t) {
    return e[0] === "." ? new URL(e,t).href : e
}
  , V1 = {}
  , f5 = function(t, r, n) {
    let i = Promise.resolve();
    if (r && r.length > 0) {
        const s = document.getElementsByTagName("link")
          , o = document.querySelector("meta[property=csp-nonce]")
          , a = (o == null ? void 0 : o.nonce) || (o == null ? void 0 : o.getAttribute("nonce"));
        i = Promise.all(r.map(u => {
            if (u = l5(u, n),
            u in V1)
                return;
            V1[u] = !0;
            const c = u.endsWith(".css")
              , l = c ? '[rel="stylesheet"]' : "";
            if (!!n)
                for (let g = s.length - 1; g >= 0; g--) {
                    const S = s[g];
                    if (S.href === u && (!c || S.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${u}"]${l}`))
                return;
            const h = document.createElement("link");
            if (h.rel = c ? "stylesheet" : c5,
            c || (h.as = "script",
            h.crossOrigin = ""),
            h.href = u,
            a && h.setAttribute("nonce", a),
            document.head.appendChild(h),
            c)
                return new Promise( (g, S) => {
                    h.addEventListener("load", g),
                    h.addEventListener("error", () => S(new Error(`Unable to preload CSS for ${u}`)))
                }
                )
        }
        ))
    }
    return i.then( () => t()).catch(s => {
        const o = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (o.payload = s,
        window.dispatchEvent(o),
        !o.defaultPrevented)
            throw s
    }
    )
}
  , Be = (...e) => f5(...e).catch(t => {
    const r = new Event("nuxt.preloadError");
    throw r.payload = t,
    window.dispatchEvent(r),
    t
}
)
  , d5 = -1
  , h5 = -2
  , p5 = -3
  , g5 = -4
  , m5 = -5
  , y5 = -6;
function b5(e, t) {
    return w5(JSON.parse(e), t)
}
function w5(e, t) {
    if (typeof e == "number")
        return i(e, !0);
    if (!Array.isArray(e) || e.length === 0)
        throw new Error("Invalid input");
    const r = e
      , n = Array(r.length);
    function i(s, o=!1) {
        if (s === d5)
            return;
        if (s === p5)
            return NaN;
        if (s === g5)
            return 1 / 0;
        if (s === m5)
            return -1 / 0;
        if (s === y5)
            return -0;
        if (o)
            throw new Error("Invalid input");
        if (s in n)
            return n[s];
        const a = r[s];
        if (!a || typeof a != "object")
            n[s] = a;
        else if (Array.isArray(a))
            if (typeof a[0] == "string") {
                const u = a[0]
                  , c = t == null ? void 0 : t[u];
                if (c)
                    return n[s] = c(i(a[1]));
                switch (u) {
                case "Date":
                    n[s] = new Date(a[1]);
                    break;
                case "Set":
                    const l = new Set;
                    n[s] = l;
                    for (let g = 1; g < a.length; g += 1)
                        l.add(i(a[g]));
                    break;
                case "Map":
                    const p = new Map;
                    n[s] = p;
                    for (let g = 1; g < a.length; g += 2)
                        p.set(i(a[g]), i(a[g + 1]));
                    break;
                case "RegExp":
                    n[s] = new RegExp(a[1],a[2]);
                    break;
                case "Object":
                    n[s] = Object(a[1]);
                    break;
                case "BigInt":
                    n[s] = BigInt(a[1]);
                    break;
                case "null":
                    const h = Object.create(null);
                    n[s] = h;
                    for (let g = 1; g < a.length; g += 2)
                        h[a[g]] = i(a[g + 1]);
                    break;
                default:
                    throw new Error(`Unknown type ${u}`)
                }
            } else {
                const u = new Array(a.length);
                n[s] = u;
                for (let c = 0; c < a.length; c += 1) {
                    const l = a[c];
                    l !== h5 && (u[c] = i(l))
                }
            }
        else {
            const u = {};
            n[s] = u;
            for (const c in a) {
                const l = a[c];
                u[c] = i(l)
            }
        }
        return n[s]
    }
    return i(0)
}
function v5(e) {
    return Array.isArray(e) ? e : [e]
}
const x5 = ["title", "titleTemplate", "script", "style", "noscript"]
  , ul = ["base", "meta", "link", "style", "script", "noscript"]
  , E5 = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"]
  , S5 = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"]
  , h2 = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "children", "innerHTML", "textContent", "processTemplateParams"]
  , _5 = typeof window < "u";
function wg(e) {
    let t = 9;
    for (let r = 0; r < e.length; )
        t = Math.imul(t ^ e.charCodeAt(r++), 9 ** 9);
    return ((t ^ t >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}
function K1(e) {
    return e._h || wg(e._d ? e._d : `${e.tag}:${e.textContent || e.innerHTML || ""}:${Object.entries(e.props).map( ([t,r]) => `${t}:${String(r)}`).join(",")}`)
}
function p2(e, t) {
    const {props: r, tag: n} = e;
    if (S5.includes(n))
        return n;
    if (n === "link" && r.rel === "canonical")
        return "canonical";
    if (r.charset)
        return "charset";
    const i = ["id"];
    n === "meta" && i.push("name", "property", "http-equiv");
    for (const s of i)
        if (typeof r[s] < "u") {
            const o = String(r[s]);
            return t && !t(o) ? !1 : `${n}:${s}:${o}`
        }
    return !1
}
function G1(e, t) {
    return e == null ? t || null : typeof e == "function" ? e(t) : e
}
function g2(e, t) {
    const r = []
      , n = t.resolveKeyData || (s => s.key)
      , i = t.resolveValueData || (s => s.value);
    for (const [s,o] of Object.entries(e))
        r.push(...(Array.isArray(o) ? o : [o]).map(a => {
            const u = {
                key: s,
                value: a
            }
              , c = i(u);
            return typeof c == "object" ? g2(c, t) : Array.isArray(c) ? c : {
                [typeof t.key == "function" ? t.key(u) : t.key]: n(u),
                [typeof t.value == "function" ? t.value(u) : t.value]: c
            }
        }
        ).flat());
    return r
}
function m2(e, t) {
    return Object.entries(e).map( ([r,n]) => {
        if (typeof n == "object" && (n = m2(n, t)),
        t.resolve) {
            const i = t.resolve({
                key: r,
                value: n
            });
            if (typeof i < "u")
                return i
        }
        return typeof n == "number" && (n = n.toString()),
        typeof n == "string" && t.wrapValue && (n = n.replace(new RegExp(t.wrapValue,"g"), `\\${t.wrapValue}`),
        n = `${t.wrapValue}${n}${t.wrapValue}`),
        `${r}${t.keyValueSeparator || ""}${n}`
    }
    ).join(t.entrySeparator || "")
}
const br = e => ({
    keyValue: e,
    metaKey: "property"
})
  , a0 = e => ({
    keyValue: e
})
  , vg = {
    appleItunesApp: {
        unpack: {
            entrySeparator: ", ",
            resolve({key: e, value: t}) {
                return `${li(e)}=${t}`
            }
        }
    },
    articleExpirationTime: br("article:expiration_time"),
    articleModifiedTime: br("article:modified_time"),
    articlePublishedTime: br("article:published_time"),
    bookReleaseDate: br("book:release_date"),
    charset: {
        metaKey: "charset"
    },
    contentSecurityPolicy: {
        unpack: {
            entrySeparator: "; ",
            resolve({key: e, value: t}) {
                return `${li(e)} ${t}`
            }
        },
        metaKey: "http-equiv"
    },
    contentType: {
        metaKey: "http-equiv"
    },
    defaultStyle: {
        metaKey: "http-equiv"
    },
    fbAppId: br("fb:app_id"),
    msapplicationConfig: a0("msapplication-Config"),
    msapplicationTileColor: a0("msapplication-TileColor"),
    msapplicationTileImage: a0("msapplication-TileImage"),
    ogAudioSecureUrl: br("og:audio:secure_url"),
    ogAudioUrl: br("og:audio"),
    ogImageSecureUrl: br("og:image:secure_url"),
    ogImageUrl: br("og:image"),
    ogSiteName: br("og:site_name"),
    ogVideoSecureUrl: br("og:video:secure_url"),
    ogVideoUrl: br("og:video"),
    profileFirstName: br("profile:first_name"),
    profileLastName: br("profile:last_name"),
    profileUsername: br("profile:username"),
    refresh: {
        metaKey: "http-equiv",
        unpack: {
            entrySeparator: ";",
            resolve({key: e, value: t}) {
                if (e === "seconds")
                    return `${t}`
            }
        }
    },
    robots: {
        unpack: {
            entrySeparator: ", ",
            resolve({key: e, value: t}) {
                return typeof t == "boolean" ? `${li(e)}` : `${li(e)}:${t}`
            }
        }
    },
    xUaCompatible: {
        metaKey: "http-equiv"
    }
}
  , y2 = ["og", "book", "article", "profile"];
function b2(e) {
    var r;
    const t = li(e).split(":")[0];
    return y2.includes(t) ? "property" : ((r = vg[e]) == null ? void 0 : r.metaKey) || "name"
}
function A5(e) {
    var t;
    return ((t = vg[e]) == null ? void 0 : t.keyValue) || li(e)
}
function li(e) {
    const t = e.replace(/([A-Z])/g, "-$1").toLowerCase()
      , r = t.split("-")[0];
    return y2.includes(r) || r === "twitter" ? e.replace(/([A-Z])/g, ":$1").toLowerCase() : t
}
function Sh(e) {
    if (Array.isArray(e))
        return e.map(r => Sh(r));
    if (typeof e != "object" || Array.isArray(e))
        return e;
    const t = {};
    for (const [r,n] of Object.entries(e))
        t[li(r)] = Sh(n);
    return t
}
function M5(e, t) {
    const r = vg[t];
    return t === "refresh" ? `${e.seconds};url=${e.url}` : m2(Sh(e), {
        keyValueSeparator: "=",
        entrySeparator: ", ",
        resolve({value: n, key: i}) {
            if (n === null)
                return "";
            if (typeof n == "boolean")
                return `${i}`
        },
        ...r == null ? void 0 : r.unpack
    })
}
const w2 = ["og:image", "og:video", "og:audio", "twitter:image"];
function v2(e) {
    const t = {};
    return Object.entries(e).forEach( ([r,n]) => {
        String(n) !== "false" && r && (t[r] = n)
    }
    ),
    t
}
function Q1(e, t) {
    const r = v2(t)
      , n = li(e)
      , i = b2(n);
    if (w2.includes(n)) {
        const s = {};
        return Object.entries(r).forEach( ([o,a]) => {
            s[`${e}${o === "url" ? "" : `${o.charAt(0).toUpperCase()}${o.slice(1)}`}`] = a
        }
        ),
        x2(s).sort( (o, a) => {
            var u, c;
            return (((u = o[i]) == null ? void 0 : u.length) || 0) - (((c = a[i]) == null ? void 0 : c.length) || 0)
        }
        )
    }
    return [{
        [i]: n,
        ...r
    }]
}
function x2(e) {
    const t = []
      , r = {};
    Object.entries(e).forEach( ([i,s]) => {
        if (!Array.isArray(s)) {
            if (typeof s == "object" && s) {
                if (w2.includes(li(i))) {
                    t.push(...Q1(i, s));
                    return
                }
                r[i] = v2(s)
            } else
                r[i] = s;
            return
        }
        s.forEach(o => {
            t.push(...typeof o == "string" ? x2({
                [i]: o
            }) : Q1(i, o))
        }
        )
    }
    );
    const n = g2(r, {
        key({key: i}) {
            return b2(i)
        },
        value({key: i}) {
            return i === "charset" ? "charset" : "content"
        },
        resolveKeyData({key: i}) {
            return A5(i)
        },
        resolveValueData({value: i, key: s}) {
            return i === null ? "_null" : typeof i == "object" ? M5(i, s) : typeof i == "number" ? i.toString() : i
        }
    });
    return [...t, ...n].map(i => (i.content === "_null" && (i.content = null),
    i))
}
async function I5(e, t, r) {
    const n = {
        tag: e,
        props: await E2(typeof t == "object" && typeof t != "function" && !(t instanceof Promise) ? {
            ...t
        } : {
            [["script", "noscript", "style"].includes(e) ? "innerHTML" : "textContent"]: t
        }, ["templateParams", "titleTemplate"].includes(e))
    };
    return h2.forEach(i => {
        const s = typeof n.props[i] < "u" ? n.props[i] : r[i];
        typeof s < "u" && ((!["innerHTML", "textContent", "children"].includes(i) || x5.includes(n.tag)) && (n[i === "children" ? "innerHTML" : i] = s),
        delete n.props[i])
    }
    ),
    n.props.body && (n.tagPosition = "bodyClose",
    delete n.props.body),
    n.tag === "script" && typeof n.innerHTML == "object" && (n.innerHTML = JSON.stringify(n.innerHTML),
    n.props.type = n.props.type || "application/json"),
    Array.isArray(n.props.content) ? n.props.content.map(i => ({
        ...n,
        props: {
            ...n.props,
            content: i
        }
    })) : n
}
function T5(e, t) {
    var n;
    const r = e === "class" ? " " : ";";
    return typeof t == "object" && !Array.isArray(t) && (t = Object.entries(t).filter( ([,i]) => i).map( ([i,s]) => e === "style" ? `${i}:${s}` : i)),
    (n = Array.isArray(t) ? t.join(r) : t) == null ? void 0 : n.split(r).filter(i => i.trim()).filter(Boolean).join(r)
}
async function E2(e, t) {
    for (const r of Object.keys(e)) {
        if (["class", "style"].includes(r)) {
            e[r] = T5(r, e[r]);
            continue
        }
        if (e[r]instanceof Promise && (e[r] = await e[r]),
        !t && !h2.includes(r)) {
            const n = String(e[r])
              , i = r.startsWith("data-");
            n === "true" || n === "" ? e[r] = i ? "true" : !0 : e[r] || (i && n === "false" ? e[r] = "false" : delete e[r])
        }
    }
    return e
}
const C5 = 10;
async function k5(e) {
    const t = [];
    return Object.entries(e.resolvedInput).filter( ([r,n]) => typeof n < "u" && E5.includes(r)).forEach( ([r,n]) => {
        const i = v5(n);
        t.push(...i.map(s => I5(r, s, e)).flat())
    }
    ),
    (await Promise.all(t)).flat().filter(Boolean).map( (r, n) => (r._e = e._i,
    e.mode && (r._m = e.mode),
    r._p = (e._i << C5) + n,
    r))
}
const Y1 = {
    base: -10,
    title: 10
}
  , Z1 = {
    critical: -80,
    high: -10,
    low: 20
};
function Kl(e) {
    let t = 100;
    const r = e.tagPriority;
    return typeof r == "number" ? r : (e.tag === "meta" ? (e.props["http-equiv"] === "content-security-policy" && (t = -30),
    e.props.charset && (t = -20),
    e.props.name === "viewport" && (t = -15)) : e.tag === "link" && e.props.rel === "preconnect" ? t = 20 : e.tag in Y1 && (t = Y1[e.tag]),
    typeof r == "string" && r in Z1 ? t + Z1[r] : t)
}
const L5 = [{
    prefix: "before:",
    offset: -1
}, {
    prefix: "after:",
    offset: 1
}]
  , J1 = ["onload", "onerror", "onabort", "onprogress", "onloadstart"]
  , Mi = "%separator";
function cl(e, t, r) {
    if (typeof e != "string" || !e.includes("%"))
        return e;
    function n(o) {
        let a;
        return ["s", "pageTitle"].includes(o) ? a = t.pageTitle : o.includes(".") ? a = o.split(".").reduce( (u, c) => u && u[c] || void 0, t) : a = t[o],
        typeof a < "u" ? (a || "").replace(/"/g, '\\"') : !1
    }
    let i = e;
    try {
        i = decodeURI(e)
    } catch {}
    return (i.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach(o => {
        const a = n(o.slice(1));
        typeof a == "string" && (e = e.replace(new RegExp(`\\${o}(\\W|$)`,"g"), (u, c) => `${a}${c}`).trim())
    }
    ),
    e.includes(Mi) && (e.endsWith(Mi) && (e = e.slice(0, -Mi.length).trim()),
    e.startsWith(Mi) && (e = e.slice(Mi.length).trim()),
    e = e.replace(new RegExp(`\\${Mi}\\s*\\${Mi}`,"g"), Mi),
    e = cl(e, {
        separator: r
    }, r)),
    e
}
async function S2(e, t={}) {
    var l;
    const r = t.document || e.resolvedOptions.document;
    if (!r || !e.dirty)
        return;
    const n = {
        shouldRender: !0,
        tags: []
    };
    if (await e.hooks.callHook("dom:beforeRender", n),
    !n.shouldRender)
        return;
    const i = (await e.resolveTags()).map(p => ({
        tag: p,
        id: ul.includes(p.tag) ? K1(p) : p.tag,
        shouldRender: !0
    }));
    let s = e._dom;
    if (!s) {
        s = {
            elMap: {
                htmlAttrs: r.documentElement,
                bodyAttrs: r.body
            }
        };
        for (const p of ["body", "head"]) {
            const h = (l = r[p]) == null ? void 0 : l.children
              , g = [];
            for (const S of [...h].filter(x => ul.includes(x.tagName.toLowerCase()))) {
                const x = {
                    tag: S.tagName.toLowerCase(),
                    props: await E2(S.getAttributeNames().reduce( (M, A) => ({
                        ...M,
                        [A]: S.getAttribute(A)
                    }), {})),
                    innerHTML: S.innerHTML
                };
                let v = 1
                  , I = p2(x);
                for (; I && g.find(M => M._d === I); )
                    I = `${I}:${v++}`;
                x._d = I || void 0,
                g.push(x),
                s.elMap[S.getAttribute("data-hid") || K1(x)] = S
            }
        }
    }
    s.pendingSideEffects = {
        ...s.sideEffects || {}
    },
    s.sideEffects = {};
    function o(p, h, g) {
        const S = `${p}:${h}`;
        s.sideEffects[S] = g,
        delete s.pendingSideEffects[S]
    }
    function a({id: p, $el: h, tag: g}) {
        const S = g.tag.endsWith("Attrs");
        s.elMap[p] = h,
        S || (["textContent", "innerHTML"].forEach(x => {
            g[x] && g[x] !== h[x] && (h[x] = g[x])
        }
        ),
        o(p, "el", () => {
            var x;
            (x = s.elMap[p]) == null || x.remove(),
            delete s.elMap[p]
        }
        ));
        for (const [x,v] of Object.entries(g._eventHandlers || {}))
            h.getAttribute(`data-${x}`) !== "" && ((g.tag === "bodyAttrs" ? r.defaultView : h).addEventListener(x.replace("on", ""), v.bind(h)),
            h.setAttribute(`data-${x}`, ""));
        Object.entries(g.props).forEach( ([x,v]) => {
            const I = `attr:${x}`;
            if (x === "class")
                for (const M of (v || "").split(" ").filter(Boolean))
                    S && o(p, `${I}:${M}`, () => h.classList.remove(M)),
                    !h.classList.contains(M) && h.classList.add(M);
            else if (x === "style")
                for (const M of (v || "").split(";").filter(Boolean)) {
                    const [A,...k] = M.split(":").map(L => L.trim());
                    o(p, `${I}:${M}:${A}`, () => {
                        h.style.removeProperty(A)
                    }
                    ),
                    h.style.setProperty(A, k.join(":"))
                }
            else
                h.getAttribute(x) !== v && h.setAttribute(x, v === !0 ? "" : String(v)),
                S && o(p, I, () => h.removeAttribute(x))
        }
        )
    }
    const u = []
      , c = {
        bodyClose: void 0,
        bodyOpen: void 0,
        head: void 0
    };
    for (const p of i) {
        const {tag: h, shouldRender: g, id: S} = p;
        if (g) {
            if (h.tag === "title") {
                r.title = h.textContent;
                continue
            }
            p.$el = p.$el || s.elMap[S],
            p.$el ? a(p) : ul.includes(h.tag) && u.push(p)
        }
    }
    for (const p of u) {
        const h = p.tag.tagPosition || "head";
        p.$el = r.createElement(p.tag.tag),
        a(p),
        c[h] = c[h] || r.createDocumentFragment(),
        c[h].appendChild(p.$el)
    }
    for (const p of i)
        await e.hooks.callHook("dom:renderTag", p, r, o);
    c.head && r.head.appendChild(c.head),
    c.bodyOpen && r.body.insertBefore(c.bodyOpen, r.body.firstChild),
    c.bodyClose && r.body.appendChild(c.bodyClose),
    Object.values(s.pendingSideEffects).forEach(p => p()),
    e._dom = s,
    e.dirty = !1,
    await e.hooks.callHook("dom:rendered", {
        renders: i
    })
}
async function O5(e, t={}) {
    const r = t.delayFn || (n => setTimeout(n, 10));
    return e._domUpdatePromise = e._domUpdatePromise || new Promise(n => r(async () => {
        await S2(e, t),
        delete e._domUpdatePromise,
        n()
    }
    ))
}
function N5(e) {
    return t => {
        var n, i;
        const r = ((i = (n = t.resolvedOptions.document) == null ? void 0 : n.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : i.innerHTML) || !1;
        return r && t.push(JSON.parse(r)),
        {
            mode: "client",
            hooks: {
                "entries:updated": function(s) {
                    O5(s, e)
                }
            }
        }
    }
}
const R5 = ["templateParams", "htmlAttrs", "bodyAttrs"]
  , B5 = {
    hooks: {
        "tag:normalise": function({tag: e}) {
            ["hid", "vmid", "key"].forEach(n => {
                e.props[n] && (e.key = e.props[n],
                delete e.props[n])
            }
            );
            const r = p2(e) || (e.key ? `${e.tag}:${e.key}` : !1);
            r && (e._d = r)
        },
        "tags:resolve": function(e) {
            const t = {};
            e.tags.forEach(n => {
                const i = (n.key ? `${n.tag}:${n.key}` : n._d) || n._p
                  , s = t[i];
                if (s) {
                    let a = n == null ? void 0 : n.tagDuplicateStrategy;
                    if (!a && R5.includes(n.tag) && (a = "merge"),
                    a === "merge") {
                        const u = s.props;
                        ["class", "style"].forEach(c => {
                            u[c] && (n.props[c] ? (c === "style" && !u[c].endsWith(";") && (u[c] += ";"),
                            n.props[c] = `${u[c]} ${n.props[c]}`) : n.props[c] = u[c])
                        }
                        ),
                        t[i].props = {
                            ...u,
                            ...n.props
                        };
                        return
                    } else if (n._e === s._e) {
                        s._duped = s._duped || [],
                        n._d = `${s._d}:${s._duped.length + 1}`,
                        s._duped.push(n);
                        return
                    } else if (Kl(n) > Kl(s))
                        return
                }
                const o = Object.keys(n.props).length + (n.innerHTML ? 1 : 0) + (n.textContent ? 1 : 0);
                if (ul.includes(n.tag) && o === 0) {
                    delete t[i];
                    return
                }
                t[i] = n
            }
            );
            const r = [];
            Object.values(t).forEach(n => {
                const i = n._duped;
                delete n._duped,
                r.push(n),
                i && r.push(...i)
            }
            ),
            e.tags = r,
            e.tags = e.tags.filter(n => !(n.tag === "meta" && (n.props.name || n.props.property) && !n.props.content))
        }
    }
}
  , P5 = {
    mode: "server",
    hooks: {
        "tags:resolve": function(e) {
            const t = {};
            e.tags.filter(r => ["titleTemplate", "templateParams", "title"].includes(r.tag) && r._m === "server").forEach(r => {
                t[r.tag] = r.tag.startsWith("title") ? r.textContent : r.props
            }
            ),
            Object.keys(t).length && e.tags.push({
                tag: "script",
                innerHTML: JSON.stringify(t),
                props: {
                    id: "unhead:payload",
                    type: "application/json"
                }
            })
        }
    }
}
  , j5 = ["script", "link", "bodyAttrs"]
  , D5 = e => ({
    hooks: {
        "tags:resolve": function(t) {
            for (const r of t.tags.filter(n => j5.includes(n.tag)))
                Object.entries(r.props).forEach( ([n,i]) => {
                    n.startsWith("on") && typeof i == "function" && (e.ssr && J1.includes(n) ? r.props[n] = `this.dataset.${n}fired = true` : delete r.props[n],
                    r._eventHandlers = r._eventHandlers || {},
                    r._eventHandlers[n] = i)
                }
                ),
                e.ssr && r._eventHandlers && (r.props.src || r.props.href) && (r.key = r.key || wg(r.props.src || r.props.href))
        },
        "dom:renderTag": function({$el: t, tag: r}) {
            var n, i;
            for (const s of Object.keys((t == null ? void 0 : t.dataset) || {}).filter(o => J1.some(a => `${a}fired` === o))) {
                const o = s.replace("fired", "");
                (i = (n = r._eventHandlers) == null ? void 0 : n[o]) == null || i.call(t, new Event(o.replace("on", "")))
            }
        }
    }
})
  , U5 = ["link", "style", "script", "noscript"]
  , z5 = {
    hooks: {
        "tag:normalise": ({tag: e}) => {
            e.key && U5.includes(e.tag) && (e.props["data-hid"] = e._h = wg(e.key))
        }
    }
}
  , $5 = {
    hooks: {
        "tags:resolve": e => {
            const t = r => {
                var n;
                return (n = e.tags.find(i => i._d === r)) == null ? void 0 : n._p
            }
            ;
            for (const {prefix: r, offset: n} of L5)
                for (const i of e.tags.filter(s => typeof s.tagPriority == "string" && s.tagPriority.startsWith(r))) {
                    const s = t(i.tagPriority.replace(r, ""));
                    typeof s < "u" && (i._p = s + n)
                }
            e.tags.sort( (r, n) => r._p - n._p).sort( (r, n) => Kl(r) - Kl(n))
        }
    }
}
  , F5 = {
    meta: "content",
    link: "href",
    htmlAttrs: "lang"
}
  , H5 = e => ({
    hooks: {
        "tags:resolve": t => {
            var a;
            const {tags: r} = t
              , n = (a = r.find(u => u.tag === "title")) == null ? void 0 : a.textContent
              , i = r.findIndex(u => u.tag === "templateParams")
              , s = i !== -1 ? r[i].props : {}
              , o = s.separator || "|";
            delete s.separator,
            s.pageTitle = cl(s.pageTitle || n || "", s, o);
            for (const u of r.filter(c => c.processTemplateParams !== !1)) {
                const c = F5[u.tag];
                c && typeof u.props[c] == "string" ? u.props[c] = cl(u.props[c], s, o) : (u.processTemplateParams === !0 || ["titleTemplate", "title"].includes(u.tag)) && ["innerHTML", "textContent"].forEach(l => {
                    typeof u[l] == "string" && (u[l] = cl(u[l], s, o))
                }
                )
            }
            e._templateParams = s,
            e._separator = o,
            t.tags = r.filter(u => u.tag !== "templateParams")
        }
    }
})
  , q5 = {
    hooks: {
        "tags:resolve": e => {
            const {tags: t} = e;
            let r = t.findIndex(i => i.tag === "titleTemplate");
            const n = t.findIndex(i => i.tag === "title");
            if (n !== -1 && r !== -1) {
                const i = G1(t[r].textContent, t[n].textContent);
                i !== null ? t[n].textContent = i || t[n].textContent : delete t[n]
            } else if (r !== -1) {
                const i = G1(t[r].textContent);
                i !== null && (t[r].textContent = i,
                t[r].tag = "title",
                r = -1)
            }
            r !== -1 && delete t[r],
            e.tags = t.filter(Boolean)
        }
    }
}
  , W5 = {
    hooks: {
        "tags:afterResolve": function(e) {
            for (const t of e.tags)
                typeof t.innerHTML == "string" && (t.innerHTML && ["application/ld+json", "application/json"].includes(t.props.type) ? t.innerHTML = t.innerHTML.replace(/</g, "\\u003C") : t.innerHTML = t.innerHTML.replace(new RegExp(`</${t.tag}`,"g"), `<\\/${t.tag}`))
        }
    }
};
let _2;
function V5(e={}) {
    const t = K5(e);
    return t.use(N5()),
    _2 = t
}
function X1(e, t) {
    return !e || e === "server" && t || e === "client" && !t
}
function K5(e={}) {
    const t = n2();
    t.addHooks(e.hooks || {}),
    e.document = e.document || (_5 ? document : void 0);
    const r = !e.document
      , n = () => {
        a.dirty = !0,
        t.callHook("entries:updated", a)
    }
    ;
    let i = 0
      , s = [];
    const o = []
      , a = {
        plugins: o,
        dirty: !1,
        resolvedOptions: e,
        hooks: t,
        headEntries() {
            return s
        },
        use(u) {
            const c = typeof u == "function" ? u(a) : u;
            (!c.key || !o.some(l => l.key === c.key)) && (o.push(c),
            X1(c.mode, r) && t.addHooks(c.hooks || {}))
        },
        push(u, c) {
            c == null || delete c.head;
            const l = {
                _i: i++,
                input: u,
                ...c
            };
            return X1(l.mode, r) && (s.push(l),
            n()),
            {
                dispose() {
                    s = s.filter(p => p._i !== l._i),
                    t.callHook("entries:updated", a),
                    n()
                },
                patch(p) {
                    s = s.map(h => (h._i === l._i && (h.input = l.input = p),
                    h)),
                    n()
                }
            }
        },
        async resolveTags() {
            const u = {
                tags: [],
                entries: [...s]
            };
            await t.callHook("entries:resolve", u);
            for (const c of u.entries) {
                const l = c.resolvedInput || c.input;
                if (c.resolvedInput = await (c.transform ? c.transform(l) : l),
                c.resolvedInput)
                    for (const p of await k5(c)) {
                        const h = {
                            tag: p,
                            entry: c,
                            resolvedOptions: a.resolvedOptions
                        };
                        await t.callHook("tag:normalise", h),
                        u.tags.push(h.tag)
                    }
            }
            return await t.callHook("tags:beforeResolve", u),
            await t.callHook("tags:resolve", u),
            await t.callHook("tags:afterResolve", u),
            u.tags
        },
        ssr: r
    };
    return [B5, P5, D5, z5, $5, H5, q5, W5, ...(e == null ? void 0 : e.plugins) || []].forEach(u => a.use(u)),
    a.hooks.callHook("init", a),
    a
}
function G5() {
    return _2
}
const Q5 = Hv.startsWith("3");
function Y5(e) {
    return typeof e == "function" ? e() : ct(e)
}
function Gl(e, t="") {
    if (e instanceof Promise)
        return e;
    const r = Y5(e);
    return !e || !r ? r : Array.isArray(r) ? r.map(n => Gl(n, t)) : typeof r == "object" ? Object.fromEntries(Object.entries(r).map( ([n,i]) => n === "titleTemplate" || n.startsWith("on") ? [n, ct(i)] : [n, Gl(i, n)])) : r
}
const Z5 = {
    hooks: {
        "entries:resolve": function(e) {
            for (const t of e.entries)
                t.resolvedInput = Gl(t.input)
        }
    }
}
  , A2 = "usehead";
function J5(e) {
    return {
        install(r) {
            Q5 && (r.config.globalProperties.$unhead = e,
            r.config.globalProperties.$head = e,
            r.provide(A2, e))
        }
    }.install
}
function X5(e={}) {
    e.domDelayFn = e.domDelayFn || (r => Kn( () => setTimeout( () => r(), 0)));
    const t = V5(e);
    return t.use(Z5),
    t.install = J5(t),
    t
}
const _h = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , Ah = "__unhead_injection_handler__";
function eA(e) {
    _h[Ah] = e
}
function tA() {
    if (Ah in _h)
        return _h[Ah]();
    const e = Kt(A2);
    return e || G5()
}
function Hf(e, t={}) {
    const r = t.head || tA();
    if (r)
        return r.ssr ? r.push(e, t) : rA(r, e, t)
}
function rA(e, t, r={}) {
    const n = Ue(!1)
      , i = Ue({});
    Cn( () => {
        i.value = n.value ? {} : Gl(t)
    }
    );
    const s = e.push(i.value, r);
    return vt(i, a => {
        s.patch(a)
    }
    ),
    Gn() && (Ju( () => {
        s.dispose()
    }
    ),
    vv( () => {
        n.value = !0
    }
    ),
    wv( () => {
        n.value = !1
    }
    )),
    s
}
const Da = "https://mog.me"
  , nA = {
    metadata: {
        app_name: "MOG.ME",
        title: "MOG.ME | MOG ANY IMAGE",
        description: "Add Pit Viper sunglasses and other stickers to photos and NFT profile pictures, brought to you by $MOG.",
        image: `${Da}/opengraph.jpeg`,
        icon: `${Da}/favicon.ico`,
        modal_icon: `${Da}`,
        url: `${Da}`,
        auto_connect: !1
    },
    ui: {
        primary: "mog",
        gray: "neutral",
        textarea: {
            wrapper: "border-none cursor-pointer",
            form: "cursor-pointer focus:cursor-text",
            variant: {
                outline: "outline-none"
            }
        },
        skeleton: {
            background: "bg-gray-300 dark:bg-gray-600"
        },
        button: {
            default: {
                loadingIcon: "i-svg-spinners-ring-resize"
            },
            rounded: "rounded-full",
            variant: {
                solid: "bg-{color}-600 dark:bg-{color}-600 dark:text-text",
                outline: "ring-0.5 focus-visible:ring-0.5 ring-coal-100 dark:ring-coal-600 hover:bg-coal-100 dark:hover:bg-coal-600"
            }
        },
        notifications: {
            position: "bottom-0 top-auto"
        },
        notification: {
            background: "bg-white",
            description: "text-mog-700",
            title: "text-mog-700 font-semibold",
            icon: {
                base: "w-7 h-7",
                color: "text-mog-700"
            }
        }
    }
}
  , M2 = {
    ...nA
}
  , iA = {
    nuxt: {
        buildId: "d3a917c4-388b-4043-ac53-5c939f9d740d"
    },
    ui: {
        primary: "green",
        gray: "cool",
        colors: ["red", "orange", "amber", "yellow", "lime", "green", "emerald", "teal", "cyan", "sky", "blue", "indigo", "violet", "purple", "fuchsia", "pink", "rose", "primary", "mog", "gom"],
        strategy: "merge"
    }
}
  , pn = e5(M2, iA);
function fa() {
    const e = ut();
    return e._appConfig || (e._appConfig = Vn(pn)),
    e._appConfig
}
const sA = !1
  , Mh = !1
  , oA = !0
  , aA = !1
  , uA = {
    componentName: "NuxtLink"
}
  , iF = {
    deep: !0
}
  , cA = "#__nuxt";
let ll, I2;
function lA() {
    var t;
    const e = (t = fa().nuxt) == null ? void 0 : t.buildId;
    return ll = $fetch(gg(`builds/meta/${e}.json`)),
    ll.then(r => {
        I2 = X8(r.matcher)
    }
    ),
    ll
}
function qf() {
    return ll || lA()
}
async function xg(e) {
    return await qf(),
    yg({}, ...I2.matchAll(e).reverse())
}
function ey(e, t={}) {
    const r = dA(e, t)
      , n = ut()
      , i = n._payloadCache = n._payloadCache || {};
    return r in i || (i[r] = hA(e).then(s => s ? T2(r).then(o => o || (delete i[r],
    null)) : (i[r] = null,
    null))),
    i[r]
}
const fA = "_payload.json";
function dA(e, t={}) {
    var i;
    const r = new URL(e,"http://localhost");
    if (r.host !== "localhost" || xi(r.pathname, {
        acceptRelative: !0
    }))
        throw new Error("Payload URL must not include hostname: " + e);
    const n = t.hash || (t.fresh ? Date.now() : (i = fa().nuxt) == null ? void 0 : i.buildId);
    return zf(os().app.baseURL, r.pathname, fA + (n ? `?${n}` : ""))
}
async function T2(e) {
    const t = fetch(e).then(r => r.text().then(C2));
    try {
        return await t
    } catch (r) {
        console.warn("[nuxt] Cannot load payload ", e, r)
    }
    return null
}
async function hA(e=bg().path) {
    if (e = Df(e),
    (await qf()).prerendered.includes(e))
        return !0;
    const r = await xg(e);
    return !!r.prerender && !r.redirect
}
let kc = null;
async function pA() {
    if (kc)
        return kc;
    const e = document.getElementById("__NUXT_DATA__");
    if (!e)
        return {};
    const t = await C2(e.textContent || "")
      , r = e.dataset.src ? await T2(e.dataset.src) : void 0;
    return kc = {
        ...t,
        ...r,
        ...window.__NUXT__
    },
    kc
}
async function C2(e) {
    return await b5(e, ut()._payloadRevivers)
}
function gA(e, t) {
    ut()._payloadRevivers[e] = t
}
const ty = {
    NuxtError: e => Ff(e),
    EmptyShallowRef: e => Pr(e === "_" ? void 0 : e === "0n" ? BigInt(0) : Fl(e)),
    EmptyRef: e => Ue(e === "_" ? void 0 : e === "0n" ? BigInt(0) : Fl(e)),
    ShallowRef: e => Pr(e),
    ShallowReactive: e => Qu(e),
    Ref: e => Ue(e),
    Reactive: e => Vn(e)
}
  , mA = _t({
    name: "nuxt:revive-payload:client",
    order: -30,
    async setup(e) {
        let t, r;
        for (const n in ty)
            gA(n, ty[n]);
        Object.assign(e.payload, ([t,r] = lu( () => e.runWithContext(pA)),
        t = await t,
        r(),
        t)),
        window.__NUXT__ = e.payload
    }
})
  , yA = []
  , bA = _t({
    name: "nuxt:head",
    enforce: "pre",
    setup(e) {
        const t = X5({
            plugins: yA
        });
        eA( () => ut().vueApp._context.provides.usehead),
        e.vueApp.use(t);
        {
            let r = !0;
            const n = async () => {
                r = !1,
                await S2(t)
            }
            ;
            t.hooks.hook("dom:beforeRender", i => {
                i.shouldRender = !r
            }
            ),
            e.hooks.hook("page:start", () => {
                r = !0
            }
            ),
            e.hooks.hook("page:finish", () => {
                e.isHydrating || n()
            }
            ),
            e.hooks.hook("app:error", n),
            e.hooks.hook("app:suspense:resolve", n)
        }
    }
});
/*!
  * vue-router v4.3.0
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const co = typeof document < "u";
function wA(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module"
}
const rt = Object.assign;
function u0(e, t) {
    const r = {};
    for (const n in t) {
        const i = t[n];
        r[n] = Mn(i) ? i.map(e) : e(i)
    }
    return r
}
const Ga = () => {}
  , Mn = Array.isArray
  , k2 = /#/g
  , vA = /&/g
  , xA = /\//g
  , EA = /=/g
  , SA = /\?/g
  , L2 = /\+/g
  , _A = /%5B/g
  , AA = /%5D/g
  , O2 = /%5E/g
  , MA = /%60/g
  , N2 = /%7B/g
  , IA = /%7C/g
  , R2 = /%7D/g
  , TA = /%20/g;
function Eg(e) {
    return encodeURI("" + e).replace(IA, "|").replace(_A, "[").replace(AA, "]")
}
function CA(e) {
    return Eg(e).replace(N2, "{").replace(R2, "}").replace(O2, "^")
}
function Ih(e) {
    return Eg(e).replace(L2, "%2B").replace(TA, "+").replace(k2, "%23").replace(vA, "%26").replace(MA, "`").replace(N2, "{").replace(R2, "}").replace(O2, "^")
}
function kA(e) {
    return Ih(e).replace(EA, "%3D")
}
function LA(e) {
    return Eg(e).replace(k2, "%23").replace(SA, "%3F")
}
function OA(e) {
    return e == null ? "" : LA(e).replace(xA, "%2F")
}
function fu(e) {
    try {
        return decodeURIComponent("" + e)
    } catch {}
    return "" + e
}
const NA = /\/$/
  , RA = e => e.replace(NA, "");
function c0(e, t, r="/") {
    let n, i = {}, s = "", o = "";
    const a = t.indexOf("#");
    let u = t.indexOf("?");
    return a < u && a >= 0 && (u = -1),
    u > -1 && (n = t.slice(0, u),
    s = t.slice(u + 1, a > -1 ? a : t.length),
    i = e(s)),
    a > -1 && (n = n || t.slice(0, a),
    o = t.slice(a, t.length)),
    n = DA(n ?? t, r),
    {
        fullPath: n + (s && "?") + s + o,
        path: n,
        query: i,
        hash: fu(o)
    }
}
function BA(e, t) {
    const r = t.query ? e(t.query) : "";
    return t.path + (r && "?") + r + (t.hash || "")
}
function ry(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}
function PA(e, t, r) {
    const n = t.matched.length - 1
      , i = r.matched.length - 1;
    return n > -1 && n === i && $o(t.matched[n], r.matched[i]) && B2(t.params, r.params) && e(t.query) === e(r.query) && t.hash === r.hash
}
function $o(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}
function B2(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const r in e)
        if (!jA(e[r], t[r]))
            return !1;
    return !0
}
function jA(e, t) {
    return Mn(e) ? ny(e, t) : Mn(t) ? ny(t, e) : e === t
}
function ny(e, t) {
    return Mn(t) ? e.length === t.length && e.every( (r, n) => r === t[n]) : e.length === 1 && e[0] === t
}
function DA(e, t) {
    if (e.startsWith("/"))
        return e;
    if (!e)
        return t;
    const r = t.split("/")
      , n = e.split("/")
      , i = n[n.length - 1];
    (i === ".." || i === ".") && n.push("");
    let s = r.length - 1, o, a;
    for (o = 0; o < n.length; o++)
        if (a = n[o],
        a !== ".")
            if (a === "..")
                s > 1 && s--;
            else
                break;
    return r.slice(0, s).join("/") + "/" + n.slice(o).join("/")
}
var du;
(function(e) {
    e.pop = "pop",
    e.push = "push"
}
)(du || (du = {}));
var Qa;
(function(e) {
    e.back = "back",
    e.forward = "forward",
    e.unknown = ""
}
)(Qa || (Qa = {}));
function UA(e) {
    if (!e)
        if (co) {
            const t = document.querySelector("base");
            e = t && t.getAttribute("href") || "/",
            e = e.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            e = "/";
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e),
    RA(e)
}
const zA = /^[^#]+#/;
function $A(e, t) {
    return e.replace(zA, "#") + t
}
function FA(e, t) {
    const r = document.documentElement.getBoundingClientRect()
      , n = e.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: n.left - r.left - (t.left || 0),
        top: n.top - r.top - (t.top || 0)
    }
}
const Wf = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function HA(e) {
    let t;
    if ("el"in e) {
        const r = e.el
          , n = typeof r == "string" && r.startsWith("#")
          , i = typeof r == "string" ? n ? document.getElementById(r.slice(1)) : document.querySelector(r) : r;
        if (!i)
            return;
        t = FA(i, e)
    } else
        t = e;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}
function iy(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const Th = new Map;
function qA(e, t) {
    Th.set(e, t)
}
function WA(e) {
    const t = Th.get(e);
    return Th.delete(e),
    t
}
let VA = () => location.protocol + "//" + location.host;
function P2(e, t) {
    const {pathname: r, search: n, hash: i} = t
      , s = e.indexOf("#");
    if (s > -1) {
        let a = i.includes(e.slice(s)) ? e.slice(s).length : 1
          , u = i.slice(a);
        return u[0] !== "/" && (u = "/" + u),
        ry(u, "")
    }
    return ry(r, e) + n + i
}
function KA(e, t, r, n) {
    let i = []
      , s = []
      , o = null;
    const a = ({state: h}) => {
        const g = P2(e, location)
          , S = r.value
          , x = t.value;
        let v = 0;
        if (h) {
            if (r.value = g,
            t.value = h,
            o && o === S) {
                o = null;
                return
            }
            v = x ? h.position - x.position : 0
        } else
            n(g);
        i.forEach(I => {
            I(r.value, S, {
                delta: v,
                type: du.pop,
                direction: v ? v > 0 ? Qa.forward : Qa.back : Qa.unknown
            })
        }
        )
    }
    ;
    function u() {
        o = r.value
    }
    function c(h) {
        i.push(h);
        const g = () => {
            const S = i.indexOf(h);
            S > -1 && i.splice(S, 1)
        }
        ;
        return s.push(g),
        g
    }
    function l() {
        const {history: h} = window;
        h.state && h.replaceState(rt({}, h.state, {
            scroll: Wf()
        }), "")
    }
    function p() {
        for (const h of s)
            h();
        s = [],
        window.removeEventListener("popstate", a),
        window.removeEventListener("beforeunload", l)
    }
    return window.addEventListener("popstate", a),
    window.addEventListener("beforeunload", l, {
        passive: !0
    }),
    {
        pauseListeners: u,
        listen: c,
        destroy: p
    }
}
function sy(e, t, r, n=!1, i=!1) {
    return {
        back: e,
        current: t,
        forward: r,
        replaced: n,
        position: window.history.length,
        scroll: i ? Wf() : null
    }
}
function GA(e) {
    const {history: t, location: r} = window
      , n = {
        value: P2(e, r)
    }
      , i = {
        value: t.state
    };
    i.value || s(n.value, {
        back: null,
        current: n.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function s(u, c, l) {
        const p = e.indexOf("#")
          , h = p > -1 ? (r.host && document.querySelector("base") ? e : e.slice(p)) + u : VA() + e + u;
        try {
            t[l ? "replaceState" : "pushState"](c, "", h),
            i.value = c
        } catch (g) {
            console.error(g),
            r[l ? "replace" : "assign"](h)
        }
    }
    function o(u, c) {
        const l = rt({}, t.state, sy(i.value.back, u, i.value.forward, !0), c, {
            position: i.value.position
        });
        s(u, l, !0),
        n.value = u
    }
    function a(u, c) {
        const l = rt({}, i.value, t.state, {
            forward: u,
            scroll: Wf()
        });
        s(l.current, l, !0);
        const p = rt({}, sy(n.value, u, null), {
            position: l.position + 1
        }, c);
        s(u, p, !1),
        n.value = u
    }
    return {
        location: n,
        state: i,
        push: a,
        replace: o
    }
}
function j2(e) {
    e = UA(e);
    const t = GA(e)
      , r = KA(e, t.state, t.location, t.replace);
    function n(s, o=!0) {
        o || r.pauseListeners(),
        history.go(s)
    }
    const i = rt({
        location: "",
        base: e,
        go: n,
        createHref: $A.bind(null, e)
    }, t, r);
    return Object.defineProperty(i, "location", {
        enumerable: !0,
        get: () => t.location.value
    }),
    Object.defineProperty(i, "state", {
        enumerable: !0,
        get: () => t.state.value
    }),
    i
}
function QA(e) {
    return e = location.host ? e || location.pathname + location.search : "",
    e.includes("#") || (e += "#"),
    j2(e)
}
function YA(e) {
    return typeof e == "string" || e && typeof e == "object"
}
function D2(e) {
    return typeof e == "string" || typeof e == "symbol"
}
const wn = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
}
  , U2 = Symbol("");
var oy;
(function(e) {
    e[e.aborted = 4] = "aborted",
    e[e.cancelled = 8] = "cancelled",
    e[e.duplicated = 16] = "duplicated"
}
)(oy || (oy = {}));
function Fo(e, t) {
    return rt(new Error, {
        type: e,
        [U2]: !0
    }, t)
}
function Jn(e, t) {
    return e instanceof Error && U2 in e && (t == null || !!(e.type & t))
}
const ay = "[^/]+?"
  , ZA = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , JA = /[.+*?^${}()[\]/\\]/g;
function XA(e, t) {
    const r = rt({}, ZA, t)
      , n = [];
    let i = r.start ? "^" : "";
    const s = [];
    for (const c of e) {
        const l = c.length ? [] : [90];
        r.strict && !c.length && (i += "/");
        for (let p = 0; p < c.length; p++) {
            const h = c[p];
            let g = 40 + (r.sensitive ? .25 : 0);
            if (h.type === 0)
                p || (i += "/"),
                i += h.value.replace(JA, "\\$&"),
                g += 40;
            else if (h.type === 1) {
                const {value: S, repeatable: x, optional: v, regexp: I} = h;
                s.push({
                    name: S,
                    repeatable: x,
                    optional: v
                });
                const M = I || ay;
                if (M !== ay) {
                    g += 10;
                    try {
                        new RegExp(`(${M})`)
                    } catch (k) {
                        throw new Error(`Invalid custom RegExp for param "${S}" (${M}): ` + k.message)
                    }
                }
                let A = x ? `((?:${M})(?:/(?:${M}))*)` : `(${M})`;
                p || (A = v && c.length < 2 ? `(?:/${A})` : "/" + A),
                v && (A += "?"),
                i += A,
                g += 20,
                v && (g += -8),
                x && (g += -20),
                M === ".*" && (g += -50)
            }
            l.push(g)
        }
        n.push(l)
    }
    if (r.strict && r.end) {
        const c = n.length - 1;
        n[c][n[c].length - 1] += .7000000000000001
    }
    r.strict || (i += "/?"),
    r.end ? i += "$" : r.strict && (i += "(?:/|$)");
    const o = new RegExp(i,r.sensitive ? "" : "i");
    function a(c) {
        const l = c.match(o)
          , p = {};
        if (!l)
            return null;
        for (let h = 1; h < l.length; h++) {
            const g = l[h] || ""
              , S = s[h - 1];
            p[S.name] = g && S.repeatable ? g.split("/") : g
        }
        return p
    }
    function u(c) {
        let l = ""
          , p = !1;
        for (const h of e) {
            (!p || !l.endsWith("/")) && (l += "/"),
            p = !1;
            for (const g of h)
                if (g.type === 0)
                    l += g.value;
                else if (g.type === 1) {
                    const {value: S, repeatable: x, optional: v} = g
                      , I = S in c ? c[S] : "";
                    if (Mn(I) && !x)
                        throw new Error(`Provided param "${S}" is an array but it is not repeatable (* or + modifiers)`);
                    const M = Mn(I) ? I.join("/") : I;
                    if (!M)
                        if (v)
                            h.length < 2 && (l.endsWith("/") ? l = l.slice(0, -1) : p = !0);
                        else
                            throw new Error(`Missing required param "${S}"`);
                    l += M
                }
        }
        return l || "/"
    }
    return {
        re: o,
        score: n,
        keys: s,
        parse: a,
        stringify: u
    }
}
function eM(e, t) {
    let r = 0;
    for (; r < e.length && r < t.length; ) {
        const n = t[r] - e[r];
        if (n)
            return n;
        r++
    }
    return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0
}
function tM(e, t) {
    let r = 0;
    const n = e.score
      , i = t.score;
    for (; r < n.length && r < i.length; ) {
        const s = eM(n[r], i[r]);
        if (s)
            return s;
        r++
    }
    if (Math.abs(i.length - n.length) === 1) {
        if (uy(n))
            return 1;
        if (uy(i))
            return -1
    }
    return i.length - n.length
}
function uy(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const rM = {
    type: 0,
    value: ""
}
  , nM = /[a-zA-Z0-9_]/;
function iM(e) {
    if (!e)
        return [[]];
    if (e === "/")
        return [[rM]];
    if (!e.startsWith("/"))
        throw new Error(`Invalid path "${e}"`);
    function t(g) {
        throw new Error(`ERR (${r})/"${c}": ${g}`)
    }
    let r = 0
      , n = r;
    const i = [];
    let s;
    function o() {
        s && i.push(s),
        s = []
    }
    let a = 0, u, c = "", l = "";
    function p() {
        c && (r === 0 ? s.push({
            type: 0,
            value: c
        }) : r === 1 || r === 2 || r === 3 ? (s.length > 1 && (u === "*" || u === "+") && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
        s.push({
            type: 1,
            value: c,
            regexp: l,
            repeatable: u === "*" || u === "+",
            optional: u === "*" || u === "?"
        })) : t("Invalid state to consume buffer"),
        c = "")
    }
    function h() {
        c += u
    }
    for (; a < e.length; ) {
        if (u = e[a++],
        u === "\\" && r !== 2) {
            n = r,
            r = 4;
            continue
        }
        switch (r) {
        case 0:
            u === "/" ? (c && p(),
            o()) : u === ":" ? (p(),
            r = 1) : h();
            break;
        case 4:
            h(),
            r = n;
            break;
        case 1:
            u === "(" ? r = 2 : nM.test(u) ? h() : (p(),
            r = 0,
            u !== "*" && u !== "?" && u !== "+" && a--);
            break;
        case 2:
            u === ")" ? l[l.length - 1] == "\\" ? l = l.slice(0, -1) + u : r = 3 : l += u;
            break;
        case 3:
            p(),
            r = 0,
            u !== "*" && u !== "?" && u !== "+" && a--,
            l = "";
            break;
        default:
            t("Unknown state");
            break
        }
    }
    return r === 2 && t(`Unfinished custom RegExp for param "${c}"`),
    p(),
    o(),
    i
}
function sM(e, t, r) {
    const n = XA(iM(e.path), r)
      , i = rt(n, {
        record: e,
        parent: t,
        children: [],
        alias: []
    });
    return t && !i.record.aliasOf == !t.record.aliasOf && t.children.push(i),
    i
}
function oM(e, t) {
    const r = []
      , n = new Map;
    t = fy({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t);
    function i(l) {
        return n.get(l)
    }
    function s(l, p, h) {
        const g = !h
          , S = aM(l);
        S.aliasOf = h && h.record;
        const x = fy(t, l)
          , v = [S];
        if ("alias"in l) {
            const A = typeof l.alias == "string" ? [l.alias] : l.alias;
            for (const k of A)
                v.push(rt({}, S, {
                    components: h ? h.record.components : S.components,
                    path: k,
                    aliasOf: h ? h.record : S
                }))
        }
        let I, M;
        for (const A of v) {
            const {path: k} = A;
            if (p && k[0] !== "/") {
                const L = p.record.path
                  , O = L[L.length - 1] === "/" ? "" : "/";
                A.path = p.record.path + (k && O + k)
            }
            if (I = sM(A, p, x),
            h ? h.alias.push(I) : (M = M || I,
            M !== I && M.alias.push(I),
            g && l.name && !ly(I) && o(l.name)),
            S.children) {
                const L = S.children;
                for (let O = 0; O < L.length; O++)
                    s(L[O], I, h && h.children[O])
            }
            h = h || I,
            (I.record.components && Object.keys(I.record.components).length || I.record.name || I.record.redirect) && u(I)
        }
        return M ? () => {
            o(M)
        }
        : Ga
    }
    function o(l) {
        if (D2(l)) {
            const p = n.get(l);
            p && (n.delete(l),
            r.splice(r.indexOf(p), 1),
            p.children.forEach(o),
            p.alias.forEach(o))
        } else {
            const p = r.indexOf(l);
            p > -1 && (r.splice(p, 1),
            l.record.name && n.delete(l.record.name),
            l.children.forEach(o),
            l.alias.forEach(o))
        }
    }
    function a() {
        return r
    }
    function u(l) {
        let p = 0;
        for (; p < r.length && tM(l, r[p]) >= 0 && (l.record.path !== r[p].record.path || !z2(l, r[p])); )
            p++;
        r.splice(p, 0, l),
        l.record.name && !ly(l) && n.set(l.record.name, l)
    }
    function c(l, p) {
        let h, g = {}, S, x;
        if ("name"in l && l.name) {
            if (h = n.get(l.name),
            !h)
                throw Fo(1, {
                    location: l
                });
            x = h.record.name,
            g = rt(cy(p.params, h.keys.filter(M => !M.optional).concat(h.parent ? h.parent.keys.filter(M => M.optional) : []).map(M => M.name)), l.params && cy(l.params, h.keys.map(M => M.name))),
            S = h.stringify(g)
        } else if (l.path != null)
            S = l.path,
            h = r.find(M => M.re.test(S)),
            h && (g = h.parse(S),
            x = h.record.name);
        else {
            if (h = p.name ? n.get(p.name) : r.find(M => M.re.test(p.path)),
            !h)
                throw Fo(1, {
                    location: l,
                    currentLocation: p
                });
            x = h.record.name,
            g = rt({}, p.params, l.params),
            S = h.stringify(g)
        }
        const v = [];
        let I = h;
        for (; I; )
            v.unshift(I.record),
            I = I.parent;
        return {
            name: x,
            path: S,
            params: g,
            matched: v,
            meta: cM(v)
        }
    }
    return e.forEach(l => s(l)),
    {
        addRoute: s,
        resolve: c,
        removeRoute: o,
        getRoutes: a,
        getRecordMatcher: i
    }
}
function cy(e, t) {
    const r = {};
    for (const n of t)
        n in e && (r[n] = e[n]);
    return r
}
function aM(e) {
    return {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: void 0,
        beforeEnter: e.beforeEnter,
        props: uM(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in e ? e.components || null : e.component && {
            default: e.component
        }
    }
}
function uM(e) {
    const t = {}
      , r = e.props || !1;
    if ("component"in e)
        t.default = r;
    else
        for (const n in e.components)
            t[n] = typeof r == "object" ? r[n] : r;
    return t
}
function ly(e) {
    for (; e; ) {
        if (e.record.aliasOf)
            return !0;
        e = e.parent
    }
    return !1
}
function cM(e) {
    return e.reduce( (t, r) => rt(t, r.meta), {})
}
function fy(e, t) {
    const r = {};
    for (const n in e)
        r[n] = n in t ? t[n] : e[n];
    return r
}
function z2(e, t) {
    return t.children.some(r => r === e || z2(e, r))
}
function lM(e) {
    const t = {};
    if (e === "" || e === "?")
        return t;
    const n = (e[0] === "?" ? e.slice(1) : e).split("&");
    for (let i = 0; i < n.length; ++i) {
        const s = n[i].replace(L2, " ")
          , o = s.indexOf("=")
          , a = fu(o < 0 ? s : s.slice(0, o))
          , u = o < 0 ? null : fu(s.slice(o + 1));
        if (a in t) {
            let c = t[a];
            Mn(c) || (c = t[a] = [c]),
            c.push(u)
        } else
            t[a] = u
    }
    return t
}
function dy(e) {
    let t = "";
    for (let r in e) {
        const n = e[r];
        if (r = kA(r),
        n == null) {
            n !== void 0 && (t += (t.length ? "&" : "") + r);
            continue
        }
        (Mn(n) ? n.map(s => s && Ih(s)) : [n && Ih(n)]).forEach(s => {
            s !== void 0 && (t += (t.length ? "&" : "") + r,
            s != null && (t += "=" + s))
        }
        )
    }
    return t
}
function fM(e) {
    const t = {};
    for (const r in e) {
        const n = e[r];
        n !== void 0 && (t[r] = Mn(n) ? n.map(i => i == null ? null : "" + i) : n == null ? n : "" + n)
    }
    return t
}
const dM = Symbol("")
  , hy = Symbol("")
  , Vf = Symbol("")
  , Sg = Symbol("")
  , Ch = Symbol("");
function _a() {
    let e = [];
    function t(n) {
        return e.push(n),
        () => {
            const i = e.indexOf(n);
            i > -1 && e.splice(i, 1)
        }
    }
    function r() {
        e = []
    }
    return {
        add: t,
        list: () => e.slice(),
        reset: r
    }
}
function Ui(e, t, r, n, i, s=o => o()) {
    const o = n && (n.enterCallbacks[i] = n.enterCallbacks[i] || []);
    return () => new Promise( (a, u) => {
        const c = h => {
            h === !1 ? u(Fo(4, {
                from: r,
                to: t
            })) : h instanceof Error ? u(h) : YA(h) ? u(Fo(2, {
                from: t,
                to: h
            })) : (o && n.enterCallbacks[i] === o && typeof h == "function" && o.push(h),
            a())
        }
          , l = s( () => e.call(n && n.instances[i], t, r, c));
        let p = Promise.resolve(l);
        e.length < 3 && (p = p.then(c)),
        p.catch(h => u(h))
    }
    )
}
function l0(e, t, r, n, i=s => s()) {
    const s = [];
    for (const o of e)
        for (const a in o.components) {
            let u = o.components[a];
            if (!(t !== "beforeRouteEnter" && !o.instances[a]))
                if (hM(u)) {
                    const l = (u.__vccOpts || u)[t];
                    l && s.push(Ui(l, r, n, o, a, i))
                } else {
                    let c = u();
                    s.push( () => c.then(l => {
                        if (!l)
                            return Promise.reject(new Error(`Couldn't resolve component "${a}" at "${o.path}"`));
                        const p = wA(l) ? l.default : l;
                        o.components[a] = p;
                        const g = (p.__vccOpts || p)[t];
                        return g && Ui(g, r, n, o, a, i)()
                    }
                    ))
                }
        }
    return s
}
function hM(e) {
    return typeof e == "object" || "displayName"in e || "props"in e || "__vccOpts"in e
}
function py(e) {
    const t = Kt(Vf)
      , r = Kt(Sg)
      , n = Se( () => t.resolve(ct(e.to)))
      , i = Se( () => {
        const {matched: u} = n.value
          , {length: c} = u
          , l = u[c - 1]
          , p = r.matched;
        if (!l || !p.length)
            return -1;
        const h = p.findIndex($o.bind(null, l));
        if (h > -1)
            return h;
        const g = gy(u[c - 2]);
        return c > 1 && gy(l) === g && p[p.length - 1].path !== g ? p.findIndex($o.bind(null, u[c - 2])) : h
    }
    )
      , s = Se( () => i.value > -1 && yM(r.params, n.value.params))
      , o = Se( () => i.value > -1 && i.value === r.matched.length - 1 && B2(r.params, n.value.params));
    function a(u={}) {
        return mM(u) ? t[ct(e.replace) ? "replace" : "push"](ct(e.to)).catch(Ga) : Promise.resolve()
    }
    return {
        route: n,
        href: Se( () => n.value.href),
        isActive: s,
        isExactActive: o,
        navigate: a
    }
}
const pM = lr({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: py,
    setup(e, {slots: t}) {
        const r = Vn(py(e))
          , {options: n} = Kt(Vf)
          , i = Se( () => ({
            [my(e.activeClass, n.linkActiveClass, "router-link-active")]: r.isActive,
            [my(e.exactActiveClass, n.linkExactActiveClass, "router-link-exact-active")]: r.isExactActive
        }));
        return () => {
            const s = t.default && t.default(r);
            return e.custom ? s : cr("a", {
                "aria-current": r.isExactActive ? e.ariaCurrentValue : null,
                href: r.href,
                onClick: r.navigate,
                class: i.value
            }, s)
        }
    }
})
  , gM = pM;
function mM(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t))
                return
        }
        return e.preventDefault && e.preventDefault(),
        !0
    }
}
function yM(e, t) {
    for (const r in t) {
        const n = t[r]
          , i = e[r];
        if (typeof n == "string") {
            if (n !== i)
                return !1
        } else if (!Mn(i) || i.length !== n.length || n.some( (s, o) => s !== i[o]))
            return !1
    }
    return !0
}
function gy(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const my = (e, t, r) => e ?? t ?? r
  , bM = lr({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(e, {attrs: t, slots: r}) {
        const n = Kt(Ch)
          , i = Se( () => e.route || n.value)
          , s = Kt(hy, 0)
          , o = Se( () => {
            let c = ct(s);
            const {matched: l} = i.value;
            let p;
            for (; (p = l[c]) && !p.components; )
                c++;
            return c
        }
        )
          , a = Se( () => i.value.matched[o.value]);
        Zi(hy, Se( () => o.value + 1)),
        Zi(dM, a),
        Zi(Ch, i);
        const u = Ue();
        return vt( () => [u.value, a.value, e.name], ([c,l,p], [h,g,S]) => {
            l && (l.instances[p] = c,
            g && g !== l && c && c === h && (l.leaveGuards.size || (l.leaveGuards = g.leaveGuards),
            l.updateGuards.size || (l.updateGuards = g.updateGuards))),
            c && l && (!g || !$o(l, g) || !h) && (l.enterCallbacks[p] || []).forEach(x => x(c))
        }
        , {
            flush: "post"
        }),
        () => {
            const c = i.value
              , l = e.name
              , p = a.value
              , h = p && p.components[l];
            if (!h)
                return yy(r.default, {
                    Component: h,
                    route: c
                });
            const g = p.props[l]
              , S = g ? g === !0 ? c.params : typeof g == "function" ? g(c) : g : null
              , v = cr(h, rt({}, S, t, {
                onVnodeUnmounted: I => {
                    I.component.isUnmounted && (p.instances[l] = null)
                }
                ,
                ref: u
            }));
            return yy(r.default, {
                Component: v,
                route: c
            }) || v
        }
    }
});
function yy(e, t) {
    if (!e)
        return null;
    const r = e(t);
    return r.length === 1 ? r[0] : r
}
const $2 = bM;
function wM(e) {
    const t = oM(e.routes, e)
      , r = e.parseQuery || lM
      , n = e.stringifyQuery || dy
      , i = e.history
      , s = _a()
      , o = _a()
      , a = _a()
      , u = Pr(wn);
    let c = wn;
    co && e.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const l = u0.bind(null, Q => "" + Q)
      , p = u0.bind(null, OA)
      , h = u0.bind(null, fu);
    function g(Q, ee) {
        let te, he;
        return D2(Q) ? (te = t.getRecordMatcher(Q),
        he = ee) : he = Q,
        t.addRoute(he, te)
    }
    function S(Q) {
        const ee = t.getRecordMatcher(Q);
        ee && t.removeRoute(ee)
    }
    function x() {
        return t.getRoutes().map(Q => Q.record)
    }
    function v(Q) {
        return !!t.getRecordMatcher(Q)
    }
    function I(Q, ee) {
        if (ee = rt({}, ee || u.value),
        typeof Q == "string") {
            const H = c0(r, Q, ee.path)
              , Y = t.resolve({
                path: H.path
            }, ee)
              , se = i.createHref(H.fullPath);
            return rt(H, Y, {
                params: h(Y.params),
                hash: fu(H.hash),
                redirectedFrom: void 0,
                href: se
            })
        }
        let te;
        if (Q.path != null)
            te = rt({}, Q, {
                path: c0(r, Q.path, ee.path).path
            });
        else {
            const H = rt({}, Q.params);
            for (const Y in H)
                H[Y] == null && delete H[Y];
            te = rt({}, Q, {
                params: p(H)
            }),
            ee.params = p(ee.params)
        }
        const he = t.resolve(te, ee)
          , xe = Q.hash || "";
        he.params = l(h(he.params));
        const Ae = BA(n, rt({}, Q, {
            hash: CA(xe),
            path: he.path
        }))
          , z = i.createHref(Ae);
        return rt({
            fullPath: Ae,
            hash: xe,
            query: n === dy ? fM(Q.query) : Q.query || {}
        }, he, {
            redirectedFrom: void 0,
            href: z
        })
    }
    function M(Q) {
        return typeof Q == "string" ? c0(r, Q, u.value.path) : rt({}, Q)
    }
    function A(Q, ee) {
        if (c !== Q)
            return Fo(8, {
                from: ee,
                to: Q
            })
    }
    function k(Q) {
        return $(Q)
    }
    function L(Q) {
        return k(rt(M(Q), {
            replace: !0
        }))
    }
    function O(Q) {
        const ee = Q.matched[Q.matched.length - 1];
        if (ee && ee.redirect) {
            const {redirect: te} = ee;
            let he = typeof te == "function" ? te(Q) : te;
            return typeof he == "string" && (he = he.includes("?") || he.includes("#") ? he = M(he) : {
                path: he
            },
            he.params = {}),
            rt({
                query: Q.query,
                hash: Q.hash,
                params: he.path != null ? {} : Q.params
            }, he)
        }
    }
    function $(Q, ee) {
        const te = c = I(Q)
          , he = u.value
          , xe = Q.state
          , Ae = Q.force
          , z = Q.replace === !0
          , H = O(te);
        if (H)
            return $(rt(M(H), {
                state: typeof H == "object" ? rt({}, xe, H.state) : xe,
                force: Ae,
                replace: z
            }), ee || te);
        const Y = te;
        Y.redirectedFrom = ee;
        let se;
        return !Ae && PA(n, he, te) && (se = Fo(16, {
            to: Y,
            from: he
        }),
        N(he, he, !0, !1)),
        (se ? Promise.resolve(se) : G(Y, he)).catch(X => Jn(X) ? Jn(X, 2) ? X : W(X) : C(X, Y, he)).then(X => {
            if (X) {
                if (Jn(X, 2))
                    return $(rt({
                        replace: z
                    }, M(X.to), {
                        state: typeof X.to == "object" ? rt({}, xe, X.to.state) : xe,
                        force: Ae
                    }), ee || Y)
            } else
                X = q(Y, he, !0, z, xe);
            return F(Y, he, X),
            X
        }
        )
    }
    function D(Q, ee) {
        const te = A(Q, ee);
        return te ? Promise.reject(te) : Promise.resolve()
    }
    function K(Q) {
        const ee = re.values().next().value;
        return ee && typeof ee.runWithContext == "function" ? ee.runWithContext(Q) : Q()
    }
    function G(Q, ee) {
        let te;
        const [he,xe,Ae] = vM(Q, ee);
        te = l0(he.reverse(), "beforeRouteLeave", Q, ee);
        for (const H of he)
            H.leaveGuards.forEach(Y => {
                te.push(Ui(Y, Q, ee))
            }
            );
        const z = D.bind(null, Q, ee);
        return te.push(z),
        ue(te).then( () => {
            te = [];
            for (const H of s.list())
                te.push(Ui(H, Q, ee));
            return te.push(z),
            ue(te)
        }
        ).then( () => {
            te = l0(xe, "beforeRouteUpdate", Q, ee);
            for (const H of xe)
                H.updateGuards.forEach(Y => {
                    te.push(Ui(Y, Q, ee))
                }
                );
            return te.push(z),
            ue(te)
        }
        ).then( () => {
            te = [];
            for (const H of Ae)
                if (H.beforeEnter)
                    if (Mn(H.beforeEnter))
                        for (const Y of H.beforeEnter)
                            te.push(Ui(Y, Q, ee));
                    else
                        te.push(Ui(H.beforeEnter, Q, ee));
            return te.push(z),
            ue(te)
        }
        ).then( () => (Q.matched.forEach(H => H.enterCallbacks = {}),
        te = l0(Ae, "beforeRouteEnter", Q, ee, K),
        te.push(z),
        ue(te))).then( () => {
            te = [];
            for (const H of o.list())
                te.push(Ui(H, Q, ee));
            return te.push(z),
            ue(te)
        }
        ).catch(H => Jn(H, 8) ? H : Promise.reject(H))
    }
    function F(Q, ee, te) {
        a.list().forEach(he => K( () => he(Q, ee, te)))
    }
    function q(Q, ee, te, he, xe) {
        const Ae = A(Q, ee);
        if (Ae)
            return Ae;
        const z = ee === wn
          , H = co ? history.state : {};
        te && (he || z ? i.replace(Q.fullPath, rt({
            scroll: z && H && H.scroll
        }, xe)) : i.push(Q.fullPath, xe)),
        u.value = Q,
        N(Q, ee, te, z),
        W()
    }
    let B;
    function y() {
        B || (B = i.listen( (Q, ee, te) => {
            if (!ie.listening)
                return;
            const he = I(Q)
              , xe = O(he);
            if (xe) {
                $(rt(xe, {
                    replace: !0
                }), he).catch(Ga);
                return
            }
            c = he;
            const Ae = u.value;
            co && qA(iy(Ae.fullPath, te.delta), Wf()),
            G(he, Ae).catch(z => Jn(z, 12) ? z : Jn(z, 2) ? ($(z.to, he).then(H => {
                Jn(H, 20) && !te.delta && te.type === du.pop && i.go(-1, !1)
            }
            ).catch(Ga),
            Promise.reject()) : (te.delta && i.go(-te.delta, !1),
            C(z, he, Ae))).then(z => {
                z = z || q(he, Ae, !1),
                z && (te.delta && !Jn(z, 8) ? i.go(-te.delta, !1) : te.type === du.pop && Jn(z, 20) && i.go(-1, !1)),
                F(he, Ae, z)
            }
            ).catch(Ga)
        }
        ))
    }
    let b = _a(), _ = _a(), T;
    function C(Q, ee, te) {
        W(Q);
        const he = _.list();
        return he.length ? he.forEach(xe => xe(Q, ee, te)) : console.error(Q),
        Promise.reject(Q)
    }
    function P() {
        return T && u.value !== wn ? Promise.resolve() : new Promise( (Q, ee) => {
            b.add([Q, ee])
        }
        )
    }
    function W(Q) {
        return T || (T = !Q,
        y(),
        b.list().forEach( ([ee,te]) => Q ? te(Q) : ee()),
        b.reset()),
        Q
    }
    function N(Q, ee, te, he) {
        const {scrollBehavior: xe} = e;
        if (!co || !xe)
            return Promise.resolve();
        const Ae = !te && WA(iy(Q.fullPath, 0)) || (he || !te) && history.state && history.state.scroll || null;
        return Kn().then( () => xe(Q, ee, Ae)).then(z => z && HA(z)).catch(z => C(z, Q, ee))
    }
    const w = Q => i.go(Q);
    let U;
    const re = new Set
      , ie = {
        currentRoute: u,
        listening: !0,
        addRoute: g,
        removeRoute: S,
        hasRoute: v,
        getRoutes: x,
        resolve: I,
        options: e,
        push: k,
        replace: L,
        go: w,
        back: () => w(-1),
        forward: () => w(1),
        beforeEach: s.add,
        beforeResolve: o.add,
        afterEach: a.add,
        onError: _.add,
        isReady: P,
        install(Q) {
            const ee = this;
            Q.component("RouterLink", gM),
            Q.component("RouterView", $2),
            Q.config.globalProperties.$router = ee,
            Object.defineProperty(Q.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => ct(u)
            }),
            co && !U && u.value === wn && (U = !0,
            k(i.location).catch(xe => {}
            ));
            const te = {};
            for (const xe in wn)
                Object.defineProperty(te, xe, {
                    get: () => u.value[xe],
                    enumerable: !0
                });
            Q.provide(Vf, ee),
            Q.provide(Sg, Qu(te)),
            Q.provide(Ch, u);
            const he = Q.unmount;
            re.add(Q),
            Q.unmount = function() {
                re.delete(Q),
                re.size < 1 && (c = wn,
                B && B(),
                B = null,
                u.value = wn,
                U = !1,
                T = !1),
                he()
            }
        }
    };
    function ue(Q) {
        return Q.reduce( (ee, te) => ee.then( () => K(te)), Promise.resolve())
    }
    return ie
}
function vM(e, t) {
    const r = []
      , n = []
      , i = []
      , s = Math.max(t.matched.length, e.matched.length);
    for (let o = 0; o < s; o++) {
        const a = t.matched[o];
        a && (e.matched.find(c => $o(c, a)) ? n.push(a) : r.push(a));
        const u = e.matched[o];
        u && (t.matched.find(c => $o(c, u)) || i.push(u))
    }
    return [r, n, i]
}
function sF() {
    return Kt(Vf)
}
function xM() {
    return Kt(Sg)
}
const EM = (e, t) => t.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, r => {
    var n;
    return ((n = e.params[r.slice(1)]) == null ? void 0 : n.toString()) || ""
}
)
  , kh = (e, t) => {
    const r = e.route.matched.find(i => {
        var s;
        return ((s = i.components) == null ? void 0 : s.default) === e.Component.type
    }
    )
      , n = t ?? (r == null ? void 0 : r.meta.key) ?? (r && EM(e.route, r));
    return typeof n == "function" ? n(e.route) : n
}
  , SM = (e, t) => ({
    default: () => e ? cr(hS, e === !0 ? {} : e, t) : t
});
function _g(e) {
    return Array.isArray(e) ? e : [e]
}
const f0 = null
  , d0 = null
  , h0 = null
  , p0 = null
  , g0 = null
  , by = [{
    name: "download",
    path: "/download",
    meta: {},
    alias: [],
    redirect: f0 == null ? void 0 : f0.redirect,
    component: () => Be( () => import("./D1GKVMkh.js"), __vite__mapDeps([0, 1, 2, 3]), import.meta.url).then(e => e.default || e)
}, {
    name: "index",
    path: "/",
    meta: {},
    alias: [],
    redirect: d0 == null ? void 0 : d0.redirect,
    component: () => Be( () => import("./ZuwYCTpL.js"), __vite__mapDeps([4, 5, 2, 6, 7, 1, 3, 8, 9]), import.meta.url).then(e => e.default || e)
}, {
    name: "privacy",
    path: "/privacy",
    meta: {},
    alias: [],
    redirect: h0 == null ? void 0 : h0.redirect,
    component: () => Be( () => import("./CpHqOkQN.js"), __vite__mapDeps([10, 8, 11]), import.meta.url).then(e => e.default || e)
}, {
    name: "tos",
    path: "/tos",
    meta: {},
    alias: [],
    redirect: p0 == null ? void 0 : p0.redirect,
    component: () => Be( () => import("./DeZxFPLG.js"), __vite__mapDeps([12, 8, 13]), import.meta.url).then(e => e.default || e)
}, {
    name: "wtf",
    path: "/wtf",
    meta: {},
    alias: [],
    redirect: g0 == null ? void 0 : g0.redirect,
    component: () => Be( () => import("./DHDguVmz.js"), __vite__mapDeps([14, 8, 15]), import.meta.url).then(e => e.default || e)
}]
  , F2 = (e, t, r) => (t = t === !0 ? {} : t,
{
    default: () => {
        var n;
        return t ? cr(e, t, r) : (n = r.default) == null ? void 0 : n.call(r)
    }
});
function wy(e) {
    const t = (e == null ? void 0 : e.meta.key) ?? e.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, r => {
        var n;
        return ((n = e.params[r.slice(1)]) == null ? void 0 : n.toString()) || ""
    }
    );
    return typeof t == "function" ? t(e) : t
}
function H2(e, t) {
    return e === t || t === wn ? !1 : wy(e) !== wy(t) ? !0 : !e.matched.every( (n, i) => {
        var s, o;
        return n.components && n.components.default === ((o = (s = t.matched[i]) == null ? void 0 : s.components) == null ? void 0 : o.default)
    }
    )
}
function oF(e, t=!1) {
    if (e) {
        if (e.nodeName === "#comment" && e.nodeValue === "[")
            return q2(e, [], t);
        if (t) {
            const r = e.cloneNode(!0);
            return r.querySelectorAll("[data-island-slot]").forEach(n => {
                n.innerHTML = ""
            }
            ),
            [r.outerHTML]
        }
        return [e.outerHTML]
    }
    return null
}
function q2(e, t=[], r=!1) {
    if (e && e.nodeName) {
        if (AM(e))
            return t;
        if (!_M(e)) {
            const n = e.cloneNode(!0);
            r && n.querySelectorAll("[data-island-slot]").forEach(i => {
                i.innerHTML = ""
            }
            ),
            t.push(n.outerHTML)
        }
        q2(e.nextSibling, t, r)
    }
    return t
}
function _M(e) {
    return e.nodeName === "#comment" && e.nodeValue === "["
}
function AM(e) {
    return e.nodeName === "#comment" && e.nodeValue === "]"
}
const MM = {
    scrollBehavior(e, t, r) {
        var c;
        const n = ut()
          , i = ((c = Ur().options) == null ? void 0 : c.scrollBehaviorType) ?? "auto";
        let s = r || void 0;
        const o = typeof e.meta.scrollToTop == "function" ? e.meta.scrollToTop(e, t) : e.meta.scrollToTop;
        if (!s && t && e && o !== !1 && H2(e, t) && (s = {
            left: 0,
            top: 0
        }),
        e.path === t.path)
            return t.hash && !e.hash ? {
                left: 0,
                top: 0
            } : e.hash ? {
                el: e.hash,
                top: vy(e.hash),
                behavior: i
            } : !1;
        const a = l => !!(l.meta.pageTransition ?? Mh)
          , u = a(t) && a(e) ? "page:transition:finish" : "page:finish";
        return new Promise(l => {
            n.hooks.hookOnce(u, async () => {
                await new Promise(p => setTimeout(p, 0)),
                e.hash && (s = {
                    el: e.hash,
                    top: vy(e.hash),
                    behavior: i
                }),
                l(s)
            }
            )
        }
        )
    }
};
function vy(e) {
    try {
        const t = document.querySelector(e);
        if (t)
            return parseFloat(getComputedStyle(t).scrollMarginTop)
    } catch {}
    return 0
}
const IM = {
    hashMode: !1,
    scrollBehaviorType: "auto"
}
  , $r = {
    ...IM,
    ...MM
}
  , TM = async e => {
    var u;
    let t, r;
    if (!((u = e.meta) != null && u.validate))
        return;
    const n = ut()
      , i = Ur();
    if (([t,r] = lu( () => Promise.resolve(e.meta.validate(e))),
    t = await t,
    r(),
    t) === !0)
        return;
    const o = Ff({
        statusCode: 404,
        statusMessage: `Page Not Found: ${e.fullPath}`,
        data: {
            path: e.fullPath
        }
    })
      , a = i.beforeResolve(c => {
        if (a(),
        c === e) {
            const l = i.afterEach(async () => {
                l(),
                await n.runWithContext( () => ho(o)),
                window.history.pushState({}, "", e.fullPath)
            }
            );
            return !1
        }
    }
    )
}
  , CM = async e => {
    let t, r;
    const n = ([t,r] = lu( () => xg(e.path)),
    t = await t,
    r(),
    t);
    if (n.redirect)
        return xi(n.redirect, {
            acceptRelative: !0
        }) ? (window.location.href = n.redirect,
        !1) : n.redirect
}
  , kM = [TM, CM]
  , Ya = {
    devonly: () => Be( () => import("./-2TFhy4h.js"), [], import.meta.url)
};
function LM(e, t, r) {
    const {pathname: n, search: i, hash: s} = t
      , o = e.indexOf("#");
    if (o > -1) {
        const c = s.includes(e.slice(o)) ? e.slice(o).length : 1;
        let l = s.slice(c);
        return l[0] !== "/" && (l = "/" + l),
        j1(l, "")
    }
    const a = j1(n, e)
      , u = !r || s8(a, r, {
        trailingSlash: !0
    }) ? a : r;
    return u + (u.includes("?") ? "" : i) + s
}
const OM = _t({
    name: "nuxt:router",
    enforce: "pre",
    async setup(e) {
        var v, I;
        let t, r, n = os().app.baseURL;
        $r.hashMode && !n.includes("#") && (n += "#");
        const i = ((v = $r.history) == null ? void 0 : v.call($r, n)) ?? ($r.hashMode ? QA(n) : j2(n))
          , s = ((I = $r.routes) == null ? void 0 : I.call($r, by)) ?? by;
        let o;
        const a = wM({
            ...$r,
            scrollBehavior: (M, A, k) => {
                if (A === wn) {
                    o = k;
                    return
                }
                if ($r.scrollBehavior) {
                    if (a.options.scrollBehavior = $r.scrollBehavior,
                    "scrollRestoration"in window.history) {
                        const L = a.beforeEach( () => {
                            L(),
                            window.history.scrollRestoration = "manual"
                        }
                        )
                    }
                    return $r.scrollBehavior(M, wn, o || k)
                }
            }
            ,
            history: i,
            routes: s
        });
        "scrollRestoration"in window.history && (window.history.scrollRestoration = "auto"),
        e.vueApp.use(a);
        const u = Pr(a.currentRoute.value);
        a.afterEach( (M, A) => {
            u.value = A
        }
        ),
        Object.defineProperty(e.vueApp.config.globalProperties, "previousRoute", {
            get: () => u.value
        });
        const c = LM(n, window.location, e.payload.path)
          , l = Pr(a.currentRoute.value)
          , p = () => {
            l.value = a.currentRoute.value
        }
        ;
        e.hook("page:finish", p),
        a.afterEach( (M, A) => {
            var k, L, O, $;
            ((L = (k = M.matched[0]) == null ? void 0 : k.components) == null ? void 0 : L.default) === (($ = (O = A.matched[0]) == null ? void 0 : O.components) == null ? void 0 : $.default) && p()
        }
        );
        const h = {};
        for (const M in l.value)
            Object.defineProperty(h, M, {
                get: () => l.value[M]
            });
        e._route = Qu(h),
        e._middleware = e._middleware || {
            global: [],
            named: {}
        };
        try {
            [t,r] = lu( () => a.isReady()),
            await t,
            r()
        } catch (M) {
            [t,r] = lu( () => e.runWithContext( () => ho(M))),
            await t,
            r()
        }
        const g = c !== a.currentRoute.value.fullPath ? a.resolve(c) : a.currentRoute.value;
        p();
        const S = e.payload.state._layout;
        a.beforeEach(async (M, A) => {
            var k;
            await e.callHook("page:loading:start"),
            M.meta = Vn(M.meta),
            e.isHydrating && S && !$s(M.meta.layout) && (M.meta.layout = S),
            e._processingMiddleware = !0;
            {
                const L = new Set([...kM, ...e._middleware.global]);
                for (const O of M.matched) {
                    const $ = O.meta.middleware;
                    if ($)
                        for (const D of _g($))
                            L.add(D)
                }
                {
                    const O = await e.runWithContext( () => xg(M.path));
                    if (O.appMiddleware)
                        for (const $ in O.appMiddleware)
                            O.appMiddleware[$] ? L.add($) : L.delete($)
                }
                for (const O of L) {
                    const $ = typeof O == "string" ? e._middleware.named[O] || await ((k = Ya[O]) == null ? void 0 : k.call(Ya).then(K => K.default || K)) : O;
                    if (!$)
                        throw new Error(`Unknown route middleware: '${O}'.`);
                    const D = await e.runWithContext( () => $(M, A));
                    if (!e.payload.serverRendered && e.isHydrating && (D === !1 || D instanceof Error)) {
                        const K = D || xh({
                            statusCode: 404,
                            statusMessage: `Page Not Found: ${c}`
                        });
                        return await e.runWithContext( () => ho(K)),
                        !1
                    }
                    if (D !== !0 && (D || D === !1))
                        return D
                }
            }
        }
        ),
        a.onError(async () => {
            delete e._processingMiddleware,
            await e.callHook("page:loading:end")
        }
        );
        const x = $f();
        return a.afterEach(async (M, A, k) => {
            delete e._processingMiddleware,
            !e.isHydrating && x.value && await e.runWithContext(d2),
            k && await e.callHook("page:loading:end"),
            M.matched.length === 0 && await e.runWithContext( () => ho(xh({
                statusCode: 404,
                fatal: !1,
                statusMessage: `Page not found: ${M.fullPath}`,
                data: {
                    path: M.fullPath
                }
            })))
        }
        ),
        e.hooks.hookOnce("app:created", async () => {
            try {
                "name"in g && (g.name = void 0),
                await a.replace({
                    ...g,
                    force: !0
                }),
                a.options.scrollBehavior = $r.scrollBehavior
            } catch (M) {
                await e.runWithContext( () => ho(M))
            }
        }
        ),
        {
            provide: {
                router: a
            }
        }
    }
})
  , NM = "$s";
function da(...e) {
    const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0;
    typeof e[0] != "string" && e.unshift(t);
    const [r,n] = e;
    if (!r || typeof r != "string")
        throw new TypeError("[nuxt] [useState] key must be a string: " + r);
    if (n !== void 0 && typeof n != "function")
        throw new Error("[nuxt] [useState] init must be a function: " + n);
    const i = NM + r
      , s = ut()
      , o = Xs(s.payload.state, i);
    if (o.value === void 0 && n) {
        const a = n();
        if (bt(a))
            return s.payload.state[i] = a,
            a;
        o.value = a
    }
    return o
}
const RM = _t({
    name: "nuxt-site-config:init",
    enforce: "pre",
    async setup(e) {
        const t = da("site-config");
        let r = {};
        return r = t.value || window.__NUXT_SITE_CONFIG__,
        {
            provide: {
                nuxtSiteConfig: r
            }
        }
    }
})
  , Lh = globalThis.requestIdleCallback || (e => {
    const t = Date.now()
      , r = {
        didTimeout: !1,
        timeRemaining: () => Math.max(0, 50 - (Date.now() - t))
    };
    return setTimeout( () => {
        e(r)
    }
    , 1)
}
)
  , BM = globalThis.cancelIdleCallback || (e => {
    clearTimeout(e)
}
)
  , Ag = e => {
    const t = ut();
    t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", () => {
        Lh(e)
    }
    ) : Lh(e)
}
  , PM = _t({
    name: "nuxt:payload",
    setup(e) {
        Ur().beforeResolve(async (t, r) => {
            if (t.path === r.path)
                return;
            const n = await ey(t.path);
            n && Object.assign(e.static.data, n.data)
        }
        ),
        Ag( () => {
            var t;
            e.hooks.hook("link:prefetch", async r => {
                tc(r).protocol || await ey(r)
            }
            ),
            ((t = navigator.connection) == null ? void 0 : t.effectiveType) !== "slow-2g" && setTimeout(qf, 1e3)
        }
        )
    }
})
  , jM = _t(e => {
    let t;
    async function r() {
        const n = await qf();
        t && clearTimeout(t),
        t = setTimeout(r, 1e3 * 60 * 60);
        try {
            const i = await $fetch(gg("builds/latest.json") + `?${Date.now()}`);
            i.id !== n.id && e.hooks.callHook("app:manifest:update", i)
        } catch {}
    }
    Ag( () => {
        t = setTimeout(r, 1e3 * 60 * 60)
    }
    )
}
)
  , DM = !1;
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let W2;
const rc = e => W2 = e
  , V2 = Symbol();
function Oh(e) {
    return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function"
}
var Za;
(function(e) {
    e.direct = "direct",
    e.patchObject = "patch object",
    e.patchFunction = "patch function"
}
)(Za || (Za = {}));
function UM() {
    const e = Mf(!0)
      , t = e.run( () => Ue({}));
    let r = []
      , n = [];
    const i = Cf({
        install(s) {
            rc(i),
            i._a = s,
            s.provide(V2, i),
            s.config.globalProperties.$pinia = i,
            n.forEach(o => r.push(o)),
            n = []
        },
        use(s) {
            return !this._a && !DM ? n.push(s) : r.push(s),
            this
        },
        _p: r,
        _a: null,
        _e: e,
        _s: new Map,
        state: t
    });
    return i
}
const K2 = () => {}
;
function xy(e, t, r, n=K2) {
    e.push(t);
    const i = () => {
        const s = e.indexOf(t);
        s > -1 && (e.splice(s, 1),
        n())
    }
    ;
    return !r && If() && Kp(i),
    i
}
function so(e, ...t) {
    e.slice().forEach(r => {
        r(...t)
    }
    )
}
const zM = e => e();
function Nh(e, t) {
    e instanceof Map && t instanceof Map && t.forEach( (r, n) => e.set(n, r)),
    e instanceof Set && t instanceof Set && t.forEach(e.add, e);
    for (const r in t) {
        if (!t.hasOwnProperty(r))
            continue;
        const n = t[r]
          , i = e[r];
        Oh(i) && Oh(n) && e.hasOwnProperty(r) && !bt(n) && !hi(n) ? e[r] = Nh(i, n) : e[r] = n
    }
    return e
}
const $M = Symbol();
function FM(e) {
    return !Oh(e) || !e.hasOwnProperty($M)
}
const {assign: Ni} = Object;
function HM(e) {
    return !!(bt(e) && e.effect)
}
function qM(e, t, r, n) {
    const {state: i, actions: s, getters: o} = t
      , a = r.state.value[e];
    let u;
    function c() {
        a || (r.state.value[e] = i ? i() : {});
        const l = ov(r.state.value[e]);
        return Ni(l, s, Object.keys(o || {}).reduce( (p, h) => (p[h] = Cf(Se( () => {
            rc(r);
            const g = r._s.get(e);
            return o[h].call(g, g)
        }
        )),
        p), {}))
    }
    return u = G2(e, c, t, r, n, !0),
    u
}
function G2(e, t, r={}, n, i, s) {
    let o;
    const a = Ni({
        actions: {}
    }, r)
      , u = {
        deep: !0
    };
    let c, l, p = [], h = [], g;
    const S = n.state.value[e];
    !s && !S && (n.state.value[e] = {}),
    Ue({});
    let x;
    function v(D) {
        let K;
        c = l = !1,
        typeof D == "function" ? (D(n.state.value[e]),
        K = {
            type: Za.patchFunction,
            storeId: e,
            events: g
        }) : (Nh(n.state.value[e], D),
        K = {
            type: Za.patchObject,
            payload: D,
            storeId: e,
            events: g
        });
        const G = x = Symbol();
        Kn().then( () => {
            x === G && (c = !0)
        }
        ),
        l = !0,
        so(p, K, n.state.value[e])
    }
    const I = s ? function() {
        const {state: K} = r
          , G = K ? K() : {};
        this.$patch(F => {
            Ni(F, G)
        }
        )
    }
    : K2;
    function M() {
        o.stop(),
        p = [],
        h = [],
        n._s.delete(e)
    }
    function A(D, K) {
        return function() {
            rc(n);
            const G = Array.from(arguments)
              , F = []
              , q = [];
            function B(_) {
                F.push(_)
            }
            function y(_) {
                q.push(_)
            }
            so(h, {
                args: G,
                name: D,
                store: L,
                after: B,
                onError: y
            });
            let b;
            try {
                b = K.apply(this && this.$id === e ? this : L, G)
            } catch (_) {
                throw so(q, _),
                _
            }
            return b instanceof Promise ? b.then(_ => (so(F, _),
            _)).catch(_ => (so(q, _),
            Promise.reject(_))) : (so(F, b),
            b)
        }
    }
    const k = {
        _p: n,
        $id: e,
        $onAction: xy.bind(null, h),
        $patch: v,
        $reset: I,
        $subscribe(D, K={}) {
            const G = xy(p, D, K.detached, () => F())
              , F = o.run( () => vt( () => n.state.value[e], q => {
                (K.flush === "sync" ? l : c) && D({
                    storeId: e,
                    type: Za.direct,
                    events: g
                }, q)
            }
            , Ni({}, u, K)));
            return G
        },
        $dispose: M
    }
      , L = Vn(k);
    n._s.set(e, L);
    const $ = (n._a && n._a.runWithContext || zM)( () => n._e.run( () => (o = Mf()).run(t)));
    for (const D in $) {
        const K = $[D];
        if (bt(K) && !HM(K) || hi(K))
            s || (S && FM(K) && (bt(K) ? K.value = S[D] : Nh(K, S[D])),
            n.state.value[e][D] = K);
        else if (typeof K == "function") {
            const G = A(D, K);
            $[D] = G,
            a.actions[D] = K
        }
    }
    return Ni(L, $),
    Ni(Ke(L), $),
    Object.defineProperty(L, "$state", {
        get: () => n.state.value[e],
        set: D => {
            v(K => {
                Ni(K, D)
            }
            )
        }
    }),
    n._p.forEach(D => {
        Ni(L, o.run( () => D({
            store: L,
            app: n._a,
            pinia: n,
            options: a
        })))
    }
    ),
    S && s && r.hydrate && r.hydrate(L.$state, S),
    c = !0,
    l = !0,
    L
}
function WM(e, t, r) {
    let n, i;
    const s = typeof t == "function";
    typeof e == "string" ? (n = e,
    i = s ? r : t) : (i = e,
    n = e.id);
    function o(a, u) {
        const c = cg();
        return a = a || (c ? Kt(V2, null) : null),
        a && rc(a),
        a = W2,
        a._s.has(n) || (s ? G2(n, t, i, a) : qM(n, i, a)),
        a._s.get(n)
    }
    return o.$id = n,
    o
}
function aF(e) {
    {
        e = Ke(e);
        const t = {};
        for (const r in e) {
            const n = e[r];
            (bt(n) || hi(n)) && (t[r] = Xs(e, r))
        }
        return t
    }
}
async function Q2(e, t=Ur()) {
    const {path: r, matched: n} = t.resolve(e);
    if (!n.length || (t._routePreloaded || (t._routePreloaded = new Set),
    t._routePreloaded.has(r)))
        return;
    const i = t._preloadPromises = t._preloadPromises || [];
    if (i.length > 4)
        return Promise.all(i).then( () => Q2(e, t));
    t._routePreloaded.add(r);
    const s = n.map(o => {
        var a;
        return (a = o.components) == null ? void 0 : a.default
    }
    ).filter(o => typeof o == "function");
    for (const o of s) {
        const a = Promise.resolve(o()).catch( () => {}
        ).finally( () => i.splice(i.indexOf(a)));
        i.push(a)
    }
    await Promise.all(i)
}
function VM(e={}) {
    const t = e.path || window.location.pathname;
    let r = {};
    try {
        r = Fl(sessionStorage.getItem("nuxt:reload") || "{}")
    } catch {}
    if (e.force || (r == null ? void 0 : r.path) !== t || (r == null ? void 0 : r.expires) < Date.now()) {
        try {
            sessionStorage.setItem("nuxt:reload", JSON.stringify({
                path: t,
                expires: Date.now() + (e.ttl ?? 1e4)
            }))
        } catch {}
        if (e.persistState)
            try {
                sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
                    state: ut().payload.state
                }))
            } catch {}
        window.location.pathname !== t ? window.location.href = t : window.location.reload()
    }
}
const KM = (...e) => e.find(t => t !== void 0);
function GM(e) {
    const t = e.componentName || "NuxtLink";
    function r(n, i) {
        if (!n || e.trailingSlash !== "append" && e.trailingSlash !== "remove")
            return n;
        if (typeof n == "string")
            return Ey(n, e.trailingSlash);
        const s = "path"in n && n.path !== void 0 ? n.path : i(n).path;
        return {
            ...n,
            name: void 0,
            path: Ey(s, e.trailingSlash)
        }
    }
    return lr({
        name: t,
        props: {
            to: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            href: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            target: {
                type: String,
                default: void 0,
                required: !1
            },
            rel: {
                type: String,
                default: void 0,
                required: !1
            },
            noRel: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            prefetch: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            noPrefetch: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            activeClass: {
                type: String,
                default: void 0,
                required: !1
            },
            exactActiveClass: {
                type: String,
                default: void 0,
                required: !1
            },
            prefetchedClass: {
                type: String,
                default: void 0,
                required: !1
            },
            replace: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            ariaCurrentValue: {
                type: String,
                default: void 0,
                required: !1
            },
            external: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            custom: {
                type: Boolean,
                default: void 0,
                required: !1
            }
        },
        setup(n, {slots: i}) {
            const s = Ur()
              , o = os()
              , a = Se( () => {
                const S = n.to || n.href || "";
                return r(S, s.resolve)
            }
            )
              , u = Se( () => typeof a.value == "string" && xi(a.value, {
                acceptRelative: !0
            }))
              , c = Se( () => n.target && n.target !== "_self")
              , l = Se( () => n.external || c.value ? !0 : typeof a.value == "object" ? !1 : a.value === "" || u.value)
              , p = Ue(!1)
              , h = Ue(null)
              , g = S => {
                var x;
                h.value = n.custom ? (x = S == null ? void 0 : S.$el) == null ? void 0 : x.nextElementSibling : S == null ? void 0 : S.$el
            }
            ;
            if (n.prefetch !== !1 && n.noPrefetch !== !0 && n.target !== "_blank" && !ZM()) {
                const x = ut();
                let v, I = null;
                vi( () => {
                    const M = YM();
                    Ag( () => {
                        v = Lh( () => {
                            var A;
                            (A = h == null ? void 0 : h.value) != null && A.tagName && (I = M.observe(h.value, async () => {
                                I == null || I(),
                                I = null;
                                const k = typeof a.value == "string" ? a.value : s.resolve(a.value).fullPath;
                                await Promise.all([x.hooks.callHook("link:prefetch", k).catch( () => {}
                                ), !l.value && Q2(a.value, s).catch( () => {}
                                )]),
                                p.value = !0
                            }
                            ))
                        }
                        )
                    }
                    )
                }
                ),
                Ju( () => {
                    v && BM(v),
                    I == null || I(),
                    I = null
                }
                )
            }
            return () => {
                var I, M;
                if (!l.value) {
                    const A = {
                        ref: g,
                        to: a.value,
                        activeClass: n.activeClass || e.activeClass,
                        exactActiveClass: n.exactActiveClass || e.exactActiveClass,
                        replace: n.replace,
                        ariaCurrentValue: n.ariaCurrentValue,
                        custom: n.custom
                    };
                    return n.custom || (p.value && (A.class = n.prefetchedClass || e.prefetchedClass),
                    A.rel = n.rel || void 0),
                    cr(YE("RouterLink"), A, i.default)
                }
                const S = typeof a.value == "object" ? ((I = s.resolve(a.value)) == null ? void 0 : I.href) ?? null : a.value && !n.external && !u.value ? r(zf(o.app.baseURL, a.value), s.resolve) : a.value || null
                  , x = n.target || null
                  , v = KM(n.noRel ? "" : n.rel, e.externalRelAttribute, u.value || c.value ? "noopener noreferrer" : "") || null;
                if (n.custom) {
                    if (!i.default)
                        return null;
                    const A = () => a5(S, {
                        replace: n.replace,
                        external: n.external
                    });
                    return i.default({
                        href: S,
                        navigate: A,
                        get route() {
                            if (!S)
                                return;
                            const k = tc(S);
                            return {
                                path: k.pathname,
                                fullPath: k.pathname,
                                get query() {
                                    return Yv(k.search)
                                },
                                hash: k.hash,
                                params: {},
                                name: void 0,
                                matched: [],
                                redirectedFrom: void 0,
                                meta: {},
                                href: S
                            }
                        },
                        rel: v,
                        target: x,
                        isExternal: l.value,
                        isActive: !1,
                        isExactActive: !1
                    })
                }
                return cr("a", {
                    ref: h,
                    href: S,
                    rel: v,
                    target: x
                }, (M = i.default) == null ? void 0 : M.call(i))
            }
        }
    })
}
const QM = GM(uA);
function Ey(e, t) {
    const r = t === "append" ? ql : Df;
    return xi(e) && !e.startsWith("http") ? e : r(e, !0)
}
function YM() {
    const e = ut();
    if (e._observer)
        return e._observer;
    let t = null;
    const r = new Map
      , n = (s, o) => (t || (t = new IntersectionObserver(a => {
        for (const u of a) {
            const c = r.get(u.target);
            (u.isIntersecting || u.intersectionRatio > 0) && c && c()
        }
    }
    )),
    r.set(s, o),
    t.observe(s),
    () => {
        r.delete(s),
        t.unobserve(s),
        r.size === 0 && (t.disconnect(),
        t = null)
    }
    );
    return e._observer = {
        observe: n
    }
}
function ZM() {
    const e = navigator.connection;
    return !!(e && (e.saveData || /2g/.test(e.effectiveType)))
}
const JM = _t(e => {
    const t = UM();
    return e.vueApp.use(t),
    rc(t),
    e.payload && e.payload.pinia && (t.state.value = e.payload.pinia),
    {
        provide: {
            pinia: t
        }
    }
}
)
  , XM = qe( () => Be( () => import("./D0eSoN2t.js"), __vite__mapDeps([16, 5, 2, 6, 17]), import.meta.url).then(e => e.default || e.default || e))
  , eI = qe( () => Be( () => import("./Dn4Y3_gJ.js"), __vite__mapDeps([18, 19, 20, 21, 22, 23, 24]), import.meta.url).then(e => e.default || e.default || e))
  , tI = qe( () => Be( () => import("./CaVQExbI.js"), __vite__mapDeps([25, 23, 24, 22]), import.meta.url).then(e => e.default || e.default || e))
  , rI = qe( () => Be( () => import("./CJZAWsTM.js"), __vite__mapDeps([26, 24, 22]), import.meta.url).then(e => e.default || e.default || e))
  , nI = qe( () => Be( () => import("./KYTQi-wr.js"), __vite__mapDeps([23, 24, 22]), import.meta.url).then(e => e.default || e.default || e))
  , iI = qe( () => Be( () => import("./AOrSYlDQ.js"), __vite__mapDeps([19, 20, 21, 22]), import.meta.url).then(e => e.default || e.default || e))
  , sI = qe( () => Be( () => import("./B4c7Ua3S.js"), __vite__mapDeps([27, 20, 21, 22]), import.meta.url).then(e => e.default || e.default || e))
  , oI = qe( () => Be( () => import("./CeFiirrS.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , aI = qe( () => Be( () => import("./CiQBbzqc.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , uI = qe( () => Be( () => import("./CO_D5t0Z.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , cI = qe( () => Be( () => import("./Bb3LV7NO.js"), __vite__mapDeps([28, 29]), import.meta.url).then(e => e.default || e.default || e))
  , lI = qe( () => Be( () => import("./8LqkhGLL.js"), __vite__mapDeps([30, 31, 32]), import.meta.url).then(e => e.default || e.default || e))
  , fI = qe( () => Be( () => import("./YfWWKaj_.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , dI = qe( () => Be( () => import("./CkbLC2tE.js"), __vite__mapDeps([33, 31, 32]), import.meta.url).then(e => e.default || e.default || e))
  , hI = qe( () => Be( () => import("./LWw-K4Kb.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , pI = qe( () => Be( () => import("./r_uKh3JW.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , gI = qe( () => Be( () => import("./Dwv8pIMD.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , mI = qe( () => Be( () => import("./DBz9emXD.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , yI = qe( () => Be( () => import("./tFBVo9-9.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , bI = qe( () => Be( () => import("./CQ4fBe86.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , wI = qe( () => Be( () => import("./BzF3SzjN.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , vI = qe( () => Be( () => import("./Bbt8s-Xt.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , xI = qe( () => Be( () => import("./CYB4riCj.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , EI = qe( () => Be( () => import("./Cto21wWs.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , SI = qe( () => Be( () => import("./DilLFQ3U.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , _I = qe( () => Be( () => import("./B5UzysfY.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , AI = qe( () => Be( () => import("./DC8JnLSR.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , MI = qe( () => Be( () => import("./BxKmISQ_.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , II = qe( () => Be( () => import("./DL_YmWnJ.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , TI = qe( () => Be( () => import("./B_stL5yb.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , CI = qe( () => Be( () => import("./mbkKWfp6.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , kI = qe( () => Be( () => import("./CbGSmPfG.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , LI = qe( () => Be( () => import("./25F93RKv.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , OI = qe( () => Be( () => import("./K8nJhIYH.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , NI = qe( () => Be( () => import("./Cb_OliMl.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , RI = qe( () => Be( () => import("./Ea5flwiE.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , BI = qe( () => Be( () => import("./BQG2PFbB.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , PI = qe( () => Be( () => Promise.resolve().then( () => f$), void 0, import.meta.url).then(e => e.default || e.default || e))
  , jI = qe( () => Be( () => import("./YzQ7Yq7Z.js"), __vite__mapDeps([34, 35]), import.meta.url).then(e => e.default || e.default || e))
  , DI = [["ConnectWalletModal", XM], ["ContentDoc", eI], ["ContentList", tI], ["ContentNavigation", rI], ["ContentQuery", nI], ["ContentRenderer", iI], ["ContentRendererMarkdown", sI], ["MDCSlot", oI], ["DocumentDrivenEmpty", aI], ["DocumentDrivenNotFound", uI], ["Markdown", cI], ["ProseCode", lI], ["ProseCodeInline", fI], ["ProsePre", dI], ["ProseA", hI], ["ProseBlockquote", pI], ["ProseEm", gI], ["ProseH1", mI], ["ProseH2", yI], ["ProseH3", bI], ["ProseH4", wI], ["ProseH5", vI], ["ProseH6", xI], ["ProseHr", EI], ["ProseImg", SI], ["ProseLi", _I], ["ProseOl", AI], ["ProseP", MI], ["ProseScript", II], ["ProseStrong", TI], ["ProseTable", CI], ["ProseTbody", kI], ["ProseTd", LI], ["ProseTh", OI], ["ProseThead", NI], ["ProseTr", RI], ["ProseUl", BI], ["Icon", PI], ["IconCSS", jI]]
  , UI = _t({
    name: "nuxt:global-components",
    setup(e) {
        for (const [t,r] of DI)
            e.vueApp.component(t, r),
            e.vueApp.component("Lazy" + t, r)
    }
})
  , Wi = {
    default: () => Be( () => import("./B8pLC7Uw.js"), __vite__mapDeps([36, 7, 5, 2]), import.meta.url).then(e => e.default || e)
}
  , zI = _t({
    name: "nuxt:prefetch",
    setup(e) {
        const t = Ur();
        e.hooks.hook("app:mounted", () => {
            t.beforeEach(async r => {
                var i;
                const n = (i = r == null ? void 0 : r.meta) == null ? void 0 : i.layout;
                n && typeof Wi[n] == "function" && await Wi[n]()
            }
            )
        }
        ),
        e.hooks.hook("link:prefetch", r => {
            if (xi(r))
                return;
            const n = t.resolve(r);
            if (!n)
                return;
            const i = n.meta.layout;
            let s = _g(n.meta.middleware);
            s = s.filter(o => typeof o == "string");
            for (const o of s)
                typeof Ya[o] == "function" && Ya[o]();
            i && typeof Wi[i] == "function" && Wi[i]()
        }
        )
    }
});
function fl(...e) {
    var t;
    (t = window.dataLayer) == null || t.push(arguments)
}
function Y2({tags: e}) {
    window.dataLayer = window.dataLayer || [];
    for (const t of e)
        for (const r of t.initCommands ?? [])
            fl(...r);
    fl("js", new Date);
    for (const t of e)
        fl("config", t.id, t.config ?? {})
}
function Z2(e) {
    const t = Ke(e)
      , r = t.tags.filter(Boolean).map(n => typeof n == "string" ? {
        id: n
    } : n);
    if (t.id) {
        const {id: n, config: i, initCommands: s} = t;
        r.unshift({
            id: n,
            config: i,
            initCommands: s
        })
    }
    return r
}
const $I = _t({
    parallel: !0,
    setup() {
        const e = os().public.gtag
          , t = Z2(e);
        if (!t.length || (Y2({
            tags: t
        }),
        !e.enabled))
            return;
        const r = e.loadingStrategy === "async" ? "async" : "defer";
        Hf({
            script: [{
                src: Uf(e.url, {
                    id: t[0].id
                }),
                [r]: !0,
                "data-gtag": ""
            }]
        })
    }
});
function ns(e) {
    return If() ? (Kp(e),
    !0) : !1
}
function FI(e) {
    let t = 0, r, n;
    const i = () => {
        t -= 1,
        n && t <= 0 && (n.stop(),
        r = void 0,
        n = void 0)
    }
    ;
    return (...s) => (t += 1,
    r || (n = Mf(!0),
    r = n.run( () => e(...s))),
    ns(i),
    r)
}
function gn(e) {
    return typeof e == "function" ? e() : ct(e)
}
const hu = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const HI = e => e != null
  , qI = Object.prototype.toString
  , WI = e => qI.call(e) === "[object Object]"
  , Sy = () => +Date.now()
  , Rh = () => {}
;
function J2(e, t) {
    function r(...n) {
        return new Promise( (i, s) => {
            Promise.resolve(e( () => t.apply(this, n), {
                fn: t,
                thisArg: this,
                args: n
            })).then(i).catch(s)
        }
        )
    }
    return r
}
const X2 = e => e();
function VI(e, t={}) {
    let r, n, i = Rh;
    const s = a => {
        clearTimeout(a),
        i(),
        i = Rh
    }
    ;
    return a => {
        const u = gn(e)
          , c = gn(t.maxWait);
        return r && s(r),
        u <= 0 || c !== void 0 && c <= 0 ? (n && (s(n),
        n = null),
        Promise.resolve(a())) : new Promise( (l, p) => {
            i = t.rejectOnCancel ? p : l,
            c && !n && (n = setTimeout( () => {
                r && s(r),
                n = null,
                l(a())
            }
            , c)),
            r = setTimeout( () => {
                n && s(n),
                n = null,
                l(a())
            }
            , u)
        }
        )
    }
}
function KI(e=X2) {
    const t = Ue(!0);
    function r() {
        t.value = !1
    }
    function n() {
        t.value = !0
    }
    const i = (...s) => {
        t.value && e(...s)
    }
    ;
    return {
        isActive: Yu(t),
        pause: r,
        resume: n,
        eventFilter: i
    }
}
function GI(e, t) {
    var r;
    if (typeof e == "number")
        return e + t;
    const n = ((r = e.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : r[0]) || ""
      , i = e.slice(n.length)
      , s = Number.parseFloat(n) + t;
    return Number.isNaN(s) ? e : s + i
}
function ex(e) {
    return e || Gn()
}
function uF(e, t=200, r={}) {
    return J2(VI(t, r), e)
}
function QI(e, t, r={}) {
    const {eventFilter: n=X2, ...i} = r;
    return vt(e, J2(n, t), i)
}
function YI(e, t, r={}) {
    const {eventFilter: n, ...i} = r
      , {eventFilter: s, pause: o, resume: a, isActive: u} = KI(n);
    return {
        stop: QI(e, t, {
            ...i,
            eventFilter: s
        }),
        pause: o,
        resume: a,
        isActive: u
    }
}
function tx(e, t=!0, r) {
    ex() ? vi(e, r) : t ? e() : Kn(e)
}
function cF(e, t) {
    ex(t) && ca(e, t)
}
function ZI(e, t=1e3, r={}) {
    const {immediate: n=!0, immediateCallback: i=!1} = r;
    let s = null;
    const o = Ue(!1);
    function a() {
        s && (clearInterval(s),
        s = null)
    }
    function u() {
        o.value = !1,
        a()
    }
    function c() {
        const l = gn(t);
        l <= 0 || (o.value = !0,
        i && e(),
        a(),
        s = setInterval(e, l))
    }
    if (n && hu && c(),
    bt(t) || typeof t == "function") {
        const l = vt(t, () => {
            o.value && hu && c()
        }
        );
        ns(l)
    }
    return ns(u),
    {
        isActive: o,
        pause: u,
        resume: c
    }
}
function lF(e, t, r) {
    return vt(e, t, {
        ...r,
        immediate: !0
    })
}
function Ss(e) {
    var t;
    const r = gn(e);
    return (t = r == null ? void 0 : r.$el) != null ? t : r
}
const In = hu ? window : void 0
  , JI = hu ? window.navigator : void 0;
function _s(...e) {
    let t, r, n, i;
    if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([r,n,i] = e,
    t = In) : [t,r,n,i] = e,
    !t)
        return Rh;
    Array.isArray(r) || (r = [r]),
    Array.isArray(n) || (n = [n]);
    const s = []
      , o = () => {
        s.forEach(l => l()),
        s.length = 0
    }
      , a = (l, p, h, g) => (l.addEventListener(p, h, g),
    () => l.removeEventListener(p, h, g))
      , u = vt( () => [Ss(t), gn(i)], ([l,p]) => {
        if (o(),
        !l)
            return;
        const h = WI(p) ? {
            ...p
        } : p;
        s.push(...r.flatMap(g => n.map(S => a(l, g, S, h))))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , c = () => {
        u(),
        o()
    }
    ;
    return ns(c),
    c
}
function XI(e) {
    return typeof e == "function" ? e : typeof e == "string" ? t => t.key === e : Array.isArray(e) ? t => e.includes(t.key) : () => !0
}
function fF(...e) {
    let t, r, n = {};
    e.length === 3 ? (t = e[0],
    r = e[1],
    n = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0,
    r = e[0],
    n = e[1]) : (t = e[0],
    r = e[1]) : (t = !0,
    r = e[0]);
    const {target: i=In, eventName: s="keydown", passive: o=!1, dedupe: a=!1} = n
      , u = XI(t);
    return _s(i, s, l => {
        l.repeat && gn(a) || u(l) && r(l)
    }
    , o)
}
function eT() {
    const e = Ue(!1)
      , t = Gn();
    return t && vi( () => {
        e.value = !0
    }
    , t),
    e
}
function Mg(e) {
    const t = eT();
    return Se( () => (t.value,
    !!e()))
}
function tT(e, t={}) {
    const {immediate: r=!0, fpsLimit: n=void 0, window: i=In} = t
      , s = Ue(!1)
      , o = n ? 1e3 / n : null;
    let a = 0
      , u = null;
    function c(h) {
        if (!s.value || !i)
            return;
        a || (a = h);
        const g = h - a;
        if (o && g < o) {
            u = i.requestAnimationFrame(c);
            return
        }
        a = h,
        e({
            delta: g,
            timestamp: h
        }),
        u = i.requestAnimationFrame(c)
    }
    function l() {
        !s.value && i && (s.value = !0,
        a = 0,
        u = i.requestAnimationFrame(c))
    }
    function p() {
        s.value = !1,
        u != null && i && (i.cancelAnimationFrame(u),
        u = null)
    }
    return r && l(),
    ns(p),
    {
        isActive: Yu(s),
        pause: p,
        resume: l
    }
}
function Aa(e, t={}) {
    const {window: r=In} = t
      , n = Mg( () => r && "matchMedia"in r && typeof r.matchMedia == "function");
    let i;
    const s = Ue(!1)
      , o = c => {
        s.value = c.matches
    }
      , a = () => {
        i && ("removeEventListener"in i ? i.removeEventListener("change", o) : i.removeListener(o))
    }
      , u = Cn( () => {
        n.value && (a(),
        i = r.matchMedia(gn(e)),
        "addEventListener"in i ? i.addEventListener("change", o) : i.addListener(o),
        s.value = i.matches)
    }
    );
    return ns( () => {
        u(),
        a(),
        i = void 0
    }
    ),
    s
}
const dF = {
    sm: 640,
    md: 768,
    lg: 1024,
    xl: 1280,
    "2xl": 1536
};
function hF(e, t={}) {
    function r(l, p) {
        let h = gn(e[gn(l)]);
        return p != null && (h = GI(h, p)),
        typeof h == "number" && (h = `${h}px`),
        h
    }
    const {window: n=In, strategy: i="min-width"} = t;
    function s(l) {
        return n ? n.matchMedia(l).matches : !1
    }
    const o = l => Aa( () => `(min-width: ${r(l)})`, t)
      , a = l => Aa( () => `(max-width: ${r(l)})`, t)
      , u = Object.keys(e).reduce( (l, p) => (Object.defineProperty(l, p, {
        get: () => i === "min-width" ? o(p) : a(p),
        enumerable: !0,
        configurable: !0
    }),
    l), {});
    function c() {
        const l = Object.keys(e).map(p => [p, o(p)]);
        return Se( () => l.filter( ([,p]) => p.value).map( ([p]) => p))
    }
    return Object.assign(u, {
        greaterOrEqual: o,
        smallerOrEqual: a,
        greater(l) {
            return Aa( () => `(min-width: ${r(l, .1)})`, t)
        },
        smaller(l) {
            return Aa( () => `(max-width: ${r(l, -.1)})`, t)
        },
        between(l, p) {
            return Aa( () => `(min-width: ${r(l)}) and (max-width: ${r(p, -.1)})`, t)
        },
        isGreater(l) {
            return s(`(min-width: ${r(l, .1)})`)
        },
        isGreaterOrEqual(l) {
            return s(`(min-width: ${r(l)})`)
        },
        isSmaller(l) {
            return s(`(max-width: ${r(l, -.1)})`)
        },
        isSmallerOrEqual(l) {
            return s(`(max-width: ${r(l)})`)
        },
        isInBetween(l, p) {
            return s(`(min-width: ${r(l)}) and (max-width: ${r(p, -.1)})`)
        },
        current: c,
        active() {
            const l = c();
            return Se( () => l.value.length === 0 ? "" : l.value.at(-1))
        }
    })
}
const Lc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , Oc = "__vueuse_ssr_handlers__"
  , rT = nT();
function nT() {
    return Oc in Lc || (Lc[Oc] = Lc[Oc] || {}),
    Lc[Oc]
}
function iT(e, t) {
    return rT[e] || t
}
function sT(e) {
    return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number"
}
const oT = {
    boolean: {
        read: e => e === "true",
        write: e => String(e)
    },
    object: {
        read: e => JSON.parse(e),
        write: e => JSON.stringify(e)
    },
    number: {
        read: e => Number.parseFloat(e),
        write: e => String(e)
    },
    any: {
        read: e => e,
        write: e => String(e)
    },
    string: {
        read: e => e,
        write: e => String(e)
    },
    map: {
        read: e => new Map(JSON.parse(e)),
        write: e => JSON.stringify(Array.from(e.entries()))
    },
    set: {
        read: e => new Set(JSON.parse(e)),
        write: e => JSON.stringify(Array.from(e))
    },
    date: {
        read: e => new Date(e),
        write: e => e.toISOString()
    }
}
  , _y = "vueuse-storage";
function Ua(e, t, r, n={}) {
    var i;
    const {flush: s="pre", deep: o=!0, listenToStorageChanges: a=!0, writeDefaults: u=!0, mergeDefaults: c=!1, shallow: l, window: p=In, eventFilter: h, onError: g=G => {
        console.error(G)
    }
    , initOnMounted: S} = n
      , x = (l ? Pr : Ue)(typeof t == "function" ? t() : t);
    if (!r)
        try {
            r = iT("getDefaultStorage", () => {
                var G;
                return (G = In) == null ? void 0 : G.localStorage
            }
            )()
        } catch (G) {
            g(G)
        }
    if (!r)
        return x;
    const v = gn(t)
      , I = sT(v)
      , M = (i = n.serializer) != null ? i : oT[I]
      , {pause: A, resume: k} = YI(x, () => O(x.value), {
        flush: s,
        deep: o,
        eventFilter: h
    });
    p && a && tx( () => {
        _s(p, "storage", D),
        _s(p, _y, K),
        S && D()
    }
    ),
    S || D();
    function L(G, F) {
        p && p.dispatchEvent(new CustomEvent(_y,{
            detail: {
                key: e,
                oldValue: G,
                newValue: F,
                storageArea: r
            }
        }))
    }
    function O(G) {
        try {
            const F = r.getItem(e);
            if (G == null)
                L(F, null),
                r.removeItem(e);
            else {
                const q = M.write(G);
                F !== q && (r.setItem(e, q),
                L(F, q))
            }
        } catch (F) {
            g(F)
        }
    }
    function $(G) {
        const F = G ? G.newValue : r.getItem(e);
        if (F == null)
            return u && v != null && r.setItem(e, M.write(v)),
            v;
        if (!G && c) {
            const q = M.read(F);
            return typeof c == "function" ? c(q, v) : I === "object" && !Array.isArray(q) ? {
                ...v,
                ...q
            } : q
        } else
            return typeof F != "string" ? F : M.read(F)
    }
    function D(G) {
        if (!(G && G.storageArea !== r)) {
            if (G && G.key == null) {
                x.value = v;
                return
            }
            if (!(G && G.key !== e)) {
                A();
                try {
                    (G == null ? void 0 : G.newValue) !== M.write(x.value) && (x.value = $(G))
                } catch (F) {
                    g(F)
                } finally {
                    G ? Kn(k) : k()
                }
            }
        }
    }
    function K(G) {
        D(G.detail)
    }
    return x
}
function pF(e={}) {
    const {window: t=In} = e
      , r = Ue(1);
    if (t) {
        let n = function() {
            r.value = t.devicePixelRatio,
            i(),
            s = t.matchMedia(`(resolution: ${r.value}dppx)`),
            s.addEventListener("change", n, {
                once: !0
            })
        }, i = function() {
            s == null || s.removeEventListener("change", n)
        }, s;
        n(),
        ns(i)
    }
    return {
        pixelRatio: r
    }
}
function gF(e, t={}) {
    const r = Ue(!1)
      , n = Pr(null);
    let i = 0
      , s = !0;
    if (hu) {
        const o = typeof t == "function" ? {
            onDrop: t
        } : t
          , a = u => {
            var c, l;
            const p = Array.from((l = (c = u.dataTransfer) == null ? void 0 : c.files) != null ? l : []);
            return n.value = p.length === 0 ? null : p
        }
        ;
        _s(e, "dragenter", u => {
            var c, l;
            const p = Array.from(((c = u == null ? void 0 : u.dataTransfer) == null ? void 0 : c.items) || []).map(h => h.kind === "file" ? h.type : null).filter(HI);
            if (o.dataTypes && u.dataTransfer) {
                const h = ct(o.dataTypes);
                if (s = typeof h == "function" ? h(p) : h ? h.some(g => p.includes(g)) : !0,
                !s)
                    return
            }
            u.preventDefault(),
            i += 1,
            r.value = !0,
            (l = o.onEnter) == null || l.call(o, a(u), u)
        }
        ),
        _s(e, "dragover", u => {
            var c;
            s && (u.preventDefault(),
            (c = o.onOver) == null || c.call(o, a(u), u))
        }
        ),
        _s(e, "dragleave", u => {
            var c;
            s && (u.preventDefault(),
            i -= 1,
            i === 0 && (r.value = !1),
            (c = o.onLeave) == null || c.call(o, a(u), u))
        }
        ),
        _s(e, "drop", u => {
            var c;
            u.preventDefault(),
            i = 0,
            r.value = !1,
            (c = o.onDrop) == null || c.call(o, a(u), u)
        }
        )
    }
    return {
        files: n,
        isOverDropZone: r
    }
}
function aT(e, t, r={}) {
    const {window: n=In, ...i} = r;
    let s;
    const o = Mg( () => n && "ResizeObserver"in n)
      , a = () => {
        s && (s.disconnect(),
        s = void 0)
    }
      , u = Se( () => Array.isArray(e) ? e.map(p => Ss(p)) : [Ss(e)])
      , c = vt(u, p => {
        if (a(),
        o.value && n) {
            s = new ResizeObserver(t);
            for (const h of p)
                h && s.observe(h, i)
        }
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , l = () => {
        a(),
        c()
    }
    ;
    return ns(l),
    {
        isSupported: o,
        stop: l
    }
}
function mF(e, t={
    width: 0,
    height: 0
}, r={}) {
    const {window: n=In, box: i="content-box"} = r
      , s = Se( () => {
        var p, h;
        return (h = (p = Ss(e)) == null ? void 0 : p.namespaceURI) == null ? void 0 : h.includes("svg")
    }
    )
      , o = Ue(t.width)
      , a = Ue(t.height)
      , {stop: u} = aT(e, ([p]) => {
        const h = i === "border-box" ? p.borderBoxSize : i === "content-box" ? p.contentBoxSize : p.devicePixelContentBoxSize;
        if (n && s.value) {
            const g = Ss(e);
            if (g) {
                const S = n.getComputedStyle(g);
                o.value = Number.parseFloat(S.width),
                a.value = Number.parseFloat(S.height)
            }
        } else if (h) {
            const g = Array.isArray(h) ? h : [h];
            o.value = g.reduce( (S, {inlineSize: x}) => S + x, 0),
            a.value = g.reduce( (S, {blockSize: x}) => S + x, 0)
        } else
            o.value = p.contentRect.width,
            a.value = p.contentRect.height
    }
    , r);
    tx( () => {
        const p = Ss(e);
        p && (o.value = "offsetWidth"in p ? p.offsetWidth : t.width,
        a.value = "offsetHeight"in p ? p.offsetHeight : t.height)
    }
    );
    const c = vt( () => Ss(e), p => {
        o.value = p ? t.width : 0,
        a.value = p ? t.height : 0
    }
    );
    function l() {
        u(),
        c()
    }
    return {
        width: o,
        height: a,
        stop: l
    }
}
function yF(e, t, r={}) {
    const {window: n=In} = r;
    return Ua(e, t, n == null ? void 0 : n.localStorage, r)
}
function bF(e={}, t={}) {
    const {navigator: r=JI} = t
      , n = r
      , i = Mg( () => n && "canShare"in n);
    return {
        isSupported: i,
        share: async (o={}) => {
            if (i.value) {
                const a = {
                    ...gn(e),
                    ...gn(o)
                };
                let u = !0;
                if (a.files && n.canShare && (u = n.canShare({
                    files: a.files
                })),
                u)
                    return n.share(a)
            }
        }
    }
}
function uT(e={}) {
    const {controls: t=!1, offset: r=0, immediate: n=!0, interval: i="requestAnimationFrame", callback: s} = e
      , o = Ue(Sy() + r)
      , a = () => o.value = Sy() + r
      , u = s ? () => {
        a(),
        s(o.value)
    }
    : a
      , c = i === "requestAnimationFrame" ? tT(u, {
        immediate: n
    }) : ZI(u, i, {
        immediate: n
    });
    return t ? {
        timestamp: o,
        ...c
    } : o
}
const cT = Symbol("nuxt-ui.slideover")
  , lT = _t(e => {
    const t = Pr({
        component: "div",
        props: {}
    });
    e.vueApp.provide(cT, t)
}
)
  , rx = Symbol("nuxt-ui.modal");
function fT() {
    const e = Kt(rx)
      , t = Ue(!1);
    function r(o, a) {
        if (!e)
            throw new Error("useModal() is called without provider");
        e.value = {
            component: o,
            props: a ?? {}
        },
        t.value = !0
    }
    async function n() {
        e && (t.value = !1)
    }
    function i() {
        e.value = {
            component: "div",
            props: {}
        }
    }
    function s(o) {
        e && (e.value = {
            ...e.value,
            props: {
                ...e.value.props,
                ...o
            }
        })
    }
    return {
        open: r,
        close: n,
        reset: i,
        patch: s,
        isOpen: t
    }
}
const wF = FI(fT)
  , dT = _t(e => {
    const t = Pr({
        component: "div",
        props: {}
    });
    e.vueApp.provide(rx, t)
}
)
  , Ig = "-";
function hT(e) {
    const t = gT(e)
      , {conflictingClassGroups: r, conflictingClassGroupModifiers: n} = e;
    function i(o) {
        const a = o.split(Ig);
        return a[0] === "" && a.length !== 1 && a.shift(),
        nx(a, t) || pT(o)
    }
    function s(o, a) {
        const u = r[o] || [];
        return a && n[o] ? [...u, ...n[o]] : u
    }
    return {
        getClassGroupId: i,
        getConflictingClassGroupIds: s
    }
}
function nx(e, t) {
    var o;
    if (e.length === 0)
        return t.classGroupId;
    const r = e[0]
      , n = t.nextPart.get(r)
      , i = n ? nx(e.slice(1), n) : void 0;
    if (i)
        return i;
    if (t.validators.length === 0)
        return;
    const s = e.join(Ig);
    return (o = t.validators.find( ({validator: a}) => a(s))) == null ? void 0 : o.classGroupId
}
const Ay = /^\[(.+)\]$/;
function pT(e) {
    if (Ay.test(e)) {
        const t = Ay.exec(e)[1]
          , r = t == null ? void 0 : t.substring(0, t.indexOf(":"));
        if (r)
            return "arbitrary.." + r
    }
}
function gT(e) {
    const {theme: t, prefix: r} = e
      , n = {
        nextPart: new Map,
        validators: []
    };
    return yT(Object.entries(e.classGroups), r).forEach( ([s,o]) => {
        Bh(o, n, s, t)
    }
    ),
    n
}
function Bh(e, t, r, n) {
    e.forEach(i => {
        if (typeof i == "string") {
            const s = i === "" ? t : My(t, i);
            s.classGroupId = r;
            return
        }
        if (typeof i == "function") {
            if (mT(i)) {
                Bh(i(n), t, r, n);
                return
            }
            t.validators.push({
                validator: i,
                classGroupId: r
            });
            return
        }
        Object.entries(i).forEach( ([s,o]) => {
            Bh(o, My(t, s), r, n)
        }
        )
    }
    )
}
function My(e, t) {
    let r = e;
    return t.split(Ig).forEach(n => {
        r.nextPart.has(n) || r.nextPart.set(n, {
            nextPart: new Map,
            validators: []
        }),
        r = r.nextPart.get(n)
    }
    ),
    r
}
function mT(e) {
    return e.isThemeGetter
}
function yT(e, t) {
    return t ? e.map( ([r,n]) => {
        const i = n.map(s => typeof s == "string" ? t + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map( ([o,a]) => [t + o, a])) : s);
        return [r, i]
    }
    ) : e
}
function bT(e) {
    if (e < 1)
        return {
            get: () => {}
            ,
            set: () => {}
        };
    let t = 0
      , r = new Map
      , n = new Map;
    function i(s, o) {
        r.set(s, o),
        t++,
        t > e && (t = 0,
        n = r,
        r = new Map)
    }
    return {
        get(s) {
            let o = r.get(s);
            if (o !== void 0)
                return o;
            if ((o = n.get(s)) !== void 0)
                return i(s, o),
                o
        },
        set(s, o) {
            r.has(s) ? r.set(s, o) : i(s, o)
        }
    }
}
const ix = "!";
function wT(e) {
    const t = e.separator
      , r = t.length === 1
      , n = t[0]
      , i = t.length;
    return function(o) {
        const a = [];
        let u = 0, c = 0, l;
        for (let x = 0; x < o.length; x++) {
            let v = o[x];
            if (u === 0) {
                if (v === n && (r || o.slice(x, x + i) === t)) {
                    a.push(o.slice(c, x)),
                    c = x + i;
                    continue
                }
                if (v === "/") {
                    l = x;
                    continue
                }
            }
            v === "[" ? u++ : v === "]" && u--
        }
        const p = a.length === 0 ? o : o.substring(c)
          , h = p.startsWith(ix)
          , g = h ? p.substring(1) : p
          , S = l && l > c ? l - c : void 0;
        return {
            modifiers: a,
            hasImportantModifier: h,
            baseClassName: g,
            maybePostfixModifierPosition: S
        }
    }
}
function vT(e) {
    if (e.length <= 1)
        return e;
    const t = [];
    let r = [];
    return e.forEach(n => {
        n[0] === "[" ? (t.push(...r.sort(), n),
        r = []) : r.push(n)
    }
    ),
    t.push(...r.sort()),
    t
}
function xT(e) {
    return {
        cache: bT(e.cacheSize),
        splitModifiers: wT(e),
        ...hT(e)
    }
}
const ET = /\s+/;
function ST(e, t) {
    const {splitModifiers: r, getClassGroupId: n, getConflictingClassGroupIds: i} = t
      , s = new Set;
    return e.trim().split(ET).map(o => {
        const {modifiers: a, hasImportantModifier: u, baseClassName: c, maybePostfixModifierPosition: l} = r(o);
        let p = n(l ? c.substring(0, l) : c)
          , h = !!l;
        if (!p) {
            if (!l)
                return {
                    isTailwindClass: !1,
                    originalClassName: o
                };
            if (p = n(c),
            !p)
                return {
                    isTailwindClass: !1,
                    originalClassName: o
                };
            h = !1
        }
        const g = vT(a).join(":");
        return {
            isTailwindClass: !0,
            modifierId: u ? g + ix : g,
            classGroupId: p,
            originalClassName: o,
            hasPostfixModifier: h
        }
    }
    ).reverse().filter(o => {
        if (!o.isTailwindClass)
            return !0;
        const {modifierId: a, classGroupId: u, hasPostfixModifier: c} = o
          , l = a + u;
        return s.has(l) ? !1 : (s.add(l),
        i(u, c).forEach(p => s.add(a + p)),
        !0)
    }
    ).reverse().map(o => o.originalClassName).join(" ")
}
function ln() {
    let e = 0, t, r, n = "";
    for (; e < arguments.length; )
        (t = arguments[e++]) && (r = sx(t)) && (n && (n += " "),
        n += r);
    return n
}
function sx(e) {
    if (typeof e == "string")
        return e;
    let t, r = "";
    for (let n = 0; n < e.length; n++)
        e[n] && (t = sx(e[n])) && (r && (r += " "),
        r += t);
    return r
}
function Ph(e, ...t) {
    let r, n, i, s = o;
    function o(u) {
        const c = t.reduce( (l, p) => p(l), e());
        return r = xT(c),
        n = r.cache.get,
        i = r.cache.set,
        s = a,
        a(u)
    }
    function a(u) {
        const c = n(u);
        if (c)
            return c;
        const l = ST(u, r);
        return i(u, l),
        l
    }
    return function() {
        return s(ln.apply(null, arguments))
    }
}
function dt(e) {
    const t = r => r[e] || [];
    return t.isThemeGetter = !0,
    t
}
const ox = /^\[(?:([a-z-]+):)?(.+)\]$/i
  , _T = /^\d+\/\d+$/
  , AT = new Set(["px", "full", "screen"])
  , MT = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
  , IT = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
  , TT = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/
  , CT = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
  , kT = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function Xn(e) {
    return As(e) || AT.has(e) || _T.test(e)
}
function Ii(e) {
    return ha(e, "length", DT)
}
function As(e) {
    return !!e && !Number.isNaN(Number(e))
}
function Nc(e) {
    return ha(e, "number", As)
}
function Ma(e) {
    return !!e && Number.isInteger(Number(e))
}
function LT(e) {
    return e.endsWith("%") && As(e.slice(0, -1))
}
function ze(e) {
    return ox.test(e)
}
function Ti(e) {
    return MT.test(e)
}
const OT = new Set(["length", "size", "percentage"]);
function NT(e) {
    return ha(e, OT, ax)
}
function RT(e) {
    return ha(e, "position", ax)
}
const BT = new Set(["image", "url"]);
function PT(e) {
    return ha(e, BT, zT)
}
function jT(e) {
    return ha(e, "", UT)
}
function Ia() {
    return !0
}
function ha(e, t, r) {
    const n = ox.exec(e);
    return n ? n[1] ? typeof t == "string" ? n[1] === t : t.has(n[1]) : r(n[2]) : !1
}
function DT(e) {
    return IT.test(e) && !TT.test(e)
}
function ax() {
    return !1
}
function UT(e) {
    return CT.test(e)
}
function zT(e) {
    return kT.test(e)
}
function jh() {
    const e = dt("colors")
      , t = dt("spacing")
      , r = dt("blur")
      , n = dt("brightness")
      , i = dt("borderColor")
      , s = dt("borderRadius")
      , o = dt("borderSpacing")
      , a = dt("borderWidth")
      , u = dt("contrast")
      , c = dt("grayscale")
      , l = dt("hueRotate")
      , p = dt("invert")
      , h = dt("gap")
      , g = dt("gradientColorStops")
      , S = dt("gradientColorStopPositions")
      , x = dt("inset")
      , v = dt("margin")
      , I = dt("opacity")
      , M = dt("padding")
      , A = dt("saturate")
      , k = dt("scale")
      , L = dt("sepia")
      , O = dt("skew")
      , $ = dt("space")
      , D = dt("translate")
      , K = () => ["auto", "contain", "none"]
      , G = () => ["auto", "hidden", "clip", "visible", "scroll"]
      , F = () => ["auto", ze, t]
      , q = () => [ze, t]
      , B = () => ["", Xn, Ii]
      , y = () => ["auto", As, ze]
      , b = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"]
      , _ = () => ["solid", "dashed", "dotted", "double", "none"]
      , T = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
      , C = () => ["start", "end", "center", "between", "around", "evenly", "stretch"]
      , P = () => ["", "0", ze]
      , W = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
      , N = () => [As, Nc]
      , w = () => [As, ze];
    return {
        cacheSize: 500,
        separator: ":",
        theme: {
            colors: [Ia],
            spacing: [Xn, Ii],
            blur: ["none", "", Ti, ze],
            brightness: N(),
            borderColor: [e],
            borderRadius: ["none", "", "full", Ti, ze],
            borderSpacing: q(),
            borderWidth: B(),
            contrast: N(),
            grayscale: P(),
            hueRotate: w(),
            invert: P(),
            gap: q(),
            gradientColorStops: [e],
            gradientColorStopPositions: [LT, Ii],
            inset: F(),
            margin: F(),
            opacity: N(),
            padding: q(),
            saturate: N(),
            scale: N(),
            sepia: P(),
            skew: w(),
            space: q(),
            translate: q()
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", "video", ze]
            }],
            container: ["container"],
            columns: [{
                columns: [Ti]
            }],
            "break-after": [{
                "break-after": W()
            }],
            "break-before": [{
                "break-before": W()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: [...b(), ze]
            }],
            overflow: [{
                overflow: G()
            }],
            "overflow-x": [{
                "overflow-x": G()
            }],
            "overflow-y": [{
                "overflow-y": G()
            }],
            overscroll: [{
                overscroll: K()
            }],
            "overscroll-x": [{
                "overscroll-x": K()
            }],
            "overscroll-y": [{
                "overscroll-y": K()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: [x]
            }],
            "inset-x": [{
                "inset-x": [x]
            }],
            "inset-y": [{
                "inset-y": [x]
            }],
            start: [{
                start: [x]
            }],
            end: [{
                end: [x]
            }],
            top: [{
                top: [x]
            }],
            right: [{
                right: [x]
            }],
            bottom: [{
                bottom: [x]
            }],
            left: [{
                left: [x]
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: ["auto", Ma, ze]
            }],
            basis: [{
                basis: F()
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["wrap", "wrap-reverse", "nowrap"]
            }],
            flex: [{
                flex: ["1", "auto", "initial", "none", ze]
            }],
            grow: [{
                grow: P()
            }],
            shrink: [{
                shrink: P()
            }],
            order: [{
                order: ["first", "last", "none", Ma, ze]
            }],
            "grid-cols": [{
                "grid-cols": [Ia]
            }],
            "col-start-end": [{
                col: ["auto", {
                    span: ["full", Ma, ze]
                }, ze]
            }],
            "col-start": [{
                "col-start": y()
            }],
            "col-end": [{
                "col-end": y()
            }],
            "grid-rows": [{
                "grid-rows": [Ia]
            }],
            "row-start-end": [{
                row: ["auto", {
                    span: [Ma, ze]
                }, ze]
            }],
            "row-start": [{
                "row-start": y()
            }],
            "row-end": [{
                "row-end": y()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": ["auto", "min", "max", "fr", ze]
            }],
            "auto-rows": [{
                "auto-rows": ["auto", "min", "max", "fr", ze]
            }],
            gap: [{
                gap: [h]
            }],
            "gap-x": [{
                "gap-x": [h]
            }],
            "gap-y": [{
                "gap-y": [h]
            }],
            "justify-content": [{
                justify: ["normal", ...C()]
            }],
            "justify-items": [{
                "justify-items": ["start", "end", "center", "stretch"]
            }],
            "justify-self": [{
                "justify-self": ["auto", "start", "end", "center", "stretch"]
            }],
            "align-content": [{
                content: ["normal", ...C(), "baseline"]
            }],
            "align-items": [{
                items: ["start", "end", "center", "baseline", "stretch"]
            }],
            "align-self": [{
                self: ["auto", "start", "end", "center", "stretch", "baseline"]
            }],
            "place-content": [{
                "place-content": [...C(), "baseline"]
            }],
            "place-items": [{
                "place-items": ["start", "end", "center", "baseline", "stretch"]
            }],
            "place-self": [{
                "place-self": ["auto", "start", "end", "center", "stretch"]
            }],
            p: [{
                p: [M]
            }],
            px: [{
                px: [M]
            }],
            py: [{
                py: [M]
            }],
            ps: [{
                ps: [M]
            }],
            pe: [{
                pe: [M]
            }],
            pt: [{
                pt: [M]
            }],
            pr: [{
                pr: [M]
            }],
            pb: [{
                pb: [M]
            }],
            pl: [{
                pl: [M]
            }],
            m: [{
                m: [v]
            }],
            mx: [{
                mx: [v]
            }],
            my: [{
                my: [v]
            }],
            ms: [{
                ms: [v]
            }],
            me: [{
                me: [v]
            }],
            mt: [{
                mt: [v]
            }],
            mr: [{
                mr: [v]
            }],
            mb: [{
                mb: [v]
            }],
            ml: [{
                ml: [v]
            }],
            "space-x": [{
                "space-x": [$]
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": [$]
            }],
            "space-y-reverse": ["space-y-reverse"],
            w: [{
                w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ze, t]
            }],
            "min-w": [{
                "min-w": [ze, t, "min", "max", "fit"]
            }],
            "max-w": [{
                "max-w": [ze, t, "none", "full", "min", "max", "fit", "prose", {
                    screen: [Ti]
                }, Ti]
            }],
            h: [{
                h: [ze, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            "min-h": [{
                "min-h": [ze, t, "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            "max-h": [{
                "max-h": [ze, t, "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            size: [{
                size: [ze, t, "auto", "min", "max", "fit"]
            }],
            "font-size": [{
                text: ["base", Ti, Ii]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Nc]
            }],
            "font-family": [{
                font: [Ia]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
            tracking: [{
                tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ze]
            }],
            "line-clamp": [{
                "line-clamp": ["none", As, Nc]
            }],
            leading: [{
                leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Xn, ze]
            }],
            "list-image": [{
                "list-image": ["none", ze]
            }],
            "list-style-type": [{
                list: ["none", "disc", "decimal", ze]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "placeholder-color": [{
                placeholder: [e]
            }],
            "placeholder-opacity": [{
                "placeholder-opacity": [I]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "text-color": [{
                text: [e]
            }],
            "text-opacity": [{
                "text-opacity": [I]
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [..._(), "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: ["auto", "from-font", Xn, Ii]
            }],
            "underline-offset": [{
                "underline-offset": ["auto", Xn, ze]
            }],
            "text-decoration-color": [{
                decoration: [e]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: q()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ze]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", ze]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-opacity": [{
                "bg-opacity": [I]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: [...b(), RT]
            }],
            "bg-repeat": [{
                bg: ["no-repeat", {
                    repeat: ["", "x", "y", "round", "space"]
                }]
            }],
            "bg-size": [{
                bg: ["auto", "cover", "contain", NT]
            }],
            "bg-image": [{
                bg: ["none", {
                    "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                }, PT]
            }],
            "bg-color": [{
                bg: [e]
            }],
            "gradient-from-pos": [{
                from: [S]
            }],
            "gradient-via-pos": [{
                via: [S]
            }],
            "gradient-to-pos": [{
                to: [S]
            }],
            "gradient-from": [{
                from: [g]
            }],
            "gradient-via": [{
                via: [g]
            }],
            "gradient-to": [{
                to: [g]
            }],
            rounded: [{
                rounded: [s]
            }],
            "rounded-s": [{
                "rounded-s": [s]
            }],
            "rounded-e": [{
                "rounded-e": [s]
            }],
            "rounded-t": [{
                "rounded-t": [s]
            }],
            "rounded-r": [{
                "rounded-r": [s]
            }],
            "rounded-b": [{
                "rounded-b": [s]
            }],
            "rounded-l": [{
                "rounded-l": [s]
            }],
            "rounded-ss": [{
                "rounded-ss": [s]
            }],
            "rounded-se": [{
                "rounded-se": [s]
            }],
            "rounded-ee": [{
                "rounded-ee": [s]
            }],
            "rounded-es": [{
                "rounded-es": [s]
            }],
            "rounded-tl": [{
                "rounded-tl": [s]
            }],
            "rounded-tr": [{
                "rounded-tr": [s]
            }],
            "rounded-br": [{
                "rounded-br": [s]
            }],
            "rounded-bl": [{
                "rounded-bl": [s]
            }],
            "border-w": [{
                border: [a]
            }],
            "border-w-x": [{
                "border-x": [a]
            }],
            "border-w-y": [{
                "border-y": [a]
            }],
            "border-w-s": [{
                "border-s": [a]
            }],
            "border-w-e": [{
                "border-e": [a]
            }],
            "border-w-t": [{
                "border-t": [a]
            }],
            "border-w-r": [{
                "border-r": [a]
            }],
            "border-w-b": [{
                "border-b": [a]
            }],
            "border-w-l": [{
                "border-l": [a]
            }],
            "border-opacity": [{
                "border-opacity": [I]
            }],
            "border-style": [{
                border: [..._(), "hidden"]
            }],
            "divide-x": [{
                "divide-x": [a]
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": [a]
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "divide-opacity": [{
                "divide-opacity": [I]
            }],
            "divide-style": [{
                divide: _()
            }],
            "border-color": [{
                border: [i]
            }],
            "border-color-x": [{
                "border-x": [i]
            }],
            "border-color-y": [{
                "border-y": [i]
            }],
            "border-color-t": [{
                "border-t": [i]
            }],
            "border-color-r": [{
                "border-r": [i]
            }],
            "border-color-b": [{
                "border-b": [i]
            }],
            "border-color-l": [{
                "border-l": [i]
            }],
            "divide-color": [{
                divide: [i]
            }],
            "outline-style": [{
                outline: ["", ..._()]
            }],
            "outline-offset": [{
                "outline-offset": [Xn, ze]
            }],
            "outline-w": [{
                outline: [Xn, Ii]
            }],
            "outline-color": [{
                outline: [e]
            }],
            "ring-w": [{
                ring: B()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: [e]
            }],
            "ring-opacity": [{
                "ring-opacity": [I]
            }],
            "ring-offset-w": [{
                "ring-offset": [Xn, Ii]
            }],
            "ring-offset-color": [{
                "ring-offset": [e]
            }],
            shadow: [{
                shadow: ["", "inner", "none", Ti, jT]
            }],
            "shadow-color": [{
                shadow: [Ia]
            }],
            opacity: [{
                opacity: [I]
            }],
            "mix-blend": [{
                "mix-blend": [...T(), "plus-lighter", "plus-darker"]
            }],
            "bg-blend": [{
                "bg-blend": T()
            }],
            filter: [{
                filter: ["", "none"]
            }],
            blur: [{
                blur: [r]
            }],
            brightness: [{
                brightness: [n]
            }],
            contrast: [{
                contrast: [u]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", Ti, ze]
            }],
            grayscale: [{
                grayscale: [c]
            }],
            "hue-rotate": [{
                "hue-rotate": [l]
            }],
            invert: [{
                invert: [p]
            }],
            saturate: [{
                saturate: [A]
            }],
            sepia: [{
                sepia: [L]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none"]
            }],
            "backdrop-blur": [{
                "backdrop-blur": [r]
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [n]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [u]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": [c]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [l]
            }],
            "backdrop-invert": [{
                "backdrop-invert": [p]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [I]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [A]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": [L]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": [o]
            }],
            "border-spacing-x": [{
                "border-spacing-x": [o]
            }],
            "border-spacing-y": [{
                "border-spacing-y": [o]
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ze]
            }],
            duration: [{
                duration: w()
            }],
            ease: [{
                ease: ["linear", "in", "out", "in-out", ze]
            }],
            delay: [{
                delay: w()
            }],
            animate: [{
                animate: ["none", "spin", "ping", "pulse", "bounce", ze]
            }],
            transform: [{
                transform: ["", "gpu", "none"]
            }],
            scale: [{
                scale: [k]
            }],
            "scale-x": [{
                "scale-x": [k]
            }],
            "scale-y": [{
                "scale-y": [k]
            }],
            rotate: [{
                rotate: [Ma, ze]
            }],
            "translate-x": [{
                "translate-x": [D]
            }],
            "translate-y": [{
                "translate-y": [D]
            }],
            "skew-x": [{
                "skew-x": [O]
            }],
            "skew-y": [{
                "skew-y": [O]
            }],
            "transform-origin": [{
                origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ze]
            }],
            accent: [{
                accent: ["auto", e]
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ze]
            }],
            "caret-color": [{
                caret: [e]
            }],
            "pointer-events": [{
                "pointer-events": ["none", "auto"]
            }],
            resize: [{
                resize: ["none", "y", "x", ""]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": q()
            }],
            "scroll-mx": [{
                "scroll-mx": q()
            }],
            "scroll-my": [{
                "scroll-my": q()
            }],
            "scroll-ms": [{
                "scroll-ms": q()
            }],
            "scroll-me": [{
                "scroll-me": q()
            }],
            "scroll-mt": [{
                "scroll-mt": q()
            }],
            "scroll-mr": [{
                "scroll-mr": q()
            }],
            "scroll-mb": [{
                "scroll-mb": q()
            }],
            "scroll-ml": [{
                "scroll-ml": q()
            }],
            "scroll-p": [{
                "scroll-p": q()
            }],
            "scroll-px": [{
                "scroll-px": q()
            }],
            "scroll-py": [{
                "scroll-py": q()
            }],
            "scroll-ps": [{
                "scroll-ps": q()
            }],
            "scroll-pe": [{
                "scroll-pe": q()
            }],
            "scroll-pt": [{
                "scroll-pt": q()
            }],
            "scroll-pr": [{
                "scroll-pr": q()
            }],
            "scroll-pb": [{
                "scroll-pb": q()
            }],
            "scroll-pl": [{
                "scroll-pl": q()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", ze]
            }],
            fill: [{
                fill: [e, "none"]
            }],
            "stroke-w": [{
                stroke: [Xn, Ii, Nc]
            }],
            stroke: [{
                stroke: [e, "none"]
            }],
            sr: ["sr-only", "not-sr-only"],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        }
    }
}
function $T(e, {cacheSize: t, prefix: r, separator: n, extend: i={}, override: s={}}) {
    dl(e, "cacheSize", t),
    dl(e, "prefix", r),
    dl(e, "separator", n);
    for (const o in s)
        FT(e[o], s[o]);
    for (const o in i)
        HT(e[o], i[o]);
    return e
}
function dl(e, t, r) {
    r !== void 0 && (e[t] = r)
}
function FT(e, t) {
    if (t)
        for (const r in t)
            dl(e, r, t[r])
}
function HT(e, t) {
    if (t)
        for (const r in t) {
            const n = t[r];
            n !== void 0 && (e[r] = (e[r] || []).concat(n))
        }
}
function qT(e, ...t) {
    return typeof e == "function" ? Ph(jh, e, ...t) : Ph( () => $T(jh(), e), ...t)
}
const Ho = Ph(jh);
function WT(e, t) {
    const r = {
        ...e
    };
    for (const n of t)
        delete r[n];
    return r
}
function VT(e, t, r) {
    typeof t == "string" && (t = t.split(".").map(i => {
        const s = Number(i);
        return isNaN(s) ? i : s
    }
    ));
    let n = e;
    for (const i of t) {
        if (n == null)
            return r;
        n = n[i]
    }
    return n !== void 0 ? n : r
}
const Tg = {
    to: {
        type: [String, Object],
        default: void 0,
        required: !1
    },
    href: {
        type: [String, Object],
        default: void 0,
        required: !1
    },
    target: {
        type: String,
        default: void 0,
        required: !1
    },
    rel: {
        type: String,
        default: void 0,
        required: !1
    },
    noRel: {
        type: Boolean,
        default: void 0,
        required: !1
    },
    prefetch: {
        type: Boolean,
        default: void 0,
        required: !1
    },
    noPrefetch: {
        type: Boolean,
        default: void 0,
        required: !1
    },
    activeClass: {
        type: String,
        default: void 0,
        required: !1
    },
    exactActiveClass: {
        type: String,
        default: void 0,
        required: !1
    },
    prefetchedClass: {
        type: String,
        default: void 0,
        required: !1
    },
    replace: {
        type: Boolean,
        default: void 0,
        required: !1
    },
    ariaCurrentValue: {
        type: String,
        default: void 0,
        required: !1
    },
    external: {
        type: Boolean,
        default: void 0,
        required: !1
    }
}
  , KT = e => Object.keys(Tg).reduce( (r, n) => (e[n] !== void 0 && (r[n] = e[n]),
r), {})
  , GT = qT({
    extend: {
        classGroups: {
            icons: [e => /^i-/.test(e)]
        }
    }
})
  , QT = mg( (e, t, r, n) => {
    if (n === "default" || n.startsWith("default.") || n === "popper" || n.startsWith("popper.") || n.endsWith("avatar") && t === "size" || n.endsWith("chip") && t === "size" || n.endsWith("badge") && t === "size" || t === "color" || t === "variant")
        return !1;
    if (typeof e[t] == "string" && typeof r == "string" && e[t] && r)
        return e[t] = GT(e[t], r),
        !0
}
);
function nc(e, ...t) {
    return e === "override" ? yg({}, ...t) : QT({}, ...t)
}
function Iy(e) {
    const t = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    e = e.replace(t, function(n, i, s, o) {
        return i + i + s + s + o + o
    });
    const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
    return r ? `${parseInt(r[1], 16)} ${parseInt(r[2], 16)} ${parseInt(r[3], 16)}` : null
}
function vF(e) {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
}
const YT = "inherit"
  , ZT = "currentColor"
  , JT = "transparent"
  , XT = "#000"
  , eC = "#fff"
  , tC = {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
}
  , rC = {
    50: "rgb(var(--color-gray-50) / <alpha-value>)",
    100: "rgb(var(--color-gray-100) / <alpha-value>)",
    200: "rgb(var(--color-gray-200) / <alpha-value>)",
    300: "rgb(var(--color-gray-300) / <alpha-value>)",
    400: "rgb(var(--color-gray-400) / <alpha-value>)",
    500: "rgb(var(--color-gray-500) / <alpha-value>)",
    600: "rgb(var(--color-gray-600) / <alpha-value>)",
    700: "rgb(var(--color-gray-700) / <alpha-value>)",
    800: "rgb(var(--color-gray-800) / <alpha-value>)",
    900: "rgb(var(--color-gray-900) / <alpha-value>)",
    950: "rgb(var(--color-gray-950) / <alpha-value>)"
}
  , nC = {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
}
  , iC = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
}
  , sC = {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
}
  , oC = {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
}
  , aC = {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
}
  , uC = {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
}
  , cC = {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
}
  , lC = {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
}
  , fC = {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
}
  , dC = {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
}
  , hC = {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
}
  , pC = {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
}
  , gC = {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
}
  , mC = {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
}
  , yC = {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
}
  , bC = {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
}
  , wC = {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
}
  , vC = {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
}
  , xC = {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
}
  , EC = {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
}
  , SC = "rgb(var(--background) / <alpha-value>)"
  , _C = "rgb(var(--text) / <alpha-value>)"
  , AC = {
    50: "rgb(var(--color-primary-50) / <alpha-value>)",
    100: "rgb(var(--color-primary-100) / <alpha-value>)",
    200: "rgb(var(--color-primary-200) / <alpha-value>)",
    300: "rgb(var(--color-primary-300) / <alpha-value>)",
    400: "rgb(var(--color-primary-400) / <alpha-value>)",
    500: "rgb(var(--color-primary-500) / <alpha-value>)",
    600: "rgb(var(--color-primary-600) / <alpha-value>)",
    700: "rgb(var(--color-primary-700) / <alpha-value>)",
    800: "rgb(var(--color-primary-800) / <alpha-value>)",
    900: "rgb(var(--color-primary-900) / <alpha-value>)",
    950: "rgb(var(--color-primary-950) / <alpha-value>)",
    DEFAULT: "rgb(var(--color-primary-DEFAULT) / <alpha-value>)"
}
  , MC = "rgb(var(--secondary) / <alpha-value>)"
  , IC = "#FFF500"
  , TC = "rgb(var(--warning) / <alpha-value>)"
  , CC = "rgb(var(--success) / <alpha-value>)"
  , kC = "rgb(var(--container) / <alpha-value>)"
  , LC = "rgb(var(--modal) / <alpha-value>)"
  , OC = "#F2F2F2"
  , NC = {
    50: "#e8efff",
    100: "#d5e1ff",
    200: "#b3c6ff",
    300: "#859fff",
    400: "#5668ff",
    500: "#2f34ff",
    600: "#1d0cff",
    700: "#1400ff",
    800: "#1200e7",
    900: "#1306cd",
    950: "#0e00b1"
}
  , RC = {
    50: "#fcffe7",
    100: "#f6ffc1",
    200: "#f2ff86",
    300: "#f3ff41",
    400: "#fcff0d",
    500: "#fff500",
    600: "#d1b700",
    700: "#a68402",
    800: "#89670a",
    900: "#74540f",
    950: "#442d04"
}
  , BC = {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
}
  , Rc = {
    inherit: YT,
    current: ZT,
    transparent: JT,
    black: XT,
    white: eC,
    slate: tC,
    gray: rC,
    zinc: nC,
    neutral: iC,
    stone: sC,
    red: oC,
    orange: aC,
    amber: uC,
    yellow: cC,
    lime: lC,
    green: fC,
    emerald: dC,
    teal: hC,
    cyan: pC,
    sky: gC,
    blue: mC,
    indigo: yC,
    violet: bC,
    purple: wC,
    fuchsia: vC,
    pink: xC,
    rose: EC,
    background: SC,
    text: _C,
    primary: AC,
    secondary: MC,
    accent: IC,
    warning: TC,
    success: CC,
    container: kC,
    modal: LC,
    lightgray: OC,
    mog: NC,
    gom: RC,
    cool: BC
}
  , PC = _t( () => {
    const e = fa()
      , t = ut()
      , r = Se( () => {
        const i = Rc[e.ui.primary]
          , s = Rc[e.ui.gray];
        return i || console.warn(`[@nuxt/ui] Primary color '${e.ui.primary}' not found in Tailwind config`),
        s || console.warn(`[@nuxt/ui] Gray color '${e.ui.gray}' not found in Tailwind config`),
        `:root {
${Object.entries(i || Rc.green).map( ([o,a]) => `--color-primary-${o}: ${Iy(a)};`).join(`
`)}
--color-primary-DEFAULT: var(--color-primary-500);

${Object.entries(s || Rc.cool).map( ([o,a]) => `--color-gray-${o}: ${Iy(a)};`).join(`
`)}
}

.dark {
  --color-primary-DEFAULT: var(--color-primary-400);
}
`
    }
    )
      , n = {
        style: [{
            innerHTML: () => r.value,
            tagPriority: -2,
            id: "nuxt-ui-colors"
        }]
    };
    if (t.isHydrating && !t.payload.serverRendered) {
        const i = document.createElement("style");
        i.innerHTML = r.value,
        i.setAttribute("data-nuxt-ui-colors", ""),
        document.head.appendChild(i),
        n.script = [{
            innerHTML: "document.head.removeChild(document.querySelector('[data-nuxt-ui-colors]'))"
        }]
    }
    Hf(n)
}
)
  , jC = "__NUXT_COLOR_MODE__"
  , DC = "nuxt-color-mode"
  , ei = window[jC] || {}
  , UC = _t(e => {
    const t = da("color-mode", () => Vn({
        preference: ei.preference,
        value: ei.value,
        unknown: !1,
        forced: !1
    })).value;
    Ur().afterEach(i => {
        const s = i.meta.colorMode;
        s && s !== "system" ? (t.value = s,
        t.forced = !0) : (s === "system" && console.warn("You cannot force the colorMode to system at the page level."),
        t.forced = !1,
        t.value = t.preference === "system" ? ei.getColorScheme() : t.preference)
    }
    );
    let r;
    function n() {
        r || !window.matchMedia || (r = window.matchMedia("(prefers-color-scheme: dark)"),
        r.addEventListener("change", () => {
            !t.forced && t.preference === "system" && (t.value = ei.getColorScheme())
        }
        ))
    }
    vt( () => t.preference, i => {
        var s;
        t.forced || (i === "system" ? (t.value = ei.getColorScheme(),
        n()) : t.value = i,
        (s = window.localStorage) == null || s.setItem(DC, i))
    }
    , {
        immediate: !0
    }),
    vt( () => t.value, (i, s) => {
        ei.removeColorScheme(s),
        ei.addColorScheme(i)
    }
    ),
    t.preference === "system" && n(),
    e.hook("app:mounted", () => {
        t.unknown && (t.preference = ei.preference,
        t.value = ei.value,
        t.unknown = !1)
    }
    ),
    e.provide("colorMode", t)
}
)
  , zC = _t(e => {
    if (!document.startViewTransition)
        return;
    let t, r;
    Ur().beforeResolve(async (i, s) => {
        const o = i.meta.viewTransition ?? oA
          , u = window.matchMedia("(prefers-reduced-motion: reduce)").matches && o !== "always";
        if (o === !1 || u || !H2(i, s))
            return;
        const c = new Promise( (g, S) => {
            t = g,
            r = S
        }
        );
        let l;
        const p = new Promise(g => l = g)
          , h = document.startViewTransition( () => (l(),
        c));
        return h.finished.then( () => {
            r = void 0,
            t = void 0
        }
        ),
        await e.callHook("page:view-transition:start", h),
        p
    }
    ),
    e.hook("vue:error", () => {
        r == null || r(),
        r = void 0
    }
    ),
    e.hook("page:finish", () => {
        t == null || t(),
        t = void 0
    }
    )
}
)
  , $C = _t({
    name: "nuxt:chunk-reload",
    setup(e) {
        const t = Ur()
          , r = os()
          , n = new Set;
        t.beforeEach( () => {
            n.clear()
        }
        ),
        e.hook("app:chunkError", ({error: s}) => {
            n.add(s)
        }
        );
        function i(s) {
            const a = "href"in s && s.href[0] === "#" ? r.app.baseURL + s.href : zf(r.app.baseURL, s.fullPath);
            VM({
                path: a,
                persistState: !0
            })
        }
        e.hook("app:manifest:update", () => {
            t.beforeResolve(i)
        }
        ),
        t.onError( (s, o) => {
            n.has(s) && i(o)
        }
        )
    }
})
  , Ty = function() {
    return parseInt(Date.now() / 1e3)
}
  , xF = function(e) {
    return parseInt(e) == 0 || parseFloat(e) > 1 ? "s" : ""
};
function EF(e) {
    return "#" + e.match(/\d+/g).map(Number).map( (n, i) => n.toString(16).padStart(2, "0")).join("")
}
function SF() {
    let e = !1;
    try {
        return function(t) {
            (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0)
        }(navigator.userAgent || navigator.vendor || window.opera),
        e
    } catch {
        return e
    }
}
function _F() {
    try {
        return window.matchMedia("(pointer: coarse)").matches
    } catch {
        return !1
    }
}
function AF(e) {
    return new Promise( (t, r) => {
        let n = 0;
        e.forEach( (i, s) => {
            const o = new Image;
            o.src = i,
            o.onload = () => {
                n++,
                n === e.length && t(!0)
            }
            ,
            o.onerror = () => {
                n++
            }
        }
        )
    }
    )
}
const FC = WM("errorlogs", {
    hydrate(e, t) {
        e.uuid = Ua("errorlogs:uuid", null),
        e.logs = Ua("errorlogs:logs", [])
    },
    state: () => ({
        uuid: Ua("errorlogs:uuid", null),
        logs: Ua("errorlogs:logs", [])
    }),
    getters: {
        getSavedErrors: e => e.logs,
        getSortedSavedErrors: e => [...e.logs ?? []].reverse(),
        getOutputSavedErrors(e) {
            try {
                return JSON.stringify(this.getSortedSavedErrors).replace(/\\/g, "")
            } catch {
                return "No errors"
            }
        }
    },
    actions: {
        initUserSessionId() {
            try {
                this.cleanupSavedErrors()
            } catch {}
            try {
                if (this.uuid)
                    return;
                this.uuid = self.crypto.randomUUID()
            } catch {
                this.uuid = ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, t => (t ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t / 4).toString(16))
            }
        },
        async saveError({error: e}) {
            try {
                e.timestamp = Ty(),
                e.info = {
                    name: e == null ? void 0 : e.name,
                    message: e == null ? void 0 : e.message,
                    cause: e == null ? void 0 : e.cause
                },
                Array.isArray(this.logs) || (this.logs = []),
                this.logs.push(e)
            } catch (t) {
                console.debug(t)
            }
        },
        async cleanupSavedErrors({}={}) {
            try {
                const t = (this.getSavedErrors ?? []).filter(r => ((r == null ? void 0 : r.timestamp) ?? 0) > Ty() - 60 * 60 * 24 * 3);
                this.logs = t
            } catch (e) {
                console.debug(e)
            }
        }
    }
});
function HC(e) {
    window[`ga-disable-${e}`] = !0
}
function qC(e) {
    const t = `ga-disable-${e}`;
    t in window && delete window[t]
}
function ux() {
    const e = os().public.gtag
      , t = Z2(e);
    let r;
    r = fl;
    const n = a => {
        const u = [...t];
        let c = u.find(l => l.id === a);
        return c || (a ? (c = {
            id: a
        },
        u.unshift(c)) : c = u[0]),
        c || console.error("[nuxt-gtag] Missing Google tag ID"),
        {
            tag: c,
            tags: u
        }
    }
      , i = a => {
        {
            const {tag: u, tags: c} = n(a);
            if (!u)
                return;
            window.dataLayer || Y2({
                tags: c
            }),
            document.head.querySelector("script[data-gtag]") || Hf({
                script: [{
                    src: Uf(e.url, {
                        id: u.id
                    }),
                    "data-gtag": ""
                }]
            })
        }
    }
    ;
    function s(a) {
        {
            const {tag: u} = n(a);
            u && HC(u.id)
        }
    }
    function o(a) {
        {
            const {tag: u} = n(a);
            u && qC(u.id)
        }
    }
    return {
        gtag: r,
        initialize: i,
        disableAnalytics: s,
        enableAnalytics: o
    }
}
function Bc(...e) {
    const {gtag: t} = ux();
    t("event", ...e)
}
const WC = ({is_test: e}={}) => (ux(),
Object.freeze({
    walletConnected(t) {
        try {
            Bc("wallet_connected", {
                type: (t == null ? void 0 : t.network) || "evm",
                wallet: t == null ? void 0 : t.name
            })
        } catch (r) {
            console.log(r)
        }
    },
    nftMogged(t) {
        var r;
        try {
            Bc("nft_mogged", {
                collection: ((r = t == null ? void 0 : t.collection) == null ? void 0 : r.name) || (t == null ? void 0 : t.collectionName)
            })
        } catch (n) {
            console.log(n)
        }
    },
    pictureMogged() {
        try {
            Bc("image_mogged", {})
        } catch (t) {
            console.log(t)
        }
    },
    logError(t) {
        try {
            Bc("error", {
                message: t == null ? void 0 : t.message
            })
        } catch (r) {
            console.log(r)
        }
    }
}))
  , VC = _t(e => {
    e.vueApp.config.errorHandler = (t, r) => {
        FC().saveError({
            error: t
        }),
        WC().logError(t)
    }
}
)
  , KC = () => os().public.ENVIRONMENT == "development"
  , GC = "5.2.0"
  , QC = _t(e => {
    e.hook("app:mounted", () => {
        Hf({
            script: [{
                src: `/scripts/fabric/base_${GC}.${KC() ? "dev" : "min"}.js`
            }]
        })
    }
    )
}
)
  , Cg = {
    allowedTags: ["b", "i", "strong", "a"],
    allowedAttributes: {}
}
  , js = {
    URL: /\b(?:https?|ftp):\/\/[a-z0-9-+&@#\/%?=~_|!:,.;]*[a-z0-9-+&@#\/%=~_|]/gim,
    PSEUDO_URL: /^(https?:\/\/)?(www\.)?((?!\.)[\da-z.-]+)\.([a-z]{2,})(?:\.[a-z]{2,})?(\/[\w\-\/]*[^.\/?\n])?(\/)?([\/?][\w\-&=]*[^.\/?\n])?(#[\w.-]*)?$/gim,
    EMAIL_ADDRESS: /[\w.]+@[a-zA-Z_-]+?(?:\.[a-zA-Z]{2,6})+/gim,
    HANDLES: /@([\w!@#$%^&*()-_=+[\]{}|:;"'<>,.?/`~]+)/gim,
    URLTRIM: /^(https?:\/\/)?(www\.)?/
}
  , YC = {
    DEFAULT: "_blank"
}
  , ZC = {
    linkify: {
        className: "link-highlight"
    },
    sanitize: Cg
}
  , JC = {
    linkify: {
        className: "link-highlight"
    },
    sanitize: Cg
};
function XC(e="") {
    return [...Array.from(e.matchAll(js.HANDLES), t => t == null ? void 0 : t[0])].flatMap(t => t ?? [])
}
function ek(e="") {
    return [...e.matchAll(js.EMAIL_ADDRESS), ...Array.from(e.matchAll(js.PSEUDO_URL), t => t == null ? void 0 : t[0])].flatMap(t => t ?? [])
}
function tk(e) {
    if (ik(e)) {
        const t = sk(e == null ? void 0 : e.className)
          , r = Cy(e == null ? void 0 : e.target);
        return `${t} ${r}`
    }
    return Cy()
}
function rk(e, t, r) {
    return e = ok(e, t, r),
    e
}
function nk(e, t, r) {
    return t.match(js.EMAIL_ADDRESS) !== null && (e = ak(e, t, r)),
    (t.match(js.URL) !== null || t.match(js.PSEUDO_URL) !== null) && (e = uk(e, t, r)),
    e
}
function ik(e) {
    return e && typeof e == "object" && e !== null && !Array.isArray(e)
}
function sk(e) {
    return e ? `class="${e}"` : ""
}
function Cy(e) {
    return `target="${e || YC.DEFAULT}"`
}
function ok(e, t, r) {
    return e.replace(t, `<a ${r} href="${Da}/${t.replace("@", "")}">${t}</a>`)
}
function ak(e, t, r) {
    return e.replace(t, `<a target="_blank" ${r} href="mailto:${t}">${t}</a>`)
}
function uk(e, t, r) {
    const n = t.toLowerCase().indexOf("http") === -1 && t.toLowerCase().indexOf("ftp") === -1 ? "//" : "";
    return e.replace(t, `<a target="_blank" ${r} href="${n + t.trim()}">${t.replace(js.URLTRIM, "")}</a>`)
}
function ky(e, t) {
    return e && e.split(" ").map(r => {
        let n = ek(r) || []
          , i = XC(r) || [];
        const s = tk(t);
        return n.length ? n.forEach(o => {
            r = nk(r, o, s)
        }
        ) : i.length && i.forEach(o => {
            r = rk(r, o, s)
        }
        ),
        r
    }
    ).join(" ")
}
var ke = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ic(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
function kg(e) {
    if (e.__esModule)
        return e;
    var t = e.default;
    if (typeof t == "function") {
        var r = function n() {
            return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
        };
        r.prototype = t.prototype
    } else
        r = {};
    return Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    Object.keys(e).forEach(function(n) {
        var i = Object.getOwnPropertyDescriptor(e, n);
        Object.defineProperty(r, n, i.get ? i : {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        })
    }),
    r
}
var cx = {}
  , pu = {}
  , Lg = {}
  , gu = {}
  , Og = {};
Object.defineProperty(Og, "__esModule", {
    value: !0
});
Og.default = new Uint16Array('<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(e) {
    return e.charCodeAt(0)
}));
var Ng = {};
Object.defineProperty(Ng, "__esModule", {
    value: !0
});
Ng.default = new Uint16Array("aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(e) {
    return e.charCodeAt(0)
}));
var Dh = {};
(function(e) {
    var t;
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.replaceCodePoint = e.fromCodePoint = void 0;
    var r = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
    e.fromCodePoint = (t = String.fromCodePoint) !== null && t !== void 0 ? t : function(s) {
        var o = "";
        return s > 65535 && (s -= 65536,
        o += String.fromCharCode(s >>> 10 & 1023 | 55296),
        s = 56320 | s & 1023),
        o += String.fromCharCode(s),
        o
    }
    ;
    function n(s) {
        var o;
        return s >= 55296 && s <= 57343 || s > 1114111 ? 65533 : (o = r.get(s)) !== null && o !== void 0 ? o : s
    }
    e.replaceCodePoint = n;
    function i(s) {
        return (0,
        e.fromCodePoint)(n(s))
    }
    e.default = i
}
)(Dh);
(function(e) {
    var t = ke && ke.__createBinding || (Object.create ? function(F, q, B, y) {
        y === void 0 && (y = B);
        var b = Object.getOwnPropertyDescriptor(q, B);
        (!b || ("get"in b ? !q.__esModule : b.writable || b.configurable)) && (b = {
            enumerable: !0,
            get: function() {
                return q[B]
            }
        }),
        Object.defineProperty(F, y, b)
    }
    : function(F, q, B, y) {
        y === void 0 && (y = B),
        F[y] = q[B]
    }
    )
      , r = ke && ke.__setModuleDefault || (Object.create ? function(F, q) {
        Object.defineProperty(F, "default", {
            enumerable: !0,
            value: q
        })
    }
    : function(F, q) {
        F.default = q
    }
    )
      , n = ke && ke.__importStar || function(F) {
        if (F && F.__esModule)
            return F;
        var q = {};
        if (F != null)
            for (var B in F)
                B !== "default" && Object.prototype.hasOwnProperty.call(F, B) && t(q, F, B);
        return r(q, F),
        q
    }
      , i = ke && ke.__importDefault || function(F) {
        return F && F.__esModule ? F : {
            default: F
        }
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.decodeXML = e.decodeHTMLStrict = e.decodeHTMLAttribute = e.decodeHTML = e.determineBranch = e.EntityDecoder = e.DecodingMode = e.BinTrieFlags = e.fromCodePoint = e.replaceCodePoint = e.decodeCodePoint = e.xmlDecodeTree = e.htmlDecodeTree = void 0;
    var s = i(Og);
    e.htmlDecodeTree = s.default;
    var o = i(Ng);
    e.xmlDecodeTree = o.default;
    var a = n(Dh);
    e.decodeCodePoint = a.default;
    var u = Dh;
    Object.defineProperty(e, "replaceCodePoint", {
        enumerable: !0,
        get: function() {
            return u.replaceCodePoint
        }
    }),
    Object.defineProperty(e, "fromCodePoint", {
        enumerable: !0,
        get: function() {
            return u.fromCodePoint
        }
    });
    var c;
    (function(F) {
        F[F.NUM = 35] = "NUM",
        F[F.SEMI = 59] = "SEMI",
        F[F.EQUALS = 61] = "EQUALS",
        F[F.ZERO = 48] = "ZERO",
        F[F.NINE = 57] = "NINE",
        F[F.LOWER_A = 97] = "LOWER_A",
        F[F.LOWER_F = 102] = "LOWER_F",
        F[F.LOWER_X = 120] = "LOWER_X",
        F[F.LOWER_Z = 122] = "LOWER_Z",
        F[F.UPPER_A = 65] = "UPPER_A",
        F[F.UPPER_F = 70] = "UPPER_F",
        F[F.UPPER_Z = 90] = "UPPER_Z"
    }
    )(c || (c = {}));
    var l = 32, p;
    (function(F) {
        F[F.VALUE_LENGTH = 49152] = "VALUE_LENGTH",
        F[F.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH",
        F[F.JUMP_TABLE = 127] = "JUMP_TABLE"
    }
    )(p = e.BinTrieFlags || (e.BinTrieFlags = {}));
    function h(F) {
        return F >= c.ZERO && F <= c.NINE
    }
    function g(F) {
        return F >= c.UPPER_A && F <= c.UPPER_F || F >= c.LOWER_A && F <= c.LOWER_F
    }
    function S(F) {
        return F >= c.UPPER_A && F <= c.UPPER_Z || F >= c.LOWER_A && F <= c.LOWER_Z || h(F)
    }
    function x(F) {
        return F === c.EQUALS || S(F)
    }
    var v;
    (function(F) {
        F[F.EntityStart = 0] = "EntityStart",
        F[F.NumericStart = 1] = "NumericStart",
        F[F.NumericDecimal = 2] = "NumericDecimal",
        F[F.NumericHex = 3] = "NumericHex",
        F[F.NamedEntity = 4] = "NamedEntity"
    }
    )(v || (v = {}));
    var I;
    (function(F) {
        F[F.Legacy = 0] = "Legacy",
        F[F.Strict = 1] = "Strict",
        F[F.Attribute = 2] = "Attribute"
    }
    )(I = e.DecodingMode || (e.DecodingMode = {}));
    var M = function() {
        function F(q, B, y) {
            this.decodeTree = q,
            this.emitCodePoint = B,
            this.errors = y,
            this.state = v.EntityStart,
            this.consumed = 1,
            this.result = 0,
            this.treeIndex = 0,
            this.excess = 1,
            this.decodeMode = I.Strict
        }
        return F.prototype.startEntity = function(q) {
            this.decodeMode = q,
            this.state = v.EntityStart,
            this.result = 0,
            this.treeIndex = 0,
            this.excess = 1,
            this.consumed = 1
        }
        ,
        F.prototype.write = function(q, B) {
            switch (this.state) {
            case v.EntityStart:
                return q.charCodeAt(B) === c.NUM ? (this.state = v.NumericStart,
                this.consumed += 1,
                this.stateNumericStart(q, B + 1)) : (this.state = v.NamedEntity,
                this.stateNamedEntity(q, B));
            case v.NumericStart:
                return this.stateNumericStart(q, B);
            case v.NumericDecimal:
                return this.stateNumericDecimal(q, B);
            case v.NumericHex:
                return this.stateNumericHex(q, B);
            case v.NamedEntity:
                return this.stateNamedEntity(q, B)
            }
        }
        ,
        F.prototype.stateNumericStart = function(q, B) {
            return B >= q.length ? -1 : (q.charCodeAt(B) | l) === c.LOWER_X ? (this.state = v.NumericHex,
            this.consumed += 1,
            this.stateNumericHex(q, B + 1)) : (this.state = v.NumericDecimal,
            this.stateNumericDecimal(q, B))
        }
        ,
        F.prototype.addToNumericResult = function(q, B, y, b) {
            if (B !== y) {
                var _ = y - B;
                this.result = this.result * Math.pow(b, _) + parseInt(q.substr(B, _), b),
                this.consumed += _
            }
        }
        ,
        F.prototype.stateNumericHex = function(q, B) {
            for (var y = B; B < q.length; ) {
                var b = q.charCodeAt(B);
                if (h(b) || g(b))
                    B += 1;
                else
                    return this.addToNumericResult(q, y, B, 16),
                    this.emitNumericEntity(b, 3)
            }
            return this.addToNumericResult(q, y, B, 16),
            -1
        }
        ,
        F.prototype.stateNumericDecimal = function(q, B) {
            for (var y = B; B < q.length; ) {
                var b = q.charCodeAt(B);
                if (h(b))
                    B += 1;
                else
                    return this.addToNumericResult(q, y, B, 10),
                    this.emitNumericEntity(b, 2)
            }
            return this.addToNumericResult(q, y, B, 10),
            -1
        }
        ,
        F.prototype.emitNumericEntity = function(q, B) {
            var y;
            if (this.consumed <= B)
                return (y = this.errors) === null || y === void 0 || y.absenceOfDigitsInNumericCharacterReference(this.consumed),
                0;
            if (q === c.SEMI)
                this.consumed += 1;
            else if (this.decodeMode === I.Strict)
                return 0;
            return this.emitCodePoint((0,
            a.replaceCodePoint)(this.result), this.consumed),
            this.errors && (q !== c.SEMI && this.errors.missingSemicolonAfterCharacterReference(),
            this.errors.validateNumericCharacterReference(this.result)),
            this.consumed
        }
        ,
        F.prototype.stateNamedEntity = function(q, B) {
            for (var y = this.decodeTree, b = y[this.treeIndex], _ = (b & p.VALUE_LENGTH) >> 14; B < q.length; B++,
            this.excess++) {
                var T = q.charCodeAt(B);
                if (this.treeIndex = k(y, b, this.treeIndex + Math.max(1, _), T),
                this.treeIndex < 0)
                    return this.result === 0 || this.decodeMode === I.Attribute && (_ === 0 || x(T)) ? 0 : this.emitNotTerminatedNamedEntity();
                if (b = y[this.treeIndex],
                _ = (b & p.VALUE_LENGTH) >> 14,
                _ !== 0) {
                    if (T === c.SEMI)
                        return this.emitNamedEntityData(this.treeIndex, _, this.consumed + this.excess);
                    this.decodeMode !== I.Strict && (this.result = this.treeIndex,
                    this.consumed += this.excess,
                    this.excess = 0)
                }
            }
            return -1
        }
        ,
        F.prototype.emitNotTerminatedNamedEntity = function() {
            var q, B = this, y = B.result, b = B.decodeTree, _ = (b[y] & p.VALUE_LENGTH) >> 14;
            return this.emitNamedEntityData(y, _, this.consumed),
            (q = this.errors) === null || q === void 0 || q.missingSemicolonAfterCharacterReference(),
            this.consumed
        }
        ,
        F.prototype.emitNamedEntityData = function(q, B, y) {
            var b = this.decodeTree;
            return this.emitCodePoint(B === 1 ? b[q] & ~p.VALUE_LENGTH : b[q + 1], y),
            B === 3 && this.emitCodePoint(b[q + 2], y),
            y
        }
        ,
        F.prototype.end = function() {
            var q;
            switch (this.state) {
            case v.NamedEntity:
                return this.result !== 0 && (this.decodeMode !== I.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            case v.NumericDecimal:
                return this.emitNumericEntity(0, 2);
            case v.NumericHex:
                return this.emitNumericEntity(0, 3);
            case v.NumericStart:
                return (q = this.errors) === null || q === void 0 || q.absenceOfDigitsInNumericCharacterReference(this.consumed),
                0;
            case v.EntityStart:
                return 0
            }
        }
        ,
        F
    }();
    e.EntityDecoder = M;
    function A(F) {
        var q = ""
          , B = new M(F,function(y) {
            return q += (0,
            a.fromCodePoint)(y)
        }
        );
        return function(b, _) {
            for (var T = 0, C = 0; (C = b.indexOf("&", C)) >= 0; ) {
                q += b.slice(T, C),
                B.startEntity(_);
                var P = B.write(b, C + 1);
                if (P < 0) {
                    T = C + B.end();
                    break
                }
                T = C + P,
                C = P === 0 ? T + 1 : T
            }
            var W = q + b.slice(T);
            return q = "",
            W
        }
    }
    function k(F, q, B, y) {
        var b = (q & p.BRANCH_LENGTH) >> 7
          , _ = q & p.JUMP_TABLE;
        if (b === 0)
            return _ !== 0 && y === _ ? B : -1;
        if (_) {
            var T = y - _;
            return T < 0 || T >= b ? -1 : F[B + T] - 1
        }
        for (var C = B, P = C + b - 1; C <= P; ) {
            var W = C + P >>> 1
              , N = F[W];
            if (N < y)
                C = W + 1;
            else if (N > y)
                P = W - 1;
            else
                return F[W + b]
        }
        return -1
    }
    e.determineBranch = k;
    var L = A(s.default)
      , O = A(o.default);
    function $(F, q) {
        return q === void 0 && (q = I.Legacy),
        L(F, q)
    }
    e.decodeHTML = $;
    function D(F) {
        return L(F, I.Attribute)
    }
    e.decodeHTMLAttribute = D;
    function K(F) {
        return L(F, I.Strict)
    }
    e.decodeHTMLStrict = K;
    function G(F) {
        return O(F, I.Strict)
    }
    e.decodeXML = G
}
)(gu);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.QuoteType = void 0;
    var t = gu, r;
    (function(h) {
        h[h.Tab = 9] = "Tab",
        h[h.NewLine = 10] = "NewLine",
        h[h.FormFeed = 12] = "FormFeed",
        h[h.CarriageReturn = 13] = "CarriageReturn",
        h[h.Space = 32] = "Space",
        h[h.ExclamationMark = 33] = "ExclamationMark",
        h[h.Number = 35] = "Number",
        h[h.Amp = 38] = "Amp",
        h[h.SingleQuote = 39] = "SingleQuote",
        h[h.DoubleQuote = 34] = "DoubleQuote",
        h[h.Dash = 45] = "Dash",
        h[h.Slash = 47] = "Slash",
        h[h.Zero = 48] = "Zero",
        h[h.Nine = 57] = "Nine",
        h[h.Semi = 59] = "Semi",
        h[h.Lt = 60] = "Lt",
        h[h.Eq = 61] = "Eq",
        h[h.Gt = 62] = "Gt",
        h[h.Questionmark = 63] = "Questionmark",
        h[h.UpperA = 65] = "UpperA",
        h[h.LowerA = 97] = "LowerA",
        h[h.UpperF = 70] = "UpperF",
        h[h.LowerF = 102] = "LowerF",
        h[h.UpperZ = 90] = "UpperZ",
        h[h.LowerZ = 122] = "LowerZ",
        h[h.LowerX = 120] = "LowerX",
        h[h.OpeningSquareBracket = 91] = "OpeningSquareBracket"
    }
    )(r || (r = {}));
    var n;
    (function(h) {
        h[h.Text = 1] = "Text",
        h[h.BeforeTagName = 2] = "BeforeTagName",
        h[h.InTagName = 3] = "InTagName",
        h[h.InSelfClosingTag = 4] = "InSelfClosingTag",
        h[h.BeforeClosingTagName = 5] = "BeforeClosingTagName",
        h[h.InClosingTagName = 6] = "InClosingTagName",
        h[h.AfterClosingTagName = 7] = "AfterClosingTagName",
        h[h.BeforeAttributeName = 8] = "BeforeAttributeName",
        h[h.InAttributeName = 9] = "InAttributeName",
        h[h.AfterAttributeName = 10] = "AfterAttributeName",
        h[h.BeforeAttributeValue = 11] = "BeforeAttributeValue",
        h[h.InAttributeValueDq = 12] = "InAttributeValueDq",
        h[h.InAttributeValueSq = 13] = "InAttributeValueSq",
        h[h.InAttributeValueNq = 14] = "InAttributeValueNq",
        h[h.BeforeDeclaration = 15] = "BeforeDeclaration",
        h[h.InDeclaration = 16] = "InDeclaration",
        h[h.InProcessingInstruction = 17] = "InProcessingInstruction",
        h[h.BeforeComment = 18] = "BeforeComment",
        h[h.CDATASequence = 19] = "CDATASequence",
        h[h.InSpecialComment = 20] = "InSpecialComment",
        h[h.InCommentLike = 21] = "InCommentLike",
        h[h.BeforeSpecialS = 22] = "BeforeSpecialS",
        h[h.SpecialStartSequence = 23] = "SpecialStartSequence",
        h[h.InSpecialTag = 24] = "InSpecialTag",
        h[h.BeforeEntity = 25] = "BeforeEntity",
        h[h.BeforeNumericEntity = 26] = "BeforeNumericEntity",
        h[h.InNamedEntity = 27] = "InNamedEntity",
        h[h.InNumericEntity = 28] = "InNumericEntity",
        h[h.InHexEntity = 29] = "InHexEntity"
    }
    )(n || (n = {}));
    function i(h) {
        return h === r.Space || h === r.NewLine || h === r.Tab || h === r.FormFeed || h === r.CarriageReturn
    }
    function s(h) {
        return h === r.Slash || h === r.Gt || i(h)
    }
    function o(h) {
        return h >= r.Zero && h <= r.Nine
    }
    function a(h) {
        return h >= r.LowerA && h <= r.LowerZ || h >= r.UpperA && h <= r.UpperZ
    }
    function u(h) {
        return h >= r.UpperA && h <= r.UpperF || h >= r.LowerA && h <= r.LowerF
    }
    var c;
    (function(h) {
        h[h.NoValue = 0] = "NoValue",
        h[h.Unquoted = 1] = "Unquoted",
        h[h.Single = 2] = "Single",
        h[h.Double = 3] = "Double"
    }
    )(c = e.QuoteType || (e.QuoteType = {}));
    var l = {
        Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
        CdataEnd: new Uint8Array([93, 93, 62]),
        CommentEnd: new Uint8Array([45, 45, 62]),
        ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
        StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
        TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
    }
      , p = function() {
        function h(g, S) {
            var x = g.xmlMode
              , v = x === void 0 ? !1 : x
              , I = g.decodeEntities
              , M = I === void 0 ? !0 : I;
            this.cbs = S,
            this.state = n.Text,
            this.buffer = "",
            this.sectionStart = 0,
            this.index = 0,
            this.baseState = n.Text,
            this.isSpecial = !1,
            this.running = !0,
            this.offset = 0,
            this.currentSequence = void 0,
            this.sequenceIndex = 0,
            this.trieIndex = 0,
            this.trieCurrent = 0,
            this.entityResult = 0,
            this.entityExcess = 0,
            this.xmlMode = v,
            this.decodeEntities = M,
            this.entityTrie = v ? t.xmlDecodeTree : t.htmlDecodeTree
        }
        return h.prototype.reset = function() {
            this.state = n.Text,
            this.buffer = "",
            this.sectionStart = 0,
            this.index = 0,
            this.baseState = n.Text,
            this.currentSequence = void 0,
            this.running = !0,
            this.offset = 0
        }
        ,
        h.prototype.write = function(g) {
            this.offset += this.buffer.length,
            this.buffer = g,
            this.parse()
        }
        ,
        h.prototype.end = function() {
            this.running && this.finish()
        }
        ,
        h.prototype.pause = function() {
            this.running = !1
        }
        ,
        h.prototype.resume = function() {
            this.running = !0,
            this.index < this.buffer.length + this.offset && this.parse()
        }
        ,
        h.prototype.getIndex = function() {
            return this.index
        }
        ,
        h.prototype.getSectionStart = function() {
            return this.sectionStart
        }
        ,
        h.prototype.stateText = function(g) {
            g === r.Lt || !this.decodeEntities && this.fastForwardTo(r.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index),
            this.state = n.BeforeTagName,
            this.sectionStart = this.index) : this.decodeEntities && g === r.Amp && (this.state = n.BeforeEntity)
        }
        ,
        h.prototype.stateSpecialStartSequence = function(g) {
            var S = this.sequenceIndex === this.currentSequence.length
              , x = S ? s(g) : (g | 32) === this.currentSequence[this.sequenceIndex];
            if (!x)
                this.isSpecial = !1;
            else if (!S) {
                this.sequenceIndex++;
                return
            }
            this.sequenceIndex = 0,
            this.state = n.InTagName,
            this.stateInTagName(g)
        }
        ,
        h.prototype.stateInSpecialTag = function(g) {
            if (this.sequenceIndex === this.currentSequence.length) {
                if (g === r.Gt || i(g)) {
                    var S = this.index - this.currentSequence.length;
                    if (this.sectionStart < S) {
                        var x = this.index;
                        this.index = S,
                        this.cbs.ontext(this.sectionStart, S),
                        this.index = x
                    }
                    this.isSpecial = !1,
                    this.sectionStart = S + 2,
                    this.stateInClosingTagName(g);
                    return
                }
                this.sequenceIndex = 0
            }
            (g | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === l.TitleEnd ? this.decodeEntities && g === r.Amp && (this.state = n.BeforeEntity) : this.fastForwardTo(r.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(g === r.Lt)
        }
        ,
        h.prototype.stateCDATASequence = function(g) {
            g === l.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === l.Cdata.length && (this.state = n.InCommentLike,
            this.currentSequence = l.CdataEnd,
            this.sequenceIndex = 0,
            this.sectionStart = this.index + 1) : (this.sequenceIndex = 0,
            this.state = n.InDeclaration,
            this.stateInDeclaration(g))
        }
        ,
        h.prototype.fastForwardTo = function(g) {
            for (; ++this.index < this.buffer.length + this.offset; )
                if (this.buffer.charCodeAt(this.index - this.offset) === g)
                    return !0;
            return this.index = this.buffer.length + this.offset - 1,
            !1
        }
        ,
        h.prototype.stateInCommentLike = function(g) {
            g === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === l.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2),
            this.sequenceIndex = 0,
            this.sectionStart = this.index + 1,
            this.state = n.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : g !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0)
        }
        ,
        h.prototype.isTagStartChar = function(g) {
            return this.xmlMode ? !s(g) : a(g)
        }
        ,
        h.prototype.startSpecial = function(g, S) {
            this.isSpecial = !0,
            this.currentSequence = g,
            this.sequenceIndex = S,
            this.state = n.SpecialStartSequence
        }
        ,
        h.prototype.stateBeforeTagName = function(g) {
            if (g === r.ExclamationMark)
                this.state = n.BeforeDeclaration,
                this.sectionStart = this.index + 1;
            else if (g === r.Questionmark)
                this.state = n.InProcessingInstruction,
                this.sectionStart = this.index + 1;
            else if (this.isTagStartChar(g)) {
                var S = g | 32;
                this.sectionStart = this.index,
                !this.xmlMode && S === l.TitleEnd[2] ? this.startSpecial(l.TitleEnd, 3) : this.state = !this.xmlMode && S === l.ScriptEnd[2] ? n.BeforeSpecialS : n.InTagName
            } else
                g === r.Slash ? this.state = n.BeforeClosingTagName : (this.state = n.Text,
                this.stateText(g))
        }
        ,
        h.prototype.stateInTagName = function(g) {
            s(g) && (this.cbs.onopentagname(this.sectionStart, this.index),
            this.sectionStart = -1,
            this.state = n.BeforeAttributeName,
            this.stateBeforeAttributeName(g))
        }
        ,
        h.prototype.stateBeforeClosingTagName = function(g) {
            i(g) || (g === r.Gt ? this.state = n.Text : (this.state = this.isTagStartChar(g) ? n.InClosingTagName : n.InSpecialComment,
            this.sectionStart = this.index))
        }
        ,
        h.prototype.stateInClosingTagName = function(g) {
            (g === r.Gt || i(g)) && (this.cbs.onclosetag(this.sectionStart, this.index),
            this.sectionStart = -1,
            this.state = n.AfterClosingTagName,
            this.stateAfterClosingTagName(g))
        }
        ,
        h.prototype.stateAfterClosingTagName = function(g) {
            (g === r.Gt || this.fastForwardTo(r.Gt)) && (this.state = n.Text,
            this.baseState = n.Text,
            this.sectionStart = this.index + 1)
        }
        ,
        h.prototype.stateBeforeAttributeName = function(g) {
            g === r.Gt ? (this.cbs.onopentagend(this.index),
            this.isSpecial ? (this.state = n.InSpecialTag,
            this.sequenceIndex = 0) : this.state = n.Text,
            this.baseState = this.state,
            this.sectionStart = this.index + 1) : g === r.Slash ? this.state = n.InSelfClosingTag : i(g) || (this.state = n.InAttributeName,
            this.sectionStart = this.index)
        }
        ,
        h.prototype.stateInSelfClosingTag = function(g) {
            g === r.Gt ? (this.cbs.onselfclosingtag(this.index),
            this.state = n.Text,
            this.baseState = n.Text,
            this.sectionStart = this.index + 1,
            this.isSpecial = !1) : i(g) || (this.state = n.BeforeAttributeName,
            this.stateBeforeAttributeName(g))
        }
        ,
        h.prototype.stateInAttributeName = function(g) {
            (g === r.Eq || s(g)) && (this.cbs.onattribname(this.sectionStart, this.index),
            this.sectionStart = -1,
            this.state = n.AfterAttributeName,
            this.stateAfterAttributeName(g))
        }
        ,
        h.prototype.stateAfterAttributeName = function(g) {
            g === r.Eq ? this.state = n.BeforeAttributeValue : g === r.Slash || g === r.Gt ? (this.cbs.onattribend(c.NoValue, this.index),
            this.state = n.BeforeAttributeName,
            this.stateBeforeAttributeName(g)) : i(g) || (this.cbs.onattribend(c.NoValue, this.index),
            this.state = n.InAttributeName,
            this.sectionStart = this.index)
        }
        ,
        h.prototype.stateBeforeAttributeValue = function(g) {
            g === r.DoubleQuote ? (this.state = n.InAttributeValueDq,
            this.sectionStart = this.index + 1) : g === r.SingleQuote ? (this.state = n.InAttributeValueSq,
            this.sectionStart = this.index + 1) : i(g) || (this.sectionStart = this.index,
            this.state = n.InAttributeValueNq,
            this.stateInAttributeValueNoQuotes(g))
        }
        ,
        h.prototype.handleInAttributeValue = function(g, S) {
            g === S || !this.decodeEntities && this.fastForwardTo(S) ? (this.cbs.onattribdata(this.sectionStart, this.index),
            this.sectionStart = -1,
            this.cbs.onattribend(S === r.DoubleQuote ? c.Double : c.Single, this.index),
            this.state = n.BeforeAttributeName) : this.decodeEntities && g === r.Amp && (this.baseState = this.state,
            this.state = n.BeforeEntity)
        }
        ,
        h.prototype.stateInAttributeValueDoubleQuotes = function(g) {
            this.handleInAttributeValue(g, r.DoubleQuote)
        }
        ,
        h.prototype.stateInAttributeValueSingleQuotes = function(g) {
            this.handleInAttributeValue(g, r.SingleQuote)
        }
        ,
        h.prototype.stateInAttributeValueNoQuotes = function(g) {
            i(g) || g === r.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index),
            this.sectionStart = -1,
            this.cbs.onattribend(c.Unquoted, this.index),
            this.state = n.BeforeAttributeName,
            this.stateBeforeAttributeName(g)) : this.decodeEntities && g === r.Amp && (this.baseState = this.state,
            this.state = n.BeforeEntity)
        }
        ,
        h.prototype.stateBeforeDeclaration = function(g) {
            g === r.OpeningSquareBracket ? (this.state = n.CDATASequence,
            this.sequenceIndex = 0) : this.state = g === r.Dash ? n.BeforeComment : n.InDeclaration
        }
        ,
        h.prototype.stateInDeclaration = function(g) {
            (g === r.Gt || this.fastForwardTo(r.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index),
            this.state = n.Text,
            this.sectionStart = this.index + 1)
        }
        ,
        h.prototype.stateInProcessingInstruction = function(g) {
            (g === r.Gt || this.fastForwardTo(r.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index),
            this.state = n.Text,
            this.sectionStart = this.index + 1)
        }
        ,
        h.prototype.stateBeforeComment = function(g) {
            g === r.Dash ? (this.state = n.InCommentLike,
            this.currentSequence = l.CommentEnd,
            this.sequenceIndex = 2,
            this.sectionStart = this.index + 1) : this.state = n.InDeclaration
        }
        ,
        h.prototype.stateInSpecialComment = function(g) {
            (g === r.Gt || this.fastForwardTo(r.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0),
            this.state = n.Text,
            this.sectionStart = this.index + 1)
        }
        ,
        h.prototype.stateBeforeSpecialS = function(g) {
            var S = g | 32;
            S === l.ScriptEnd[3] ? this.startSpecial(l.ScriptEnd, 4) : S === l.StyleEnd[3] ? this.startSpecial(l.StyleEnd, 4) : (this.state = n.InTagName,
            this.stateInTagName(g))
        }
        ,
        h.prototype.stateBeforeEntity = function(g) {
            this.entityExcess = 1,
            this.entityResult = 0,
            g === r.Number ? this.state = n.BeforeNumericEntity : g === r.Amp || (this.trieIndex = 0,
            this.trieCurrent = this.entityTrie[0],
            this.state = n.InNamedEntity,
            this.stateInNamedEntity(g))
        }
        ,
        h.prototype.stateInNamedEntity = function(g) {
            if (this.entityExcess += 1,
            this.trieIndex = (0,
            t.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, g),
            this.trieIndex < 0) {
                this.emitNamedEntity(),
                this.index--;
                return
            }
            this.trieCurrent = this.entityTrie[this.trieIndex];
            var S = this.trieCurrent & t.BinTrieFlags.VALUE_LENGTH;
            if (S) {
                var x = (S >> 14) - 1;
                if (!this.allowLegacyEntity() && g !== r.Semi)
                    this.trieIndex += x;
                else {
                    var v = this.index - this.entityExcess + 1;
                    v > this.sectionStart && this.emitPartial(this.sectionStart, v),
                    this.entityResult = this.trieIndex,
                    this.trieIndex += x,
                    this.entityExcess = 0,
                    this.sectionStart = this.index + 1,
                    x === 0 && this.emitNamedEntity()
                }
            }
        }
        ,
        h.prototype.emitNamedEntity = function() {
            if (this.state = this.baseState,
            this.entityResult !== 0) {
                var g = (this.entityTrie[this.entityResult] & t.BinTrieFlags.VALUE_LENGTH) >> 14;
                switch (g) {
                case 1:
                    {
                        this.emitCodePoint(this.entityTrie[this.entityResult] & ~t.BinTrieFlags.VALUE_LENGTH);
                        break
                    }
                case 2:
                    {
                        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                        break
                    }
                case 3:
                    this.emitCodePoint(this.entityTrie[this.entityResult + 1]),
                    this.emitCodePoint(this.entityTrie[this.entityResult + 2])
                }
            }
        }
        ,
        h.prototype.stateBeforeNumericEntity = function(g) {
            (g | 32) === r.LowerX ? (this.entityExcess++,
            this.state = n.InHexEntity) : (this.state = n.InNumericEntity,
            this.stateInNumericEntity(g))
        }
        ,
        h.prototype.emitNumericEntity = function(g) {
            var S = this.index - this.entityExcess - 1
              , x = S + 2 + +(this.state === n.InHexEntity);
            x !== this.index && (S > this.sectionStart && this.emitPartial(this.sectionStart, S),
            this.sectionStart = this.index + Number(g),
            this.emitCodePoint((0,
            t.replaceCodePoint)(this.entityResult))),
            this.state = this.baseState
        }
        ,
        h.prototype.stateInNumericEntity = function(g) {
            g === r.Semi ? this.emitNumericEntity(!0) : o(g) ? (this.entityResult = this.entityResult * 10 + (g - r.Zero),
            this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState,
            this.index--)
        }
        ,
        h.prototype.stateInHexEntity = function(g) {
            g === r.Semi ? this.emitNumericEntity(!0) : o(g) ? (this.entityResult = this.entityResult * 16 + (g - r.Zero),
            this.entityExcess++) : u(g) ? (this.entityResult = this.entityResult * 16 + ((g | 32) - r.LowerA + 10),
            this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState,
            this.index--)
        }
        ,
        h.prototype.allowLegacyEntity = function() {
            return !this.xmlMode && (this.baseState === n.Text || this.baseState === n.InSpecialTag)
        }
        ,
        h.prototype.cleanup = function() {
            this.running && this.sectionStart !== this.index && (this.state === n.Text || this.state === n.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index),
            this.sectionStart = this.index) : (this.state === n.InAttributeValueDq || this.state === n.InAttributeValueSq || this.state === n.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index),
            this.sectionStart = this.index))
        }
        ,
        h.prototype.shouldContinue = function() {
            return this.index < this.buffer.length + this.offset && this.running
        }
        ,
        h.prototype.parse = function() {
            for (; this.shouldContinue(); ) {
                var g = this.buffer.charCodeAt(this.index - this.offset);
                switch (this.state) {
                case n.Text:
                    {
                        this.stateText(g);
                        break
                    }
                case n.SpecialStartSequence:
                    {
                        this.stateSpecialStartSequence(g);
                        break
                    }
                case n.InSpecialTag:
                    {
                        this.stateInSpecialTag(g);
                        break
                    }
                case n.CDATASequence:
                    {
                        this.stateCDATASequence(g);
                        break
                    }
                case n.InAttributeValueDq:
                    {
                        this.stateInAttributeValueDoubleQuotes(g);
                        break
                    }
                case n.InAttributeName:
                    {
                        this.stateInAttributeName(g);
                        break
                    }
                case n.InCommentLike:
                    {
                        this.stateInCommentLike(g);
                        break
                    }
                case n.InSpecialComment:
                    {
                        this.stateInSpecialComment(g);
                        break
                    }
                case n.BeforeAttributeName:
                    {
                        this.stateBeforeAttributeName(g);
                        break
                    }
                case n.InTagName:
                    {
                        this.stateInTagName(g);
                        break
                    }
                case n.InClosingTagName:
                    {
                        this.stateInClosingTagName(g);
                        break
                    }
                case n.BeforeTagName:
                    {
                        this.stateBeforeTagName(g);
                        break
                    }
                case n.AfterAttributeName:
                    {
                        this.stateAfterAttributeName(g);
                        break
                    }
                case n.InAttributeValueSq:
                    {
                        this.stateInAttributeValueSingleQuotes(g);
                        break
                    }
                case n.BeforeAttributeValue:
                    {
                        this.stateBeforeAttributeValue(g);
                        break
                    }
                case n.BeforeClosingTagName:
                    {
                        this.stateBeforeClosingTagName(g);
                        break
                    }
                case n.AfterClosingTagName:
                    {
                        this.stateAfterClosingTagName(g);
                        break
                    }
                case n.BeforeSpecialS:
                    {
                        this.stateBeforeSpecialS(g);
                        break
                    }
                case n.InAttributeValueNq:
                    {
                        this.stateInAttributeValueNoQuotes(g);
                        break
                    }
                case n.InSelfClosingTag:
                    {
                        this.stateInSelfClosingTag(g);
                        break
                    }
                case n.InDeclaration:
                    {
                        this.stateInDeclaration(g);
                        break
                    }
                case n.BeforeDeclaration:
                    {
                        this.stateBeforeDeclaration(g);
                        break
                    }
                case n.BeforeComment:
                    {
                        this.stateBeforeComment(g);
                        break
                    }
                case n.InProcessingInstruction:
                    {
                        this.stateInProcessingInstruction(g);
                        break
                    }
                case n.InNamedEntity:
                    {
                        this.stateInNamedEntity(g);
                        break
                    }
                case n.BeforeEntity:
                    {
                        this.stateBeforeEntity(g);
                        break
                    }
                case n.InHexEntity:
                    {
                        this.stateInHexEntity(g);
                        break
                    }
                case n.InNumericEntity:
                    {
                        this.stateInNumericEntity(g);
                        break
                    }
                default:
                    this.stateBeforeNumericEntity(g)
                }
                this.index++
            }
            this.cleanup()
        }
        ,
        h.prototype.finish = function() {
            this.state === n.InNamedEntity && this.emitNamedEntity(),
            this.sectionStart < this.index && this.handleTrailingData(),
            this.cbs.onend()
        }
        ,
        h.prototype.handleTrailingData = function() {
            var g = this.buffer.length + this.offset;
            this.state === n.InCommentLike ? this.currentSequence === l.CdataEnd ? this.cbs.oncdata(this.sectionStart, g, 0) : this.cbs.oncomment(this.sectionStart, g, 0) : this.state === n.InNumericEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === n.InHexEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === n.InTagName || this.state === n.BeforeAttributeName || this.state === n.BeforeAttributeValue || this.state === n.AfterAttributeName || this.state === n.InAttributeName || this.state === n.InAttributeValueSq || this.state === n.InAttributeValueDq || this.state === n.InAttributeValueNq || this.state === n.InClosingTagName || this.cbs.ontext(this.sectionStart, g)
        }
        ,
        h.prototype.emitPartial = function(g, S) {
            this.baseState !== n.Text && this.baseState !== n.InSpecialTag ? this.cbs.onattribdata(g, S) : this.cbs.ontext(g, S)
        }
        ,
        h.prototype.emitCodePoint = function(g) {
            this.baseState !== n.Text && this.baseState !== n.InSpecialTag ? this.cbs.onattribentity(g) : this.cbs.ontextentity(g)
        }
        ,
        h
    }();
    e.default = p
}
)(Lg);
var ck = ke && ke.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get"in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r]
        }
    }),
    Object.defineProperty(e, n, i)
}
: function(e, t, r, n) {
    n === void 0 && (n = r),
    e[n] = t[r]
}
)
  , lk = ke && ke.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    })
}
: function(e, t) {
    e.default = t
}
)
  , fk = ke && ke.__importStar || function(e) {
    if (e && e.__esModule)
        return e;
    var t = {};
    if (e != null)
        for (var r in e)
            r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && ck(t, e, r);
    return lk(t, e),
    t
}
;
Object.defineProperty(pu, "__esModule", {
    value: !0
});
pu.Parser = void 0;
var Pc = fk(Lg)
  , Ly = gu
  , oo = new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"])
  , st = new Set(["p"])
  , Oy = new Set(["thead", "tbody"])
  , Ny = new Set(["dd", "dt"])
  , Ry = new Set(["rt", "rp"])
  , dk = new Map([["tr", new Set(["tr", "th", "td"])], ["th", new Set(["th"])], ["td", new Set(["thead", "th", "td"])], ["body", new Set(["head", "link", "script"])], ["li", new Set(["li"])], ["p", st], ["h1", st], ["h2", st], ["h3", st], ["h4", st], ["h5", st], ["h6", st], ["select", oo], ["input", oo], ["output", oo], ["button", oo], ["datalist", oo], ["textarea", oo], ["option", new Set(["option"])], ["optgroup", new Set(["optgroup", "option"])], ["dd", Ny], ["dt", Ny], ["address", st], ["article", st], ["aside", st], ["blockquote", st], ["details", st], ["div", st], ["dl", st], ["fieldset", st], ["figcaption", st], ["figure", st], ["footer", st], ["form", st], ["header", st], ["hr", st], ["main", st], ["nav", st], ["ol", st], ["pre", st], ["section", st], ["table", st], ["ul", st], ["rt", Ry], ["rp", Ry], ["tbody", Oy], ["tfoot", Oy]])
  , hk = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"])
  , By = new Set(["math", "svg"])
  , Py = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignobject", "desc", "title"])
  , pk = /\s|\//
  , gk = function() {
    function e(t, r) {
        r === void 0 && (r = {});
        var n, i, s, o, a;
        this.options = r,
        this.startIndex = 0,
        this.endIndex = 0,
        this.openTagStart = 0,
        this.tagname = "",
        this.attribname = "",
        this.attribvalue = "",
        this.attribs = null,
        this.stack = [],
        this.foreignContext = [],
        this.buffers = [],
        this.bufferOffset = 0,
        this.writeIndex = 0,
        this.ended = !1,
        this.cbs = t ?? {},
        this.lowerCaseTagNames = (n = r.lowerCaseTags) !== null && n !== void 0 ? n : !r.xmlMode,
        this.lowerCaseAttributeNames = (i = r.lowerCaseAttributeNames) !== null && i !== void 0 ? i : !r.xmlMode,
        this.tokenizer = new ((s = r.Tokenizer) !== null && s !== void 0 ? s : Pc.default)(this.options,this),
        (a = (o = this.cbs).onparserinit) === null || a === void 0 || a.call(o, this)
    }
    return e.prototype.ontext = function(t, r) {
        var n, i, s = this.getSlice(t, r);
        this.endIndex = r - 1,
        (i = (n = this.cbs).ontext) === null || i === void 0 || i.call(n, s),
        this.startIndex = r
    }
    ,
    e.prototype.ontextentity = function(t) {
        var r, n, i = this.tokenizer.getSectionStart();
        this.endIndex = i - 1,
        (n = (r = this.cbs).ontext) === null || n === void 0 || n.call(r, (0,
        Ly.fromCodePoint)(t)),
        this.startIndex = i
    }
    ,
    e.prototype.isVoidElement = function(t) {
        return !this.options.xmlMode && hk.has(t)
    }
    ,
    e.prototype.onopentagname = function(t, r) {
        this.endIndex = r;
        var n = this.getSlice(t, r);
        this.lowerCaseTagNames && (n = n.toLowerCase()),
        this.emitOpenTag(n)
    }
    ,
    e.prototype.emitOpenTag = function(t) {
        var r, n, i, s;
        this.openTagStart = this.startIndex,
        this.tagname = t;
        var o = !this.options.xmlMode && dk.get(t);
        if (o)
            for (; this.stack.length > 0 && o.has(this.stack[this.stack.length - 1]); ) {
                var a = this.stack.pop();
                (n = (r = this.cbs).onclosetag) === null || n === void 0 || n.call(r, a, !0)
            }
        this.isVoidElement(t) || (this.stack.push(t),
        By.has(t) ? this.foreignContext.push(!0) : Py.has(t) && this.foreignContext.push(!1)),
        (s = (i = this.cbs).onopentagname) === null || s === void 0 || s.call(i, t),
        this.cbs.onopentag && (this.attribs = {})
    }
    ,
    e.prototype.endOpenTag = function(t) {
        var r, n;
        this.startIndex = this.openTagStart,
        this.attribs && ((n = (r = this.cbs).onopentag) === null || n === void 0 || n.call(r, this.tagname, this.attribs, t),
        this.attribs = null),
        this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0),
        this.tagname = ""
    }
    ,
    e.prototype.onopentagend = function(t) {
        this.endIndex = t,
        this.endOpenTag(!1),
        this.startIndex = t + 1
    }
    ,
    e.prototype.onclosetag = function(t, r) {
        var n, i, s, o, a, u;
        this.endIndex = r;
        var c = this.getSlice(t, r);
        if (this.lowerCaseTagNames && (c = c.toLowerCase()),
        (By.has(c) || Py.has(c)) && this.foreignContext.pop(),
        this.isVoidElement(c))
            !this.options.xmlMode && c === "br" && ((i = (n = this.cbs).onopentagname) === null || i === void 0 || i.call(n, "br"),
            (o = (s = this.cbs).onopentag) === null || o === void 0 || o.call(s, "br", {}, !0),
            (u = (a = this.cbs).onclosetag) === null || u === void 0 || u.call(a, "br", !1));
        else {
            var l = this.stack.lastIndexOf(c);
            if (l !== -1)
                if (this.cbs.onclosetag)
                    for (var p = this.stack.length - l; p--; )
                        this.cbs.onclosetag(this.stack.pop(), p !== 0);
                else
                    this.stack.length = l;
            else
                !this.options.xmlMode && c === "p" && (this.emitOpenTag("p"),
                this.closeCurrentTag(!0))
        }
        this.startIndex = r + 1
    }
    ,
    e.prototype.onselfclosingtag = function(t) {
        this.endIndex = t,
        this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(!1),
        this.startIndex = t + 1) : this.onopentagend(t)
    }
    ,
    e.prototype.closeCurrentTag = function(t) {
        var r, n, i = this.tagname;
        this.endOpenTag(t),
        this.stack[this.stack.length - 1] === i && ((n = (r = this.cbs).onclosetag) === null || n === void 0 || n.call(r, i, !t),
        this.stack.pop())
    }
    ,
    e.prototype.onattribname = function(t, r) {
        this.startIndex = t;
        var n = this.getSlice(t, r);
        this.attribname = this.lowerCaseAttributeNames ? n.toLowerCase() : n
    }
    ,
    e.prototype.onattribdata = function(t, r) {
        this.attribvalue += this.getSlice(t, r)
    }
    ,
    e.prototype.onattribentity = function(t) {
        this.attribvalue += (0,
        Ly.fromCodePoint)(t)
    }
    ,
    e.prototype.onattribend = function(t, r) {
        var n, i;
        this.endIndex = r,
        (i = (n = this.cbs).onattribute) === null || i === void 0 || i.call(n, this.attribname, this.attribvalue, t === Pc.QuoteType.Double ? '"' : t === Pc.QuoteType.Single ? "'" : t === Pc.QuoteType.NoValue ? void 0 : null),
        this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue),
        this.attribvalue = ""
    }
    ,
    e.prototype.getInstructionName = function(t) {
        var r = t.search(pk)
          , n = r < 0 ? t : t.substr(0, r);
        return this.lowerCaseTagNames && (n = n.toLowerCase()),
        n
    }
    ,
    e.prototype.ondeclaration = function(t, r) {
        this.endIndex = r;
        var n = this.getSlice(t, r);
        if (this.cbs.onprocessinginstruction) {
            var i = this.getInstructionName(n);
            this.cbs.onprocessinginstruction("!".concat(i), "!".concat(n))
        }
        this.startIndex = r + 1
    }
    ,
    e.prototype.onprocessinginstruction = function(t, r) {
        this.endIndex = r;
        var n = this.getSlice(t, r);
        if (this.cbs.onprocessinginstruction) {
            var i = this.getInstructionName(n);
            this.cbs.onprocessinginstruction("?".concat(i), "?".concat(n))
        }
        this.startIndex = r + 1
    }
    ,
    e.prototype.oncomment = function(t, r, n) {
        var i, s, o, a;
        this.endIndex = r,
        (s = (i = this.cbs).oncomment) === null || s === void 0 || s.call(i, this.getSlice(t, r - n)),
        (a = (o = this.cbs).oncommentend) === null || a === void 0 || a.call(o),
        this.startIndex = r + 1
    }
    ,
    e.prototype.oncdata = function(t, r, n) {
        var i, s, o, a, u, c, l, p, h, g;
        this.endIndex = r;
        var S = this.getSlice(t, r - n);
        this.options.xmlMode || this.options.recognizeCDATA ? ((s = (i = this.cbs).oncdatastart) === null || s === void 0 || s.call(i),
        (a = (o = this.cbs).ontext) === null || a === void 0 || a.call(o, S),
        (c = (u = this.cbs).oncdataend) === null || c === void 0 || c.call(u)) : ((p = (l = this.cbs).oncomment) === null || p === void 0 || p.call(l, "[CDATA[".concat(S, "]]")),
        (g = (h = this.cbs).oncommentend) === null || g === void 0 || g.call(h)),
        this.startIndex = r + 1
    }
    ,
    e.prototype.onend = function() {
        var t, r;
        if (this.cbs.onclosetag) {
            this.endIndex = this.startIndex;
            for (var n = this.stack.length; n > 0; this.cbs.onclosetag(this.stack[--n], !0))
                ;
        }
        (r = (t = this.cbs).onend) === null || r === void 0 || r.call(t)
    }
    ,
    e.prototype.reset = function() {
        var t, r, n, i;
        (r = (t = this.cbs).onreset) === null || r === void 0 || r.call(t),
        this.tokenizer.reset(),
        this.tagname = "",
        this.attribname = "",
        this.attribs = null,
        this.stack.length = 0,
        this.startIndex = 0,
        this.endIndex = 0,
        (i = (n = this.cbs).onparserinit) === null || i === void 0 || i.call(n, this),
        this.buffers.length = 0,
        this.bufferOffset = 0,
        this.writeIndex = 0,
        this.ended = !1
    }
    ,
    e.prototype.parseComplete = function(t) {
        this.reset(),
        this.end(t)
    }
    ,
    e.prototype.getSlice = function(t, r) {
        for (; t - this.bufferOffset >= this.buffers[0].length; )
            this.shiftBuffer();
        for (var n = this.buffers[0].slice(t - this.bufferOffset, r - this.bufferOffset); r - this.bufferOffset > this.buffers[0].length; )
            this.shiftBuffer(),
            n += this.buffers[0].slice(0, r - this.bufferOffset);
        return n
    }
    ,
    e.prototype.shiftBuffer = function() {
        this.bufferOffset += this.buffers[0].length,
        this.writeIndex--,
        this.buffers.shift()
    }
    ,
    e.prototype.write = function(t) {
        var r, n;
        if (this.ended) {
            (n = (r = this.cbs).onerror) === null || n === void 0 || n.call(r, new Error(".write() after done!"));
            return
        }
        this.buffers.push(t),
        this.tokenizer.running && (this.tokenizer.write(t),
        this.writeIndex++)
    }
    ,
    e.prototype.end = function(t) {
        var r, n;
        if (this.ended) {
            (n = (r = this.cbs).onerror) === null || n === void 0 || n.call(r, new Error(".end() after done!"));
            return
        }
        t && this.write(t),
        this.ended = !0,
        this.tokenizer.end()
    }
    ,
    e.prototype.pause = function() {
        this.tokenizer.pause()
    }
    ,
    e.prototype.resume = function() {
        for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
            this.tokenizer.write(this.buffers[this.writeIndex++]);
        this.ended && this.tokenizer.end()
    }
    ,
    e.prototype.parseChunk = function(t) {
        this.write(t)
    }
    ,
    e.prototype.done = function(t) {
        this.end(t)
    }
    ,
    e
}();
pu.Parser = gk;
var mi = {}
  , pa = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
    var t;
    (function(n) {
        n.Root = "root",
        n.Text = "text",
        n.Directive = "directive",
        n.Comment = "comment",
        n.Script = "script",
        n.Style = "style",
        n.Tag = "tag",
        n.CDATA = "cdata",
        n.Doctype = "doctype"
    }
    )(t = e.ElementType || (e.ElementType = {}));
    function r(n) {
        return n.type === t.Tag || n.type === t.Script || n.type === t.Style
    }
    e.isTag = r,
    e.Root = t.Root,
    e.Text = t.Text,
    e.Directive = t.Directive,
    e.Comment = t.Comment,
    e.Script = t.Script,
    e.Style = t.Style,
    e.Tag = t.Tag,
    e.CDATA = t.CDATA,
    e.Doctype = t.Doctype
}
)(pa);
var We = {}
  , as = ke && ke.__extends || function() {
    var e = function(t, r) {
        return e = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(n, i) {
            n.__proto__ = i
        }
        || function(n, i) {
            for (var s in i)
                Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s])
        }
        ,
        e(t, r)
    };
    return function(t, r) {
        if (typeof r != "function" && r !== null)
            throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        e(t, r);
        function n() {
            this.constructor = t
        }
        t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype,
        new n)
    }
}()
  , Ja = ke && ke.__assign || function() {
    return Ja = Object.assign || function(e) {
        for (var t, r = 1, n = arguments.length; r < n; r++) {
            t = arguments[r];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
        }
        return e
    }
    ,
    Ja.apply(this, arguments)
}
;
Object.defineProperty(We, "__esModule", {
    value: !0
});
We.cloneNode = We.hasChildren = We.isDocument = We.isDirective = We.isComment = We.isText = We.isCDATA = We.isTag = We.Element = We.Document = We.CDATA = We.NodeWithChildren = We.ProcessingInstruction = We.Comment = We.Text = We.DataNode = We.Node = void 0;
var Rr = pa
  , Rg = function() {
    function e() {
        this.parent = null,
        this.prev = null,
        this.next = null,
        this.startIndex = null,
        this.endIndex = null
    }
    return Object.defineProperty(e.prototype, "parentNode", {
        get: function() {
            return this.parent
        },
        set: function(t) {
            this.parent = t
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(e.prototype, "previousSibling", {
        get: function() {
            return this.prev
        },
        set: function(t) {
            this.prev = t
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(e.prototype, "nextSibling", {
        get: function() {
            return this.next
        },
        set: function(t) {
            this.next = t
        },
        enumerable: !1,
        configurable: !0
    }),
    e.prototype.cloneNode = function(t) {
        return t === void 0 && (t = !1),
        Bg(this, t)
    }
    ,
    e
}();
We.Node = Rg;
var Kf = function(e) {
    as(t, e);
    function t(r) {
        var n = e.call(this) || this;
        return n.data = r,
        n
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
        get: function() {
            return this.data
        },
        set: function(r) {
            this.data = r
        },
        enumerable: !1,
        configurable: !0
    }),
    t
}(Rg);
We.DataNode = Kf;
var lx = function(e) {
    as(t, e);
    function t() {
        var r = e !== null && e.apply(this, arguments) || this;
        return r.type = Rr.ElementType.Text,
        r
    }
    return Object.defineProperty(t.prototype, "nodeType", {
        get: function() {
            return 3
        },
        enumerable: !1,
        configurable: !0
    }),
    t
}(Kf);
We.Text = lx;
var fx = function(e) {
    as(t, e);
    function t() {
        var r = e !== null && e.apply(this, arguments) || this;
        return r.type = Rr.ElementType.Comment,
        r
    }
    return Object.defineProperty(t.prototype, "nodeType", {
        get: function() {
            return 8
        },
        enumerable: !1,
        configurable: !0
    }),
    t
}(Kf);
We.Comment = fx;
var dx = function(e) {
    as(t, e);
    function t(r, n) {
        var i = e.call(this, n) || this;
        return i.name = r,
        i.type = Rr.ElementType.Directive,
        i
    }
    return Object.defineProperty(t.prototype, "nodeType", {
        get: function() {
            return 1
        },
        enumerable: !1,
        configurable: !0
    }),
    t
}(Kf);
We.ProcessingInstruction = dx;
var Gf = function(e) {
    as(t, e);
    function t(r) {
        var n = e.call(this) || this;
        return n.children = r,
        n
    }
    return Object.defineProperty(t.prototype, "firstChild", {
        get: function() {
            var r;
            return (r = this.children[0]) !== null && r !== void 0 ? r : null
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(t.prototype, "lastChild", {
        get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(t.prototype, "childNodes", {
        get: function() {
            return this.children
        },
        set: function(r) {
            this.children = r
        },
        enumerable: !1,
        configurable: !0
    }),
    t
}(Rg);
We.NodeWithChildren = Gf;
var hx = function(e) {
    as(t, e);
    function t() {
        var r = e !== null && e.apply(this, arguments) || this;
        return r.type = Rr.ElementType.CDATA,
        r
    }
    return Object.defineProperty(t.prototype, "nodeType", {
        get: function() {
            return 4
        },
        enumerable: !1,
        configurable: !0
    }),
    t
}(Gf);
We.CDATA = hx;
var px = function(e) {
    as(t, e);
    function t() {
        var r = e !== null && e.apply(this, arguments) || this;
        return r.type = Rr.ElementType.Root,
        r
    }
    return Object.defineProperty(t.prototype, "nodeType", {
        get: function() {
            return 9
        },
        enumerable: !1,
        configurable: !0
    }),
    t
}(Gf);
We.Document = px;
var gx = function(e) {
    as(t, e);
    function t(r, n, i, s) {
        i === void 0 && (i = []),
        s === void 0 && (s = r === "script" ? Rr.ElementType.Script : r === "style" ? Rr.ElementType.Style : Rr.ElementType.Tag);
        var o = e.call(this, i) || this;
        return o.name = r,
        o.attribs = n,
        o.type = s,
        o
    }
    return Object.defineProperty(t.prototype, "nodeType", {
        get: function() {
            return 1
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(t.prototype, "tagName", {
        get: function() {
            return this.name
        },
        set: function(r) {
            this.name = r
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(t.prototype, "attributes", {
        get: function() {
            var r = this;
            return Object.keys(this.attribs).map(function(n) {
                var i, s;
                return {
                    name: n,
                    value: r.attribs[n],
                    namespace: (i = r["x-attribsNamespace"]) === null || i === void 0 ? void 0 : i[n],
                    prefix: (s = r["x-attribsPrefix"]) === null || s === void 0 ? void 0 : s[n]
                }
            })
        },
        enumerable: !1,
        configurable: !0
    }),
    t
}(Gf);
We.Element = gx;
function mx(e) {
    return (0,
    Rr.isTag)(e)
}
We.isTag = mx;
function yx(e) {
    return e.type === Rr.ElementType.CDATA
}
We.isCDATA = yx;
function bx(e) {
    return e.type === Rr.ElementType.Text
}
We.isText = bx;
function wx(e) {
    return e.type === Rr.ElementType.Comment
}
We.isComment = wx;
function vx(e) {
    return e.type === Rr.ElementType.Directive
}
We.isDirective = vx;
function xx(e) {
    return e.type === Rr.ElementType.Root
}
We.isDocument = xx;
function mk(e) {
    return Object.prototype.hasOwnProperty.call(e, "children")
}
We.hasChildren = mk;
function Bg(e, t) {
    t === void 0 && (t = !1);
    var r;
    if (bx(e))
        r = new lx(e.data);
    else if (wx(e))
        r = new fx(e.data);
    else if (mx(e)) {
        var n = t ? m0(e.children) : []
          , i = new gx(e.name,Ja({}, e.attribs),n);
        n.forEach(function(u) {
            return u.parent = i
        }),
        e.namespace != null && (i.namespace = e.namespace),
        e["x-attribsNamespace"] && (i["x-attribsNamespace"] = Ja({}, e["x-attribsNamespace"])),
        e["x-attribsPrefix"] && (i["x-attribsPrefix"] = Ja({}, e["x-attribsPrefix"])),
        r = i
    } else if (yx(e)) {
        var n = t ? m0(e.children) : []
          , s = new hx(n);
        n.forEach(function(c) {
            return c.parent = s
        }),
        r = s
    } else if (xx(e)) {
        var n = t ? m0(e.children) : []
          , o = new px(n);
        n.forEach(function(c) {
            return c.parent = o
        }),
        e["x-mode"] && (o["x-mode"] = e["x-mode"]),
        r = o
    } else if (vx(e)) {
        var a = new dx(e.name,e.data);
        e["x-name"] != null && (a["x-name"] = e["x-name"],
        a["x-publicId"] = e["x-publicId"],
        a["x-systemId"] = e["x-systemId"]),
        r = a
    } else
        throw new Error("Not implemented yet: ".concat(e.type));
    return r.startIndex = e.startIndex,
    r.endIndex = e.endIndex,
    e.sourceCodeLocation != null && (r.sourceCodeLocation = e.sourceCodeLocation),
    r
}
We.cloneNode = Bg;
function m0(e) {
    for (var t = e.map(function(n) {
        return Bg(n, !0)
    }), r = 1; r < t.length; r++)
        t[r].prev = t[r - 1],
        t[r - 1].next = t[r];
    return t
}
(function(e) {
    var t = ke && ke.__createBinding || (Object.create ? function(a, u, c, l) {
        l === void 0 && (l = c);
        var p = Object.getOwnPropertyDescriptor(u, c);
        (!p || ("get"in p ? !u.__esModule : p.writable || p.configurable)) && (p = {
            enumerable: !0,
            get: function() {
                return u[c]
            }
        }),
        Object.defineProperty(a, l, p)
    }
    : function(a, u, c, l) {
        l === void 0 && (l = c),
        a[l] = u[c]
    }
    )
      , r = ke && ke.__exportStar || function(a, u) {
        for (var c in a)
            c !== "default" && !Object.prototype.hasOwnProperty.call(u, c) && t(u, a, c)
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.DomHandler = void 0;
    var n = pa
      , i = We;
    r(We, e);
    var s = {
        withStartIndices: !1,
        withEndIndices: !1,
        xmlMode: !1
    }
      , o = function() {
        function a(u, c, l) {
            this.dom = [],
            this.root = new i.Document(this.dom),
            this.done = !1,
            this.tagStack = [this.root],
            this.lastNode = null,
            this.parser = null,
            typeof c == "function" && (l = c,
            c = s),
            typeof u == "object" && (c = u,
            u = void 0),
            this.callback = u ?? null,
            this.options = c ?? s,
            this.elementCB = l ?? null
        }
        return a.prototype.onparserinit = function(u) {
            this.parser = u
        }
        ,
        a.prototype.onreset = function() {
            this.dom = [],
            this.root = new i.Document(this.dom),
            this.done = !1,
            this.tagStack = [this.root],
            this.lastNode = null,
            this.parser = null
        }
        ,
        a.prototype.onend = function() {
            this.done || (this.done = !0,
            this.parser = null,
            this.handleCallback(null))
        }
        ,
        a.prototype.onerror = function(u) {
            this.handleCallback(u)
        }
        ,
        a.prototype.onclosetag = function() {
            this.lastNode = null;
            var u = this.tagStack.pop();
            this.options.withEndIndices && (u.endIndex = this.parser.endIndex),
            this.elementCB && this.elementCB(u)
        }
        ,
        a.prototype.onopentag = function(u, c) {
            var l = this.options.xmlMode ? n.ElementType.Tag : void 0
              , p = new i.Element(u,c,void 0,l);
            this.addNode(p),
            this.tagStack.push(p)
        }
        ,
        a.prototype.ontext = function(u) {
            var c = this.lastNode;
            if (c && c.type === n.ElementType.Text)
                c.data += u,
                this.options.withEndIndices && (c.endIndex = this.parser.endIndex);
            else {
                var l = new i.Text(u);
                this.addNode(l),
                this.lastNode = l
            }
        }
        ,
        a.prototype.oncomment = function(u) {
            if (this.lastNode && this.lastNode.type === n.ElementType.Comment) {
                this.lastNode.data += u;
                return
            }
            var c = new i.Comment(u);
            this.addNode(c),
            this.lastNode = c
        }
        ,
        a.prototype.oncommentend = function() {
            this.lastNode = null
        }
        ,
        a.prototype.oncdatastart = function() {
            var u = new i.Text("")
              , c = new i.CDATA([u]);
            this.addNode(c),
            u.parent = c,
            this.lastNode = u
        }
        ,
        a.prototype.oncdataend = function() {
            this.lastNode = null
        }
        ,
        a.prototype.onprocessinginstruction = function(u, c) {
            var l = new i.ProcessingInstruction(u,c);
            this.addNode(l)
        }
        ,
        a.prototype.handleCallback = function(u) {
            if (typeof this.callback == "function")
                this.callback(u, this.dom);
            else if (u)
                throw u
        }
        ,
        a.prototype.addNode = function(u) {
            var c = this.tagStack[this.tagStack.length - 1]
              , l = c.children[c.children.length - 1];
            this.options.withStartIndices && (u.startIndex = this.parser.startIndex),
            this.options.withEndIndices && (u.endIndex = this.parser.endIndex),
            c.children.push(u),
            l && (u.prev = l,
            l.next = u),
            u.parent = c,
            this.lastNode = null
        }
        ,
        a
    }();
    e.DomHandler = o,
    e.default = o
}
)(mi);
var hl = {}
  , Yr = {}
  , sc = {}
  , Ex = {}
  , Hs = {}
  , Pg = {};
Object.defineProperty(Pg, "__esModule", {
    value: !0
});
function jc(e) {
    for (var t = 1; t < e.length; t++)
        e[t][0] += e[t - 1][0] + 1;
    return e
}
Pg.default = new Map(jc([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, {
    v: "&lt;",
    n: 8402,
    o: "&nvlt;"
}], [0, {
    v: "&equals;",
    n: 8421,
    o: "&bne;"
}], [0, {
    v: "&gt;",
    n: 8402,
    o: "&nvgt;"
}], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, {
    n: 106,
    o: "&fjlig;"
}], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, {
    v: "&MediumSpace;",
    n: 8202,
    o: "&ThickSpace;"
}], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, {
    v: "&rarrw;",
    n: 824,
    o: "&nrarrw;"
}], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, {
    v: "&part;",
    n: 824,
    o: "&npart;"
}], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, {
    v: "&ang;",
    n: 8402,
    o: "&nang;"
}], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, {
    v: "&cap;",
    n: 65024,
    o: "&caps;"
}], [0, {
    v: "&cup;",
    n: 65024,
    o: "&cups;"
}], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, {
    v: "&sim;",
    n: 8402,
    o: "&nvsim;"
}], [0, {
    v: "&backsim;",
    n: 817,
    o: "&race;"
}], [0, {
    v: "&ac;",
    n: 819,
    o: "&acE;"
}], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, {
    v: "&eqsim;",
    n: 824,
    o: "&nesim;"
}], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, {
    v: "&apid;",
    n: 824,
    o: "&napid;"
}], [0, "&backcong;"], [0, {
    v: "&asympeq;",
    n: 8402,
    o: "&nvap;"
}], [0, {
    v: "&bump;",
    n: 824,
    o: "&nbump;"
}], [0, {
    v: "&bumpe;",
    n: 824,
    o: "&nbumpe;"
}], [0, {
    v: "&doteq;",
    n: 824,
    o: "&nedot;"
}], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, {
    v: "&Congruent;",
    n: 8421,
    o: "&bnequiv;"
}], [0, "&nequiv;"], [1, {
    v: "&le;",
    n: 8402,
    o: "&nvle;"
}], [0, {
    v: "&ge;",
    n: 8402,
    o: "&nvge;"
}], [0, {
    v: "&lE;",
    n: 824,
    o: "&nlE;"
}], [0, {
    v: "&gE;",
    n: 824,
    o: "&ngE;"
}], [0, {
    v: "&lnE;",
    n: 65024,
    o: "&lvertneqq;"
}], [0, {
    v: "&gnE;",
    n: 65024,
    o: "&gvertneqq;"
}], [0, {
    v: "&ll;",
    n: new Map(jc([[824, "&nLtv;"], [7577, "&nLt;"]]))
}], [0, {
    v: "&gg;",
    n: new Map(jc([[824, "&nGtv;"], [7577, "&nGt;"]]))
}], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, {
    v: "&scsim;",
    n: 824,
    o: "&NotSucceedsTilde;"
}], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, {
    v: "&sub;",
    n: 8402,
    o: "&NotSubset;"
}], [0, {
    v: "&sup;",
    n: 8402,
    o: "&NotSuperset;"
}], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, {
    v: "&subne;",
    n: 65024,
    o: "&varsubsetneq;"
}], [0, {
    v: "&supne;",
    n: 65024,
    o: "&varsupsetneq;"
}], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, {
    v: "&sqsub;",
    n: 824,
    o: "&NotSquareSubset;"
}], [0, {
    v: "&sqsup;",
    n: 824,
    o: "&NotSquareSuperset;"
}], [0, "&sqsube;"], [0, "&sqsupe;"], [0, {
    v: "&sqcap;",
    n: 65024,
    o: "&sqcaps;"
}], [0, {
    v: "&sqcup;",
    n: 65024,
    o: "&sqcups;"
}], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, {
    v: "&LeftTriangleEqual;",
    n: 8402,
    o: "&nvltrie;"
}], [0, {
    v: "&RightTriangleEqual;",
    n: 8402,
    o: "&nvrtrie;"
}], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, {
    v: "&Ll;",
    n: 824,
    o: "&nLl;"
}], [0, {
    v: "&Gg;",
    n: 824,
    o: "&nGg;"
}], [0, {
    v: "&leg;",
    n: 65024,
    o: "&lesg;"
}], [0, {
    v: "&gel;",
    n: 65024,
    o: "&gesl;"
}], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, {
    v: "&isindot;",
    n: 824,
    o: "&notindot;"
}], [0, "&notinvc;"], [0, "&notinvb;"], [1, {
    v: "&isinE;",
    n: 824,
    o: "&notinE;"
}], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, {
    v: "&rarrc;",
    n: 824,
    o: "&nrarrc;"
}], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, {
    v: "&LeftTriangleBar;",
    n: 824,
    o: "&NotLeftTriangleBar;"
}], [0, {
    v: "&RightTriangleBar;",
    n: 824,
    o: "&NotRightTriangleBar;"
}], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, {
    v: "&congdot;",
    n: 824,
    o: "&ncongdot;"
}], [0, "&easter;"], [0, "&apacir;"], [0, {
    v: "&apE;",
    n: 824,
    o: "&napE;"
}], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, {
    v: "&leqslant;",
    n: 824,
    o: "&nleqslant;"
}], [0, {
    v: "&geqslant;",
    n: 824,
    o: "&ngeqslant;"
}], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, {
    v: "&LessLess;",
    n: 824,
    o: "&NotNestedLessLess;"
}], [0, {
    v: "&GreaterGreater;",
    n: 824,
    o: "&NotNestedGreaterGreater;"
}], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, {
    v: "&smte;",
    n: 65024,
    o: "&smtes;"
}], [0, {
    v: "&late;",
    n: 65024,
    o: "&lates;"
}], [0, "&bumpE;"], [0, {
    v: "&PrecedesEqual;",
    n: 824,
    o: "&NotPrecedesEqual;"
}], [0, {
    v: "&sce;",
    n: 824,
    o: "&NotSucceedsEqual;"
}], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, {
    v: "&subE;",
    n: 824,
    o: "&nsubE;"
}], [0, {
    v: "&supE;",
    n: 824,
    o: "&nsupE;"
}], [0, "&subsim;"], [0, "&supsim;"], [2, {
    v: "&subnE;",
    n: 65024,
    o: "&varsubsetneqq;"
}], [0, {
    v: "&supnE;",
    n: 65024,
    o: "&varsupsetneqq;"
}], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, {
    v: "&parsl;",
    n: 8421,
    o: "&nparsl;"
}], [44343, {
    n: new Map(jc([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]]))
}], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var Ql = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.escapeText = e.escapeAttribute = e.escapeUTF8 = e.escape = e.encodeXML = e.getCodePoint = e.xmlReplacer = void 0,
    e.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var t = new Map([[34, "&quot;"], [38, "&amp;"], [39, "&apos;"], [60, "&lt;"], [62, "&gt;"]]);
    e.getCodePoint = String.prototype.codePointAt != null ? function(i, s) {
        return i.codePointAt(s)
    }
    : function(i, s) {
        return (i.charCodeAt(s) & 64512) === 55296 ? (i.charCodeAt(s) - 55296) * 1024 + i.charCodeAt(s + 1) - 56320 + 65536 : i.charCodeAt(s)
    }
    ;
    function r(i) {
        for (var s = "", o = 0, a; (a = e.xmlReplacer.exec(i)) !== null; ) {
            var u = a.index
              , c = i.charCodeAt(u)
              , l = t.get(c);
            l !== void 0 ? (s += i.substring(o, u) + l,
            o = u + 1) : (s += "".concat(i.substring(o, u), "&#x").concat((0,
            e.getCodePoint)(i, u).toString(16), ";"),
            o = e.xmlReplacer.lastIndex += +((c & 64512) === 55296))
        }
        return s + i.substr(o)
    }
    e.encodeXML = r,
    e.escape = r;
    function n(i, s) {
        return function(a) {
            for (var u, c = 0, l = ""; u = i.exec(a); )
                c !== u.index && (l += a.substring(c, u.index)),
                l += s.get(u[0].charCodeAt(0)),
                c = u.index + 1;
            return l + a.substring(c)
        }
    }
    e.escapeUTF8 = n(/[&<>'"]/g, t),
    e.escapeAttribute = n(/["&\u00A0]/g, new Map([[34, "&quot;"], [38, "&amp;"], [160, "&nbsp;"]])),
    e.escapeText = n(/[&<>\u00A0]/g, new Map([[38, "&amp;"], [60, "&lt;"], [62, "&gt;"], [160, "&nbsp;"]]))
}
)(Ql);
var yk = ke && ke.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
;
Object.defineProperty(Hs, "__esModule", {
    value: !0
});
Hs.encodeNonAsciiHTML = Hs.encodeHTML = void 0;
var bk = yk(Pg)
  , Sx = Ql
  , wk = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function vk(e) {
    return _x(wk, e)
}
Hs.encodeHTML = vk;
function xk(e) {
    return _x(Sx.xmlReplacer, e)
}
Hs.encodeNonAsciiHTML = xk;
function _x(e, t) {
    for (var r = "", n = 0, i; (i = e.exec(t)) !== null; ) {
        var s = i.index;
        r += t.substring(n, s);
        var o = t.charCodeAt(s)
          , a = bk.default.get(o);
        if (typeof a == "object") {
            if (s + 1 < t.length) {
                var u = t.charCodeAt(s + 1)
                  , c = typeof a.n == "number" ? a.n === u ? a.o : void 0 : a.n.get(u);
                if (c !== void 0) {
                    r += c,
                    n = e.lastIndex += 1;
                    continue
                }
            }
            a = a.v
        }
        if (a !== void 0)
            r += a,
            n = s + 1;
        else {
            var l = (0,
            Sx.getCodePoint)(t, s);
            r += "&#x".concat(l.toString(16), ";"),
            n = e.lastIndex += +(l !== o)
        }
    }
    return r + t.substr(n)
}
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.decodeXMLStrict = e.decodeHTML5Strict = e.decodeHTML4Strict = e.decodeHTML5 = e.decodeHTML4 = e.decodeHTMLAttribute = e.decodeHTMLStrict = e.decodeHTML = e.decodeXML = e.DecodingMode = e.EntityDecoder = e.encodeHTML5 = e.encodeHTML4 = e.encodeNonAsciiHTML = e.encodeHTML = e.escapeText = e.escapeAttribute = e.escapeUTF8 = e.escape = e.encodeXML = e.encode = e.decodeStrict = e.decode = e.EncodingMode = e.EntityLevel = void 0;
    var t = gu, r = Hs, n = Ql, i;
    (function(h) {
        h[h.XML = 0] = "XML",
        h[h.HTML = 1] = "HTML"
    }
    )(i = e.EntityLevel || (e.EntityLevel = {}));
    var s;
    (function(h) {
        h[h.UTF8 = 0] = "UTF8",
        h[h.ASCII = 1] = "ASCII",
        h[h.Extensive = 2] = "Extensive",
        h[h.Attribute = 3] = "Attribute",
        h[h.Text = 4] = "Text"
    }
    )(s = e.EncodingMode || (e.EncodingMode = {}));
    function o(h, g) {
        g === void 0 && (g = i.XML);
        var S = typeof g == "number" ? g : g.level;
        if (S === i.HTML) {
            var x = typeof g == "object" ? g.mode : void 0;
            return (0,
            t.decodeHTML)(h, x)
        }
        return (0,
        t.decodeXML)(h)
    }
    e.decode = o;
    function a(h, g) {
        var S;
        g === void 0 && (g = i.XML);
        var x = typeof g == "number" ? {
            level: g
        } : g;
        return (S = x.mode) !== null && S !== void 0 || (x.mode = t.DecodingMode.Strict),
        o(h, x)
    }
    e.decodeStrict = a;
    function u(h, g) {
        g === void 0 && (g = i.XML);
        var S = typeof g == "number" ? {
            level: g
        } : g;
        return S.mode === s.UTF8 ? (0,
        n.escapeUTF8)(h) : S.mode === s.Attribute ? (0,
        n.escapeAttribute)(h) : S.mode === s.Text ? (0,
        n.escapeText)(h) : S.level === i.HTML ? S.mode === s.ASCII ? (0,
        r.encodeNonAsciiHTML)(h) : (0,
        r.encodeHTML)(h) : (0,
        n.encodeXML)(h)
    }
    e.encode = u;
    var c = Ql;
    Object.defineProperty(e, "encodeXML", {
        enumerable: !0,
        get: function() {
            return c.encodeXML
        }
    }),
    Object.defineProperty(e, "escape", {
        enumerable: !0,
        get: function() {
            return c.escape
        }
    }),
    Object.defineProperty(e, "escapeUTF8", {
        enumerable: !0,
        get: function() {
            return c.escapeUTF8
        }
    }),
    Object.defineProperty(e, "escapeAttribute", {
        enumerable: !0,
        get: function() {
            return c.escapeAttribute
        }
    }),
    Object.defineProperty(e, "escapeText", {
        enumerable: !0,
        get: function() {
            return c.escapeText
        }
    });
    var l = Hs;
    Object.defineProperty(e, "encodeHTML", {
        enumerable: !0,
        get: function() {
            return l.encodeHTML
        }
    }),
    Object.defineProperty(e, "encodeNonAsciiHTML", {
        enumerable: !0,
        get: function() {
            return l.encodeNonAsciiHTML
        }
    }),
    Object.defineProperty(e, "encodeHTML4", {
        enumerable: !0,
        get: function() {
            return l.encodeHTML
        }
    }),
    Object.defineProperty(e, "encodeHTML5", {
        enumerable: !0,
        get: function() {
            return l.encodeHTML
        }
    });
    var p = gu;
    Object.defineProperty(e, "EntityDecoder", {
        enumerable: !0,
        get: function() {
            return p.EntityDecoder
        }
    }),
    Object.defineProperty(e, "DecodingMode", {
        enumerable: !0,
        get: function() {
            return p.DecodingMode
        }
    }),
    Object.defineProperty(e, "decodeXML", {
        enumerable: !0,
        get: function() {
            return p.decodeXML
        }
    }),
    Object.defineProperty(e, "decodeHTML", {
        enumerable: !0,
        get: function() {
            return p.decodeHTML
        }
    }),
    Object.defineProperty(e, "decodeHTMLStrict", {
        enumerable: !0,
        get: function() {
            return p.decodeHTMLStrict
        }
    }),
    Object.defineProperty(e, "decodeHTMLAttribute", {
        enumerable: !0,
        get: function() {
            return p.decodeHTMLAttribute
        }
    }),
    Object.defineProperty(e, "decodeHTML4", {
        enumerable: !0,
        get: function() {
            return p.decodeHTML
        }
    }),
    Object.defineProperty(e, "decodeHTML5", {
        enumerable: !0,
        get: function() {
            return p.decodeHTML
        }
    }),
    Object.defineProperty(e, "decodeHTML4Strict", {
        enumerable: !0,
        get: function() {
            return p.decodeHTMLStrict
        }
    }),
    Object.defineProperty(e, "decodeHTML5Strict", {
        enumerable: !0,
        get: function() {
            return p.decodeHTMLStrict
        }
    }),
    Object.defineProperty(e, "decodeXMLStrict", {
        enumerable: !0,
        get: function() {
            return p.decodeXML
        }
    })
}
)(Ex);
var qo = {};
Object.defineProperty(qo, "__esModule", {
    value: !0
});
qo.attributeNames = qo.elementNames = void 0;
qo.elementNames = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map(function(e) {
    return [e.toLowerCase(), e]
}));
qo.attributeNames = new Map(["definitionURL", "attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map(function(e) {
    return [e.toLowerCase(), e]
}));
var po = ke && ke.__assign || function() {
    return po = Object.assign || function(e) {
        for (var t, r = 1, n = arguments.length; r < n; r++) {
            t = arguments[r];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
        }
        return e
    }
    ,
    po.apply(this, arguments)
}
  , Ek = ke && ke.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get"in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r]
        }
    }),
    Object.defineProperty(e, n, i)
}
: function(e, t, r, n) {
    n === void 0 && (n = r),
    e[n] = t[r]
}
)
  , Sk = ke && ke.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    })
}
: function(e, t) {
    e.default = t
}
)
  , _k = ke && ke.__importStar || function(e) {
    if (e && e.__esModule)
        return e;
    var t = {};
    if (e != null)
        for (var r in e)
            r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Ek(t, e, r);
    return Sk(t, e),
    t
}
;
Object.defineProperty(sc, "__esModule", {
    value: !0
});
sc.render = void 0;
var ti = _k(pa)
  , Yl = Ex
  , Ax = qo
  , Ak = new Set(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
function Mk(e) {
    return e.replace(/"/g, "&quot;")
}
function Ik(e, t) {
    var r;
    if (e) {
        var n = ((r = t.encodeEntities) !== null && r !== void 0 ? r : t.decodeEntities) === !1 ? Mk : t.xmlMode || t.encodeEntities !== "utf8" ? Yl.encodeXML : Yl.escapeAttribute;
        return Object.keys(e).map(function(i) {
            var s, o, a = (s = e[i]) !== null && s !== void 0 ? s : "";
            return t.xmlMode === "foreign" && (i = (o = Ax.attributeNames.get(i)) !== null && o !== void 0 ? o : i),
            !t.emptyAttrs && !t.xmlMode && a === "" ? i : "".concat(i, '="').concat(n(a), '"')
        }).join(" ")
    }
}
var jy = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
function Qf(e, t) {
    t === void 0 && (t = {});
    for (var r = ("length"in e) ? e : [e], n = "", i = 0; i < r.length; i++)
        n += Tk(r[i], t);
    return n
}
sc.render = Qf;
sc.default = Qf;
function Tk(e, t) {
    switch (e.type) {
    case ti.Root:
        return Qf(e.children, t);
    case ti.Doctype:
    case ti.Directive:
        return Ok(e);
    case ti.Comment:
        return Bk(e);
    case ti.CDATA:
        return Rk(e);
    case ti.Script:
    case ti.Style:
    case ti.Tag:
        return Lk(e, t);
    case ti.Text:
        return Nk(e, t)
    }
}
var Ck = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"])
  , kk = new Set(["svg", "math"]);
function Lk(e, t) {
    var r;
    t.xmlMode === "foreign" && (e.name = (r = Ax.elementNames.get(e.name)) !== null && r !== void 0 ? r : e.name,
    e.parent && Ck.has(e.parent.name) && (t = po(po({}, t), {
        xmlMode: !1
    }))),
    !t.xmlMode && kk.has(e.name) && (t = po(po({}, t), {
        xmlMode: "foreign"
    }));
    var n = "<".concat(e.name)
      , i = Ik(e.attribs, t);
    return i && (n += " ".concat(i)),
    e.children.length === 0 && (t.xmlMode ? t.selfClosingTags !== !1 : t.selfClosingTags && jy.has(e.name)) ? (t.xmlMode || (n += " "),
    n += "/>") : (n += ">",
    e.children.length > 0 && (n += Qf(e.children, t)),
    (t.xmlMode || !jy.has(e.name)) && (n += "</".concat(e.name, ">"))),
    n
}
function Ok(e) {
    return "<".concat(e.data, ">")
}
function Nk(e, t) {
    var r, n = e.data || "";
    return ((r = t.encodeEntities) !== null && r !== void 0 ? r : t.decodeEntities) !== !1 && !(!t.xmlMode && e.parent && Ak.has(e.parent.name)) && (n = t.xmlMode || t.encodeEntities !== "utf8" ? (0,
    Yl.encodeXML)(n) : (0,
    Yl.escapeText)(n)),
    n
}
function Rk(e) {
    return "<![CDATA[".concat(e.children[0].data, "]]>")
}
function Bk(e) {
    return "<!--".concat(e.data, "-->")
}
var Pk = ke && ke.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
;
Object.defineProperty(Yr, "__esModule", {
    value: !0
});
Yr.innerText = Yr.textContent = Yr.getText = Yr.getInnerHTML = Yr.getOuterHTML = void 0;
var Fn = mi
  , jk = Pk(sc)
  , Dk = pa;
function Mx(e, t) {
    return (0,
    jk.default)(e, t)
}
Yr.getOuterHTML = Mx;
function Uk(e, t) {
    return (0,
    Fn.hasChildren)(e) ? e.children.map(function(r) {
        return Mx(r, t)
    }).join("") : ""
}
Yr.getInnerHTML = Uk;
function pl(e) {
    return Array.isArray(e) ? e.map(pl).join("") : (0,
    Fn.isTag)(e) ? e.name === "br" ? `
` : pl(e.children) : (0,
    Fn.isCDATA)(e) ? pl(e.children) : (0,
    Fn.isText)(e) ? e.data : ""
}
Yr.getText = pl;
function Uh(e) {
    return Array.isArray(e) ? e.map(Uh).join("") : (0,
    Fn.hasChildren)(e) && !(0,
    Fn.isComment)(e) ? Uh(e.children) : (0,
    Fn.isText)(e) ? e.data : ""
}
Yr.textContent = Uh;
function zh(e) {
    return Array.isArray(e) ? e.map(zh).join("") : (0,
    Fn.hasChildren)(e) && (e.type === Dk.ElementType.Tag || (0,
    Fn.isCDATA)(e)) ? zh(e.children) : (0,
    Fn.isText)(e) ? e.data : ""
}
Yr.innerText = zh;
var er = {};
Object.defineProperty(er, "__esModule", {
    value: !0
});
er.prevElementSibling = er.nextElementSibling = er.getName = er.hasAttrib = er.getAttributeValue = er.getSiblings = er.getParent = er.getChildren = void 0;
var jg = mi;
function Ix(e) {
    return (0,
    jg.hasChildren)(e) ? e.children : []
}
er.getChildren = Ix;
function Tx(e) {
    return e.parent || null
}
er.getParent = Tx;
function zk(e) {
    var t, r, n = Tx(e);
    if (n != null)
        return Ix(n);
    for (var i = [e], s = e.prev, o = e.next; s != null; )
        i.unshift(s),
        t = s,
        s = t.prev;
    for (; o != null; )
        i.push(o),
        r = o,
        o = r.next;
    return i
}
er.getSiblings = zk;
function $k(e, t) {
    var r;
    return (r = e.attribs) === null || r === void 0 ? void 0 : r[t]
}
er.getAttributeValue = $k;
function Fk(e, t) {
    return e.attribs != null && Object.prototype.hasOwnProperty.call(e.attribs, t) && e.attribs[t] != null
}
er.hasAttrib = Fk;
function Hk(e) {
    return e.name
}
er.getName = Hk;
function qk(e) {
    for (var t, r = e.next; r !== null && !(0,
    jg.isTag)(r); )
        t = r,
        r = t.next;
    return r
}
er.nextElementSibling = qk;
function Wk(e) {
    for (var t, r = e.prev; r !== null && !(0,
    jg.isTag)(r); )
        t = r,
        r = t.prev;
    return r
}
er.prevElementSibling = Wk;
var Or = {};
Object.defineProperty(Or, "__esModule", {
    value: !0
});
Or.prepend = Or.prependChild = Or.append = Or.appendChild = Or.replaceElement = Or.removeElement = void 0;
function oc(e) {
    if (e.prev && (e.prev.next = e.next),
    e.next && (e.next.prev = e.prev),
    e.parent) {
        var t = e.parent.children
          , r = t.lastIndexOf(e);
        r >= 0 && t.splice(r, 1)
    }
    e.next = null,
    e.prev = null,
    e.parent = null
}
Or.removeElement = oc;
function Vk(e, t) {
    var r = t.prev = e.prev;
    r && (r.next = t);
    var n = t.next = e.next;
    n && (n.prev = t);
    var i = t.parent = e.parent;
    if (i) {
        var s = i.children;
        s[s.lastIndexOf(e)] = t,
        e.parent = null
    }
}
Or.replaceElement = Vk;
function Kk(e, t) {
    if (oc(t),
    t.next = null,
    t.parent = e,
    e.children.push(t) > 1) {
        var r = e.children[e.children.length - 2];
        r.next = t,
        t.prev = r
    } else
        t.prev = null
}
Or.appendChild = Kk;
function Gk(e, t) {
    oc(t);
    var r = e.parent
      , n = e.next;
    if (t.next = n,
    t.prev = e,
    e.next = t,
    t.parent = r,
    n) {
        if (n.prev = t,
        r) {
            var i = r.children;
            i.splice(i.lastIndexOf(n), 0, t)
        }
    } else
        r && r.children.push(t)
}
Or.append = Gk;
function Qk(e, t) {
    if (oc(t),
    t.parent = e,
    t.prev = null,
    e.children.unshift(t) !== 1) {
        var r = e.children[1];
        r.prev = t,
        t.next = r
    } else
        t.next = null
}
Or.prependChild = Qk;
function Yk(e, t) {
    oc(t);
    var r = e.parent;
    if (r) {
        var n = r.children;
        n.splice(n.indexOf(e), 0, t)
    }
    e.prev && (e.prev.next = t),
    t.parent = r,
    t.prev = e.prev,
    t.next = e,
    e.prev = t
}
Or.prepend = Yk;
var _r = {};
Object.defineProperty(_r, "__esModule", {
    value: !0
});
_r.findAll = _r.existsOne = _r.findOne = _r.findOneChild = _r.find = _r.filter = void 0;
var Yf = mi;
function Zk(e, t, r, n) {
    return r === void 0 && (r = !0),
    n === void 0 && (n = 1 / 0),
    Cx(e, Array.isArray(t) ? t : [t], r, n)
}
_r.filter = Zk;
function Cx(e, t, r, n) {
    for (var i = [], s = [t], o = [0]; ; ) {
        if (o[0] >= s[0].length) {
            if (o.length === 1)
                return i;
            s.shift(),
            o.shift();
            continue
        }
        var a = s[0][o[0]++];
        if (e(a) && (i.push(a),
        --n <= 0))
            return i;
        r && (0,
        Yf.hasChildren)(a) && a.children.length > 0 && (o.unshift(0),
        s.unshift(a.children))
    }
}
_r.find = Cx;
function Jk(e, t) {
    return t.find(e)
}
_r.findOneChild = Jk;
function kx(e, t, r) {
    r === void 0 && (r = !0);
    for (var n = null, i = 0; i < t.length && !n; i++) {
        var s = t[i];
        if ((0,
        Yf.isTag)(s))
            e(s) ? n = s : r && s.children.length > 0 && (n = kx(e, s.children, !0));
        else
            continue
    }
    return n
}
_r.findOne = kx;
function Lx(e, t) {
    return t.some(function(r) {
        return (0,
        Yf.isTag)(r) && (e(r) || Lx(e, r.children))
    })
}
_r.existsOne = Lx;
function Xk(e, t) {
    for (var r = [], n = [t], i = [0]; ; ) {
        if (i[0] >= n[0].length) {
            if (n.length === 1)
                return r;
            n.shift(),
            i.shift();
            continue
        }
        var s = n[0][i[0]++];
        (0,
        Yf.isTag)(s) && (e(s) && r.push(s),
        s.children.length > 0 && (i.unshift(0),
        n.unshift(s.children)))
    }
}
_r.findAll = Xk;
var Zr = {};
Object.defineProperty(Zr, "__esModule", {
    value: !0
});
Zr.getElementsByTagType = Zr.getElementsByTagName = Zr.getElementById = Zr.getElements = Zr.testElement = void 0;
var bs = mi
  , Zf = _r
  , Zl = {
    tag_name: function(e) {
        return typeof e == "function" ? function(t) {
            return (0,
            bs.isTag)(t) && e(t.name)
        }
        : e === "*" ? bs.isTag : function(t) {
            return (0,
            bs.isTag)(t) && t.name === e
        }
    },
    tag_type: function(e) {
        return typeof e == "function" ? function(t) {
            return e(t.type)
        }
        : function(t) {
            return t.type === e
        }
    },
    tag_contains: function(e) {
        return typeof e == "function" ? function(t) {
            return (0,
            bs.isText)(t) && e(t.data)
        }
        : function(t) {
            return (0,
            bs.isText)(t) && t.data === e
        }
    }
};
function Ox(e, t) {
    return typeof t == "function" ? function(r) {
        return (0,
        bs.isTag)(r) && t(r.attribs[e])
    }
    : function(r) {
        return (0,
        bs.isTag)(r) && r.attribs[e] === t
    }
}
function eL(e, t) {
    return function(r) {
        return e(r) || t(r)
    }
}
function Nx(e) {
    var t = Object.keys(e).map(function(r) {
        var n = e[r];
        return Object.prototype.hasOwnProperty.call(Zl, r) ? Zl[r](n) : Ox(r, n)
    });
    return t.length === 0 ? null : t.reduce(eL)
}
function tL(e, t) {
    var r = Nx(e);
    return r ? r(t) : !0
}
Zr.testElement = tL;
function rL(e, t, r, n) {
    n === void 0 && (n = 1 / 0);
    var i = Nx(e);
    return i ? (0,
    Zf.filter)(i, t, r, n) : []
}
Zr.getElements = rL;
function nL(e, t, r) {
    return r === void 0 && (r = !0),
    Array.isArray(t) || (t = [t]),
    (0,
    Zf.findOne)(Ox("id", e), t, r)
}
Zr.getElementById = nL;
function iL(e, t, r, n) {
    return r === void 0 && (r = !0),
    n === void 0 && (n = 1 / 0),
    (0,
    Zf.filter)(Zl.tag_name(e), t, r, n)
}
Zr.getElementsByTagName = iL;
function sL(e, t, r, n) {
    return r === void 0 && (r = !0),
    n === void 0 && (n = 1 / 0),
    (0,
    Zf.filter)(Zl.tag_type(e), t, r, n)
}
Zr.getElementsByTagType = sL;
var Rx = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.uniqueSort = e.compareDocumentPosition = e.DocumentPosition = e.removeSubsets = void 0;
    var t = mi;
    function r(o) {
        for (var a = o.length; --a >= 0; ) {
            var u = o[a];
            if (a > 0 && o.lastIndexOf(u, a - 1) >= 0) {
                o.splice(a, 1);
                continue
            }
            for (var c = u.parent; c; c = c.parent)
                if (o.includes(c)) {
                    o.splice(a, 1);
                    break
                }
        }
        return o
    }
    e.removeSubsets = r;
    var n;
    (function(o) {
        o[o.DISCONNECTED = 1] = "DISCONNECTED",
        o[o.PRECEDING = 2] = "PRECEDING",
        o[o.FOLLOWING = 4] = "FOLLOWING",
        o[o.CONTAINS = 8] = "CONTAINS",
        o[o.CONTAINED_BY = 16] = "CONTAINED_BY"
    }
    )(n = e.DocumentPosition || (e.DocumentPosition = {}));
    function i(o, a) {
        var u = []
          , c = [];
        if (o === a)
            return 0;
        for (var l = (0,
        t.hasChildren)(o) ? o : o.parent; l; )
            u.unshift(l),
            l = l.parent;
        for (l = (0,
        t.hasChildren)(a) ? a : a.parent; l; )
            c.unshift(l),
            l = l.parent;
        for (var p = Math.min(u.length, c.length), h = 0; h < p && u[h] === c[h]; )
            h++;
        if (h === 0)
            return n.DISCONNECTED;
        var g = u[h - 1]
          , S = g.children
          , x = u[h]
          , v = c[h];
        return S.indexOf(x) > S.indexOf(v) ? g === a ? n.FOLLOWING | n.CONTAINED_BY : n.FOLLOWING : g === o ? n.PRECEDING | n.CONTAINS : n.PRECEDING
    }
    e.compareDocumentPosition = i;
    function s(o) {
        return o = o.filter(function(a, u, c) {
            return !c.includes(a, u + 1)
        }),
        o.sort(function(a, u) {
            var c = i(a, u);
            return c & n.PRECEDING ? -1 : c & n.FOLLOWING ? 1 : 0
        }),
        o
    }
    e.uniqueSort = s
}
)(Rx);
var Jf = {};
Object.defineProperty(Jf, "__esModule", {
    value: !0
});
Jf.getFeed = void 0;
var oL = Yr
  , ac = Zr;
function aL(e) {
    var t = Jl(dL, e);
    return t ? t.name === "feed" ? uL(t) : cL(t) : null
}
Jf.getFeed = aL;
function uL(e) {
    var t, r = e.children, n = {
        type: "atom",
        items: (0,
        ac.getElementsByTagName)("entry", r).map(function(o) {
            var a, u = o.children, c = {
                media: Bx(u)
            };
            Lr(c, "id", "id", u),
            Lr(c, "title", "title", u);
            var l = (a = Jl("link", u)) === null || a === void 0 ? void 0 : a.attribs.href;
            l && (c.link = l);
            var p = Vi("summary", u) || Vi("content", u);
            p && (c.description = p);
            var h = Vi("updated", u);
            return h && (c.pubDate = new Date(h)),
            c
        })
    };
    Lr(n, "id", "id", r),
    Lr(n, "title", "title", r);
    var i = (t = Jl("link", r)) === null || t === void 0 ? void 0 : t.attribs.href;
    i && (n.link = i),
    Lr(n, "description", "subtitle", r);
    var s = Vi("updated", r);
    return s && (n.updated = new Date(s)),
    Lr(n, "author", "email", r, !0),
    n
}
function cL(e) {
    var t, r, n = (r = (t = Jl("channel", e.children)) === null || t === void 0 ? void 0 : t.children) !== null && r !== void 0 ? r : [], i = {
        type: e.name.substr(0, 3),
        id: "",
        items: (0,
        ac.getElementsByTagName)("item", e.children).map(function(o) {
            var a = o.children
              , u = {
                media: Bx(a)
            };
            Lr(u, "id", "guid", a),
            Lr(u, "title", "title", a),
            Lr(u, "link", "link", a),
            Lr(u, "description", "description", a);
            var c = Vi("pubDate", a) || Vi("dc:date", a);
            return c && (u.pubDate = new Date(c)),
            u
        })
    };
    Lr(i, "title", "title", n),
    Lr(i, "link", "link", n),
    Lr(i, "description", "description", n);
    var s = Vi("lastBuildDate", n);
    return s && (i.updated = new Date(s)),
    Lr(i, "author", "managingEditor", n, !0),
    i
}
var lL = ["url", "type", "lang"]
  , fL = ["fileSize", "bitrate", "framerate", "samplingrate", "channels", "duration", "height", "width"];
function Bx(e) {
    return (0,
    ac.getElementsByTagName)("media:content", e).map(function(t) {
        for (var r = t.attribs, n = {
            medium: r.medium,
            isDefault: !!r.isDefault
        }, i = 0, s = lL; i < s.length; i++) {
            var o = s[i];
            r[o] && (n[o] = r[o])
        }
        for (var a = 0, u = fL; a < u.length; a++) {
            var o = u[a];
            r[o] && (n[o] = parseInt(r[o], 10))
        }
        return r.expression && (n.expression = r.expression),
        n
    })
}
function Jl(e, t) {
    return (0,
    ac.getElementsByTagName)(e, t, !0, 1)[0]
}
function Vi(e, t, r) {
    return r === void 0 && (r = !1),
    (0,
    oL.textContent)((0,
    ac.getElementsByTagName)(e, t, r, 1)).trim()
}
function Lr(e, t, r, n, i) {
    i === void 0 && (i = !1);
    var s = Vi(r, n, i);
    s && (e[t] = s)
}
function dL(e) {
    return e === "rss" || e === "feed" || e === "rdf:RDF"
}
(function(e) {
    var t = ke && ke.__createBinding || (Object.create ? function(i, s, o, a) {
        a === void 0 && (a = o);
        var u = Object.getOwnPropertyDescriptor(s, o);
        (!u || ("get"in u ? !s.__esModule : u.writable || u.configurable)) && (u = {
            enumerable: !0,
            get: function() {
                return s[o]
            }
        }),
        Object.defineProperty(i, a, u)
    }
    : function(i, s, o, a) {
        a === void 0 && (a = o),
        i[a] = s[o]
    }
    )
      , r = ke && ke.__exportStar || function(i, s) {
        for (var o in i)
            o !== "default" && !Object.prototype.hasOwnProperty.call(s, o) && t(s, i, o)
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.hasChildren = e.isDocument = e.isComment = e.isText = e.isCDATA = e.isTag = void 0,
    r(Yr, e),
    r(er, e),
    r(Or, e),
    r(_r, e),
    r(Zr, e),
    r(Rx, e),
    r(Jf, e);
    var n = mi;
    Object.defineProperty(e, "isTag", {
        enumerable: !0,
        get: function() {
            return n.isTag
        }
    }),
    Object.defineProperty(e, "isCDATA", {
        enumerable: !0,
        get: function() {
            return n.isCDATA
        }
    }),
    Object.defineProperty(e, "isText", {
        enumerable: !0,
        get: function() {
            return n.isText
        }
    }),
    Object.defineProperty(e, "isComment", {
        enumerable: !0,
        get: function() {
            return n.isComment
        }
    }),
    Object.defineProperty(e, "isDocument", {
        enumerable: !0,
        get: function() {
            return n.isDocument
        }
    }),
    Object.defineProperty(e, "hasChildren", {
        enumerable: !0,
        get: function() {
            return n.hasChildren
        }
    })
}
)(hl);
(function(e) {
    var t = ke && ke.__createBinding || (Object.create ? function(I, M, A, k) {
        k === void 0 && (k = A);
        var L = Object.getOwnPropertyDescriptor(M, A);
        (!L || ("get"in L ? !M.__esModule : L.writable || L.configurable)) && (L = {
            enumerable: !0,
            get: function() {
                return M[A]
            }
        }),
        Object.defineProperty(I, k, L)
    }
    : function(I, M, A, k) {
        k === void 0 && (k = A),
        I[k] = M[A]
    }
    )
      , r = ke && ke.__setModuleDefault || (Object.create ? function(I, M) {
        Object.defineProperty(I, "default", {
            enumerable: !0,
            value: M
        })
    }
    : function(I, M) {
        I.default = M
    }
    )
      , n = ke && ke.__importStar || function(I) {
        if (I && I.__esModule)
            return I;
        var M = {};
        if (I != null)
            for (var A in I)
                A !== "default" && Object.prototype.hasOwnProperty.call(I, A) && t(M, I, A);
        return r(M, I),
        M
    }
      , i = ke && ke.__importDefault || function(I) {
        return I && I.__esModule ? I : {
            default: I
        }
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.DomUtils = e.parseFeed = e.getFeed = e.ElementType = e.Tokenizer = e.createDomStream = e.parseDOM = e.parseDocument = e.DefaultHandler = e.DomHandler = e.Parser = void 0;
    var s = pu
      , o = pu;
    Object.defineProperty(e, "Parser", {
        enumerable: !0,
        get: function() {
            return o.Parser
        }
    });
    var a = mi
      , u = mi;
    Object.defineProperty(e, "DomHandler", {
        enumerable: !0,
        get: function() {
            return u.DomHandler
        }
    }),
    Object.defineProperty(e, "DefaultHandler", {
        enumerable: !0,
        get: function() {
            return u.DomHandler
        }
    });
    function c(I, M) {
        var A = new a.DomHandler(void 0,M);
        return new s.Parser(A,M).end(I),
        A.root
    }
    e.parseDocument = c;
    function l(I, M) {
        return c(I, M).children
    }
    e.parseDOM = l;
    function p(I, M, A) {
        var k = new a.DomHandler(I,M,A);
        return new s.Parser(k,M)
    }
    e.createDomStream = p;
    var h = Lg;
    Object.defineProperty(e, "Tokenizer", {
        enumerable: !0,
        get: function() {
            return i(h).default
        }
    }),
    e.ElementType = n(pa);
    var g = hl
      , S = hl;
    Object.defineProperty(e, "getFeed", {
        enumerable: !0,
        get: function() {
            return S.getFeed
        }
    });
    var x = {
        xmlMode: !0
    };
    function v(I, M) {
        return M === void 0 && (M = x),
        (0,
        g.getFeed)(l(I, M))
    }
    e.parseFeed = v,
    e.DomUtils = n(hl)
}
)(cx);
var hL = e => {
    if (typeof e != "string")
        throw new TypeError("Expected a string");
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
}
  , Dg = {};
Object.defineProperty(Dg, "__esModule", {
    value: !0
});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Dy(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}
function pL(e) {
    var t, r;
    return Dy(e) === !1 ? !1 : (t = e.constructor,
    t === void 0 ? !0 : (r = t.prototype,
    !(Dy(r) === !1 || r.hasOwnProperty("isPrototypeOf") === !1)))
}
Dg.isPlainObject = pL;
var gL = function(t) {
    return mL(t) && !yL(t)
};
function mL(e) {
    return !!e && typeof e == "object"
}
function yL(e) {
    var t = Object.prototype.toString.call(e);
    return t === "[object RegExp]" || t === "[object Date]" || vL(e)
}
var bL = typeof Symbol == "function" && Symbol.for
  , wL = bL ? Symbol.for("react.element") : 60103;
function vL(e) {
    return e.$$typeof === wL
}
function xL(e) {
    return Array.isArray(e) ? [] : {}
}
function mu(e, t) {
    return t.clone !== !1 && t.isMergeableObject(e) ? Wo(xL(e), e, t) : e
}
function EL(e, t, r) {
    return e.concat(t).map(function(n) {
        return mu(n, r)
    })
}
function SL(e, t) {
    if (!t.customMerge)
        return Wo;
    var r = t.customMerge(e);
    return typeof r == "function" ? r : Wo
}
function _L(e) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e).filter(function(t) {
        return Object.propertyIsEnumerable.call(e, t)
    }) : []
}
function Uy(e) {
    return Object.keys(e).concat(_L(e))
}
function Px(e, t) {
    try {
        return t in e
    } catch {
        return !1
    }
}
function AL(e, t) {
    return Px(e, t) && !(Object.hasOwnProperty.call(e, t) && Object.propertyIsEnumerable.call(e, t))
}
function ML(e, t, r) {
    var n = {};
    return r.isMergeableObject(e) && Uy(e).forEach(function(i) {
        n[i] = mu(e[i], r)
    }),
    Uy(t).forEach(function(i) {
        AL(e, i) || (Px(e, i) && r.isMergeableObject(t[i]) ? n[i] = SL(i, r)(e[i], t[i], r) : n[i] = mu(t[i], r))
    }),
    n
}
function Wo(e, t, r) {
    r = r || {},
    r.arrayMerge = r.arrayMerge || EL,
    r.isMergeableObject = r.isMergeableObject || gL,
    r.cloneUnlessOtherwiseSpecified = mu;
    var n = Array.isArray(t)
      , i = Array.isArray(e)
      , s = n === i;
    return s ? n ? r.arrayMerge(e, t, r) : ML(e, t, r) : mu(t, r)
}
Wo.all = function(t, r) {
    if (!Array.isArray(t))
        throw new Error("first argument should be an array");
    return t.reduce(function(n, i) {
        return Wo(n, i, r)
    }, {})
}
;
var IL = Wo
  , TL = IL
  , jx = {
    exports: {}
};
(function(e) {
    (function(t, r) {
        e.exports ? e.exports = r() : t.parseSrcset = r()
    }
    )(ke, function() {
        return function(t) {
            function r(k) {
                return k === " " || k === "	" || k === `
` || k === "\f" || k === "\r"
            }
            function n(k) {
                var L, O = k.exec(t.substring(v));
                if (O)
                    return L = O[0],
                    v += L.length,
                    L
            }
            for (var i = t.length, s = /^[ \t\n\r\u000c]+/, o = /^[, \t\n\r\u000c]+/, a = /^[^ \t\n\r\u000c]+/, u = /[,]+$/, c = /^\d+$/, l = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, p, h, g, S, x, v = 0, I = []; ; ) {
                if (n(o),
                v >= i)
                    return I;
                p = n(a),
                h = [],
                p.slice(-1) === "," ? (p = p.replace(u, ""),
                A()) : M()
            }
            function M() {
                for (n(s),
                g = "",
                S = "in descriptor"; ; ) {
                    if (x = t.charAt(v),
                    S === "in descriptor")
                        if (r(x))
                            g && (h.push(g),
                            g = "",
                            S = "after descriptor");
                        else if (x === ",") {
                            v += 1,
                            g && h.push(g),
                            A();
                            return
                        } else if (x === "(")
                            g = g + x,
                            S = "in parens";
                        else if (x === "") {
                            g && h.push(g),
                            A();
                            return
                        } else
                            g = g + x;
                    else if (S === "in parens")
                        if (x === ")")
                            g = g + x,
                            S = "in descriptor";
                        else if (x === "") {
                            h.push(g),
                            A();
                            return
                        } else
                            g = g + x;
                    else if (S === "after descriptor" && !r(x))
                        if (x === "") {
                            A();
                            return
                        } else
                            S = "in descriptor",
                            v -= 1;
                    v += 1
                }
            }
            function A() {
                var k = !1, L, O, $, D, K = {}, G, F, q, B, y;
                for (D = 0; D < h.length; D++)
                    G = h[D],
                    F = G[G.length - 1],
                    q = G.substring(0, G.length - 1),
                    B = parseInt(q, 10),
                    y = parseFloat(q),
                    c.test(q) && F === "w" ? ((L || O) && (k = !0),
                    B === 0 ? k = !0 : L = B) : l.test(q) && F === "x" ? ((L || O || $) && (k = !0),
                    y < 0 ? k = !0 : O = y) : c.test(q) && F === "h" ? (($ || O) && (k = !0),
                    B === 0 ? k = !0 : $ = B) : k = !0;
                k ? console && console.log && console.log("Invalid srcset descriptor found in '" + t + "' at '" + G + "'.") : (K.url = p,
                L && (K.w = L),
                O && (K.d = O),
                $ && (K.h = $),
                I.push(K))
            }
        }
    })
}
)(jx);
var CL = jx.exports
  , Ug = {
    exports: {}
}
  , ht = String
  , Dx = function() {
    return {
        isColorSupported: !1,
        reset: ht,
        bold: ht,
        dim: ht,
        italic: ht,
        underline: ht,
        inverse: ht,
        hidden: ht,
        strikethrough: ht,
        black: ht,
        red: ht,
        green: ht,
        yellow: ht,
        blue: ht,
        magenta: ht,
        cyan: ht,
        white: ht,
        gray: ht,
        bgBlack: ht,
        bgRed: ht,
        bgGreen: ht,
        bgYellow: ht,
        bgBlue: ht,
        bgMagenta: ht,
        bgCyan: ht,
        bgWhite: ht
    }
};
Ug.exports = Dx();
Ug.exports.createColors = Dx;
var kL = Ug.exports;
const LL = {}
  , OL = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: LL
}, Symbol.toStringTag, {
    value: "Module"
}))
  , mn = kg(OL);
let zy = kL
  , $y = mn
  , $h = class Ux extends Error {
    constructor(t, r, n, i, s, o) {
        super(t),
        this.name = "CssSyntaxError",
        this.reason = t,
        s && (this.file = s),
        i && (this.source = i),
        o && (this.plugin = o),
        typeof r < "u" && typeof n < "u" && (typeof r == "number" ? (this.line = r,
        this.column = n) : (this.line = r.line,
        this.column = r.column,
        this.endLine = n.line,
        this.endColumn = n.column)),
        this.setMessage(),
        Error.captureStackTrace && Error.captureStackTrace(this, Ux)
    }
    setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "",
        this.message += this.file ? this.file : "<css input>",
        typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column),
        this.message += ": " + this.reason
    }
    showSourceCode(t) {
        if (!this.source)
            return "";
        let r = this.source;
        t == null && (t = zy.isColorSupported),
        $y && t && (r = $y(r));
        let n = r.split(/\r?\n/), i = Math.max(this.line - 3, 0), s = Math.min(this.line + 2, n.length), o = String(s).length, a, u;
        if (t) {
            let {bold: c, gray: l, red: p} = zy.createColors(!0);
            a = h => c(p(h)),
            u = h => l(h)
        } else
            a = u = c => c;
        return n.slice(i, s).map( (c, l) => {
            let p = i + 1 + l
              , h = " " + (" " + p).slice(-o) + " | ";
            if (p === this.line) {
                let g = u(h.replace(/\d/g, " ")) + c.slice(0, this.column - 1).replace(/[^\t]/g, " ");
                return a(">") + u(h) + c + `
 ` + g + a("^")
            }
            return " " + u(h) + c
        }
        ).join(`
`)
    }
    toString() {
        let t = this.showSourceCode();
        return t && (t = `

` + t + `
`),
        this.name + ": " + this.message + t
    }
}
;
var zg = $h;
$h.default = $h;
var uc = {};
uc.isClean = Symbol("isClean");
uc.my = Symbol("my");
const Fy = {
    after: `
`,
    beforeClose: `
`,
    beforeComment: `
`,
    beforeDecl: `
`,
    beforeOpen: " ",
    beforeRule: `
`,
    colon: ": ",
    commentLeft: " ",
    commentRight: " ",
    emptyBody: "",
    indent: "    ",
    semicolon: !1
};
function NL(e) {
    return e[0].toUpperCase() + e.slice(1)
}
let Fh = class {
    constructor(t) {
        this.builder = t
    }
    atrule(t, r) {
        let n = "@" + t.name
          , i = t.params ? this.rawValue(t, "params") : "";
        if (typeof t.raws.afterName < "u" ? n += t.raws.afterName : i && (n += " "),
        t.nodes)
            this.block(t, n + i);
        else {
            let s = (t.raws.between || "") + (r ? ";" : "");
            this.builder(n + i + s, t)
        }
    }
    beforeAfter(t, r) {
        let n;
        t.type === "decl" ? n = this.raw(t, null, "beforeDecl") : t.type === "comment" ? n = this.raw(t, null, "beforeComment") : r === "before" ? n = this.raw(t, null, "beforeRule") : n = this.raw(t, null, "beforeClose");
        let i = t.parent
          , s = 0;
        for (; i && i.type !== "root"; )
            s += 1,
            i = i.parent;
        if (n.includes(`
`)) {
            let o = this.raw(t, null, "indent");
            if (o.length)
                for (let a = 0; a < s; a++)
                    n += o
        }
        return n
    }
    block(t, r) {
        let n = this.raw(t, "between", "beforeOpen");
        this.builder(r + n + "{", t, "start");
        let i;
        t.nodes && t.nodes.length ? (this.body(t),
        i = this.raw(t, "after")) : i = this.raw(t, "after", "emptyBody"),
        i && this.builder(i),
        this.builder("}", t, "end")
    }
    body(t) {
        let r = t.nodes.length - 1;
        for (; r > 0 && t.nodes[r].type === "comment"; )
            r -= 1;
        let n = this.raw(t, "semicolon");
        for (let i = 0; i < t.nodes.length; i++) {
            let s = t.nodes[i]
              , o = this.raw(s, "before");
            o && this.builder(o),
            this.stringify(s, r !== i || n)
        }
    }
    comment(t) {
        let r = this.raw(t, "left", "commentLeft")
          , n = this.raw(t, "right", "commentRight");
        this.builder("/*" + r + t.text + n + "*/", t)
    }
    decl(t, r) {
        let n = this.raw(t, "between", "colon")
          , i = t.prop + n + this.rawValue(t, "value");
        t.important && (i += t.raws.important || " !important"),
        r && (i += ";"),
        this.builder(i, t)
    }
    document(t) {
        this.body(t)
    }
    raw(t, r, n) {
        let i;
        if (n || (n = r),
        r && (i = t.raws[r],
        typeof i < "u"))
            return i;
        let s = t.parent;
        if (n === "before" && (!s || s.type === "root" && s.first === t || s && s.type === "document"))
            return "";
        if (!s)
            return Fy[n];
        let o = t.root();
        if (o.rawCache || (o.rawCache = {}),
        typeof o.rawCache[n] < "u")
            return o.rawCache[n];
        if (n === "before" || n === "after")
            return this.beforeAfter(t, n);
        {
            let a = "raw" + NL(n);
            this[a] ? i = this[a](o, t) : o.walk(u => {
                if (i = u.raws[r],
                typeof i < "u")
                    return !1
            }
            )
        }
        return typeof i > "u" && (i = Fy[n]),
        o.rawCache[n] = i,
        i
    }
    rawBeforeClose(t) {
        let r;
        return t.walk(n => {
            if (n.nodes && n.nodes.length > 0 && typeof n.raws.after < "u")
                return r = n.raws.after,
                r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")),
                !1
        }
        ),
        r && (r = r.replace(/\S/g, "")),
        r
    }
    rawBeforeComment(t, r) {
        let n;
        return t.walkComments(i => {
            if (typeof i.raws.before < "u")
                return n = i.raws.before,
                n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")),
                !1
        }
        ),
        typeof n > "u" ? n = this.raw(r, null, "beforeDecl") : n && (n = n.replace(/\S/g, "")),
        n
    }
    rawBeforeDecl(t, r) {
        let n;
        return t.walkDecls(i => {
            if (typeof i.raws.before < "u")
                return n = i.raws.before,
                n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")),
                !1
        }
        ),
        typeof n > "u" ? n = this.raw(r, null, "beforeRule") : n && (n = n.replace(/\S/g, "")),
        n
    }
    rawBeforeOpen(t) {
        let r;
        return t.walk(n => {
            if (n.type !== "decl" && (r = n.raws.between,
            typeof r < "u"))
                return !1
        }
        ),
        r
    }
    rawBeforeRule(t) {
        let r;
        return t.walk(n => {
            if (n.nodes && (n.parent !== t || t.first !== n) && typeof n.raws.before < "u")
                return r = n.raws.before,
                r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")),
                !1
        }
        ),
        r && (r = r.replace(/\S/g, "")),
        r
    }
    rawColon(t) {
        let r;
        return t.walkDecls(n => {
            if (typeof n.raws.between < "u")
                return r = n.raws.between.replace(/[^\s:]/g, ""),
                !1
        }
        ),
        r
    }
    rawEmptyBody(t) {
        let r;
        return t.walk(n => {
            if (n.nodes && n.nodes.length === 0 && (r = n.raws.after,
            typeof r < "u"))
                return !1
        }
        ),
        r
    }
    rawIndent(t) {
        if (t.raws.indent)
            return t.raws.indent;
        let r;
        return t.walk(n => {
            let i = n.parent;
            if (i && i !== t && i.parent && i.parent === t && typeof n.raws.before < "u") {
                let s = n.raws.before.split(`
`);
                return r = s[s.length - 1],
                r = r.replace(/\S/g, ""),
                !1
            }
        }
        ),
        r
    }
    rawSemicolon(t) {
        let r;
        return t.walk(n => {
            if (n.nodes && n.nodes.length && n.last.type === "decl" && (r = n.raws.semicolon,
            typeof r < "u"))
                return !1
        }
        ),
        r
    }
    rawValue(t, r) {
        let n = t[r]
          , i = t.raws[r];
        return i && i.value === n ? i.raw : n
    }
    root(t) {
        this.body(t),
        t.raws.after && this.builder(t.raws.after)
    }
    rule(t) {
        this.block(t, this.rawValue(t, "selector")),
        t.raws.ownSemicolon && this.builder(t.raws.ownSemicolon, t, "end")
    }
    stringify(t, r) {
        if (!this[t.type])
            throw new Error("Unknown AST node type " + t.type + ". Maybe you need to change PostCSS stringifier.");
        this[t.type](t, r)
    }
}
;
var zx = Fh;
Fh.default = Fh;
let RL = zx;
function Hh(e, t) {
    new RL(t).stringify(e)
}
var Xf = Hh;
Hh.default = Hh;
let {isClean: Dc, my: BL} = uc
  , PL = zg
  , jL = zx
  , DL = Xf;
function qh(e, t) {
    let r = new e.constructor;
    for (let n in e) {
        if (!Object.prototype.hasOwnProperty.call(e, n) || n === "proxyCache")
            continue;
        let i = e[n]
          , s = typeof i;
        n === "parent" && s === "object" ? t && (r[n] = t) : n === "source" ? r[n] = i : Array.isArray(i) ? r[n] = i.map(o => qh(o, r)) : (s === "object" && i !== null && (i = qh(i)),
        r[n] = i)
    }
    return r
}
let Wh = class {
    constructor(t={}) {
        this.raws = {},
        this[Dc] = !1,
        this[BL] = !0;
        for (let r in t)
            if (r === "nodes") {
                this.nodes = [];
                for (let n of t[r])
                    typeof n.clone == "function" ? this.append(n.clone()) : this.append(n)
            } else
                this[r] = t[r]
    }
    addToError(t) {
        if (t.postcssNode = this,
        t.stack && this.source && /\n\s{4}at /.test(t.stack)) {
            let r = this.source;
            t.stack = t.stack.replace(/\n\s{4}at /, `$&${r.input.from}:${r.start.line}:${r.start.column}$&`)
        }
        return t
    }
    after(t) {
        return this.parent.insertAfter(this, t),
        this
    }
    assign(t={}) {
        for (let r in t)
            this[r] = t[r];
        return this
    }
    before(t) {
        return this.parent.insertBefore(this, t),
        this
    }
    cleanRaws(t) {
        delete this.raws.before,
        delete this.raws.after,
        t || delete this.raws.between
    }
    clone(t={}) {
        let r = qh(this);
        for (let n in t)
            r[n] = t[n];
        return r
    }
    cloneAfter(t={}) {
        let r = this.clone(t);
        return this.parent.insertAfter(this, r),
        r
    }
    cloneBefore(t={}) {
        let r = this.clone(t);
        return this.parent.insertBefore(this, r),
        r
    }
    error(t, r={}) {
        if (this.source) {
            let {end: n, start: i} = this.rangeBy(r);
            return this.source.input.error(t, {
                column: i.column,
                line: i.line
            }, {
                column: n.column,
                line: n.line
            }, r)
        }
        return new PL(t)
    }
    getProxyProcessor() {
        return {
            get(t, r) {
                return r === "proxyOf" ? t : r === "root" ? () => t.root().toProxy() : t[r]
            },
            set(t, r, n) {
                return t[r] === n || (t[r] = n,
                (r === "prop" || r === "value" || r === "name" || r === "params" || r === "important" || r === "text") && t.markDirty()),
                !0
            }
        }
    }
    markDirty() {
        if (this[Dc]) {
            this[Dc] = !1;
            let t = this;
            for (; t = t.parent; )
                t[Dc] = !1
        }
    }
    next() {
        if (!this.parent)
            return;
        let t = this.parent.index(this);
        return this.parent.nodes[t + 1]
    }
    positionBy(t, r) {
        let n = this.source.start;
        if (t.index)
            n = this.positionInside(t.index, r);
        else if (t.word) {
            r = this.toString();
            let i = r.indexOf(t.word);
            i !== -1 && (n = this.positionInside(i, r))
        }
        return n
    }
    positionInside(t, r) {
        let n = r || this.toString()
          , i = this.source.start.column
          , s = this.source.start.line;
        for (let o = 0; o < t; o++)
            n[o] === `
` ? (i = 1,
            s += 1) : i += 1;
        return {
            column: i,
            line: s
        }
    }
    prev() {
        if (!this.parent)
            return;
        let t = this.parent.index(this);
        return this.parent.nodes[t - 1]
    }
    rangeBy(t) {
        let r = {
            column: this.source.start.column,
            line: this.source.start.line
        }
          , n = this.source.end ? {
            column: this.source.end.column + 1,
            line: this.source.end.line
        } : {
            column: r.column + 1,
            line: r.line
        };
        if (t.word) {
            let i = this.toString()
              , s = i.indexOf(t.word);
            s !== -1 && (r = this.positionInside(s, i),
            n = this.positionInside(s + t.word.length, i))
        } else
            t.start ? r = {
                column: t.start.column,
                line: t.start.line
            } : t.index && (r = this.positionInside(t.index)),
            t.end ? n = {
                column: t.end.column,
                line: t.end.line
            } : typeof t.endIndex == "number" ? n = this.positionInside(t.endIndex) : t.index && (n = this.positionInside(t.index + 1));
        return (n.line < r.line || n.line === r.line && n.column <= r.column) && (n = {
            column: r.column + 1,
            line: r.line
        }),
        {
            end: n,
            start: r
        }
    }
    raw(t, r) {
        return new jL().raw(this, t, r)
    }
    remove() {
        return this.parent && this.parent.removeChild(this),
        this.parent = void 0,
        this
    }
    replaceWith(...t) {
        if (this.parent) {
            let r = this
              , n = !1;
            for (let i of t)
                i === this ? n = !0 : n ? (this.parent.insertAfter(r, i),
                r = i) : this.parent.insertBefore(r, i);
            n || this.remove()
        }
        return this
    }
    root() {
        let t = this;
        for (; t.parent && t.parent.type !== "document"; )
            t = t.parent;
        return t
    }
    toJSON(t, r) {
        let n = {}
          , i = r == null;
        r = r || new Map;
        let s = 0;
        for (let o in this) {
            if (!Object.prototype.hasOwnProperty.call(this, o) || o === "parent" || o === "proxyCache")
                continue;
            let a = this[o];
            if (Array.isArray(a))
                n[o] = a.map(u => typeof u == "object" && u.toJSON ? u.toJSON(null, r) : u);
            else if (typeof a == "object" && a.toJSON)
                n[o] = a.toJSON(null, r);
            else if (o === "source") {
                let u = r.get(a.input);
                u == null && (u = s,
                r.set(a.input, s),
                s++),
                n[o] = {
                    end: a.end,
                    inputId: u,
                    start: a.start
                }
            } else
                n[o] = a
        }
        return i && (n.inputs = [...r.keys()].map(o => o.toJSON())),
        n
    }
    toProxy() {
        return this.proxyCache || (this.proxyCache = new Proxy(this,this.getProxyProcessor())),
        this.proxyCache
    }
    toString(t=DL) {
        t.stringify && (t = t.stringify);
        let r = "";
        return t(this, n => {
            r += n
        }
        ),
        r
    }
    warn(t, r, n) {
        let i = {
            node: this
        };
        for (let s in n)
            i[s] = n[s];
        return t.warn(r, i)
    }
    get proxyOf() {
        return this
    }
}
;
var ed = Wh;
Wh.default = Wh;
let UL = ed
  , Vh = class extends UL {
    constructor(t) {
        t && typeof t.value < "u" && typeof t.value != "string" && (t = {
            ...t,
            value: String(t.value)
        }),
        super(t),
        this.type = "decl"
    }
    get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$"
    }
}
;
var td = Vh;
Vh.default = Vh;
let zL = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"
  , $L = (e, t=21) => (r=t) => {
    let n = ""
      , i = r;
    for (; i--; )
        n += e[Math.random() * e.length | 0];
    return n
}
  , FL = (e=21) => {
    let t = ""
      , r = e;
    for (; r--; )
        t += zL[Math.random() * 64 | 0];
    return t
}
;
var HL = {
    nanoid: FL,
    customAlphabet: $L
};
let {SourceMapConsumer: Hy, SourceMapGenerator: qy} = mn
  , {existsSync: qL, readFileSync: WL} = mn
  , {dirname: y0, join: VL} = mn;
function KL(e) {
    return Buffer ? Buffer.from(e, "base64").toString() : window.atob(e)
}
let Kh = class {
    constructor(t, r) {
        if (r.map === !1)
            return;
        this.loadAnnotation(t),
        this.inline = this.startWith(this.annotation, "data:");
        let n = r.map ? r.map.prev : void 0
          , i = this.loadMap(r.from, n);
        !this.mapFile && r.from && (this.mapFile = r.from),
        this.mapFile && (this.root = y0(this.mapFile)),
        i && (this.text = i)
    }
    consumer() {
        return this.consumerCache || (this.consumerCache = new Hy(this.text)),
        this.consumerCache
    }
    decodeInline(t) {
        let r = /^data:application\/json;charset=utf-?8;base64,/
          , n = /^data:application\/json;base64,/
          , i = /^data:application\/json;charset=utf-?8,/
          , s = /^data:application\/json,/;
        if (i.test(t) || s.test(t))
            return decodeURIComponent(t.substr(RegExp.lastMatch.length));
        if (r.test(t) || n.test(t))
            return KL(t.substr(RegExp.lastMatch.length));
        let o = t.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + o)
    }
    getAnnotationURL(t) {
        return t.replace(/^\/\*\s*# sourceMappingURL=/, "").trim()
    }
    isMap(t) {
        return typeof t != "object" ? !1 : typeof t.mappings == "string" || typeof t._mappings == "string" || Array.isArray(t.sections)
    }
    loadAnnotation(t) {
        let r = t.match(/\/\*\s*# sourceMappingURL=/gm);
        if (!r)
            return;
        let n = t.lastIndexOf(r.pop())
          , i = t.indexOf("*/", n);
        n > -1 && i > -1 && (this.annotation = this.getAnnotationURL(t.substring(n, i)))
    }
    loadFile(t) {
        if (this.root = y0(t),
        qL(t))
            return this.mapFile = t,
            WL(t, "utf-8").toString().trim()
    }
    loadMap(t, r) {
        if (r === !1)
            return !1;
        if (r) {
            if (typeof r == "string")
                return r;
            if (typeof r == "function") {
                let n = r(t);
                if (n) {
                    let i = this.loadFile(n);
                    if (!i)
                        throw new Error("Unable to load previous source map: " + n.toString());
                    return i
                }
            } else {
                if (r instanceof Hy)
                    return qy.fromSourceMap(r).toString();
                if (r instanceof qy)
                    return r.toString();
                if (this.isMap(r))
                    return JSON.stringify(r);
                throw new Error("Unsupported previous source map format: " + r.toString())
            }
        } else {
            if (this.inline)
                return this.decodeInline(this.annotation);
            if (this.annotation) {
                let n = this.annotation;
                return t && (n = VL(y0(t), n)),
                this.loadFile(n)
            }
        }
    }
    startWith(t, r) {
        return t ? t.substr(0, r.length) === r : !1
    }
    withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0)
    }
}
;
var $x = Kh;
Kh.default = Kh;
let {SourceMapConsumer: GL, SourceMapGenerator: QL} = mn
  , {fileURLToPath: Wy, pathToFileURL: Uc} = mn
  , {isAbsolute: Gh, resolve: Qh} = mn
  , {nanoid: YL} = HL
  , b0 = mn
  , Vy = zg
  , ZL = $x
  , w0 = Symbol("fromOffsetCache")
  , JL = !!(GL && QL)
  , Ky = !!(Qh && Gh)
  , Xl = class {
    constructor(t, r={}) {
        if (t === null || typeof t > "u" || typeof t == "object" && !t.toString)
            throw new Error(`PostCSS received ${t} instead of CSS string`);
        if (this.css = t.toString(),
        this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0,
        this.css = this.css.slice(1)) : this.hasBOM = !1,
        r.from && (!Ky || /^\w+:\/\//.test(r.from) || Gh(r.from) ? this.file = r.from : this.file = Qh(r.from)),
        Ky && JL) {
            let n = new ZL(this.css,r);
            if (n.text) {
                this.map = n;
                let i = n.consumer().file;
                !this.file && i && (this.file = this.mapResolve(i))
            }
        }
        this.file || (this.id = "<input css " + YL(6) + ">"),
        this.map && (this.map.file = this.from)
    }
    error(t, r, n, i={}) {
        let s, o, a;
        if (r && typeof r == "object") {
            let c = r
              , l = n;
            if (typeof c.offset == "number") {
                let p = this.fromOffset(c.offset);
                r = p.line,
                n = p.col
            } else
                r = c.line,
                n = c.column;
            if (typeof l.offset == "number") {
                let p = this.fromOffset(l.offset);
                o = p.line,
                a = p.col
            } else
                o = l.line,
                a = l.column
        } else if (!n) {
            let c = this.fromOffset(r);
            r = c.line,
            n = c.col
        }
        let u = this.origin(r, n, o, a);
        return u ? s = new Vy(t,u.endLine === void 0 ? u.line : {
            column: u.column,
            line: u.line
        },u.endLine === void 0 ? u.column : {
            column: u.endColumn,
            line: u.endLine
        },u.source,u.file,i.plugin) : s = new Vy(t,o === void 0 ? r : {
            column: n,
            line: r
        },o === void 0 ? n : {
            column: a,
            line: o
        },this.css,this.file,i.plugin),
        s.input = {
            column: n,
            endColumn: a,
            endLine: o,
            line: r,
            source: this.css
        },
        this.file && (Uc && (s.input.url = Uc(this.file).toString()),
        s.input.file = this.file),
        s
    }
    fromOffset(t) {
        let r, n;
        if (this[w0])
            n = this[w0];
        else {
            let s = this.css.split(`
`);
            n = new Array(s.length);
            let o = 0;
            for (let a = 0, u = s.length; a < u; a++)
                n[a] = o,
                o += s[a].length + 1;
            this[w0] = n
        }
        r = n[n.length - 1];
        let i = 0;
        if (t >= r)
            i = n.length - 1;
        else {
            let s = n.length - 2, o;
            for (; i < s; )
                if (o = i + (s - i >> 1),
                t < n[o])
                    s = o - 1;
                else if (t >= n[o + 1])
                    i = o + 1;
                else {
                    i = o;
                    break
                }
        }
        return {
            col: t - n[i] + 1,
            line: i + 1
        }
    }
    mapResolve(t) {
        return /^\w+:\/\//.test(t) ? t : Qh(this.map.consumer().sourceRoot || this.map.root || ".", t)
    }
    origin(t, r, n, i) {
        if (!this.map)
            return !1;
        let s = this.map.consumer()
          , o = s.originalPositionFor({
            column: r,
            line: t
        });
        if (!o.source)
            return !1;
        let a;
        typeof n == "number" && (a = s.originalPositionFor({
            column: i,
            line: n
        }));
        let u;
        Gh(o.source) ? u = Uc(o.source) : u = new URL(o.source,this.map.consumer().sourceRoot || Uc(this.map.mapFile));
        let c = {
            column: o.column,
            endColumn: a && a.column,
            endLine: a && a.line,
            line: o.line,
            url: u.toString()
        };
        if (u.protocol === "file:")
            if (Wy)
                c.file = Wy(u);
            else
                throw new Error("file: protocol is not available in this PostCSS build");
        let l = s.sourceContentFor(o.source);
        return l && (c.source = l),
        c
    }
    toJSON() {
        let t = {};
        for (let r of ["hasBOM", "css", "file", "id"])
            this[r] != null && (t[r] = this[r]);
        return this.map && (t.map = {
            ...this.map
        },
        t.map.consumerCache && (t.map.consumerCache = void 0)),
        t
    }
    get from() {
        return this.file || this.id
    }
}
;
var rd = Xl;
Xl.default = Xl;
b0 && b0.registerInput && b0.registerInput(Xl);
let {SourceMapConsumer: Fx, SourceMapGenerator: gl} = mn
  , {dirname: ml, relative: Hx, resolve: qx, sep: Wx} = mn
  , {pathToFileURL: Gy} = mn
  , XL = rd
  , eO = !!(Fx && gl)
  , tO = !!(ml && qx && Hx && Wx)
  , rO = class {
    constructor(t, r, n, i) {
        this.stringify = t,
        this.mapOpts = n.map || {},
        this.root = r,
        this.opts = n,
        this.css = i,
        this.originalCSS = i,
        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute,
        this.memoizedFileURLs = new Map,
        this.memoizedPaths = new Map,
        this.memoizedURLs = new Map
    }
    addAnnotation() {
        let t;
        this.isInline() ? t = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? t = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? t = this.mapOpts.annotation(this.opts.to, this.root) : t = this.outputFile() + ".map";
        let r = `
`;
        this.css.includes(`\r
`) && (r = `\r
`),
        this.css += r + "/*# sourceMappingURL=" + t + " */"
    }
    applyPrevMaps() {
        for (let t of this.previous()) {
            let r = this.toUrl(this.path(t.file)), n = t.root || ml(t.file), i;
            this.mapOpts.sourcesContent === !1 ? (i = new Fx(t.text),
            i.sourcesContent && (i.sourcesContent = null)) : i = t.consumer(),
            this.map.applySourceMap(i, r, this.toUrl(this.path(n)))
        }
    }
    clearAnnotation() {
        if (this.mapOpts.annotation !== !1)
            if (this.root) {
                let t;
                for (let r = this.root.nodes.length - 1; r >= 0; r--)
                    t = this.root.nodes[r],
                    t.type === "comment" && t.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(r)
            } else
                this.css && (this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, ""))
    }
    generate() {
        if (this.clearAnnotation(),
        tO && eO && this.isMap())
            return this.generateMap();
        {
            let t = "";
            return this.stringify(this.root, r => {
                t += r
            }
            ),
            [t]
        }
    }
    generateMap() {
        if (this.root)
            this.generateString();
        else if (this.previous().length === 1) {
            let t = this.previous()[0].consumer();
            t.file = this.outputFile(),
            this.map = gl.fromSourceMap(t, {
                ignoreInvalidMapping: !0
            })
        } else
            this.map = new gl({
                file: this.outputFile(),
                ignoreInvalidMapping: !0
            }),
            this.map.addMapping({
                generated: {
                    column: 0,
                    line: 1
                },
                original: {
                    column: 0,
                    line: 1
                },
                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
            });
        return this.isSourcesContent() && this.setSourcesContent(),
        this.root && this.previous().length > 0 && this.applyPrevMaps(),
        this.isAnnotation() && this.addAnnotation(),
        this.isInline() ? [this.css] : [this.css, this.map]
    }
    generateString() {
        this.css = "",
        this.map = new gl({
            file: this.outputFile(),
            ignoreInvalidMapping: !0
        });
        let t = 1, r = 1, n = "<no source>", i = {
            generated: {
                column: 0,
                line: 0
            },
            original: {
                column: 0,
                line: 0
            },
            source: ""
        }, s, o;
        this.stringify(this.root, (a, u, c) => {
            if (this.css += a,
            u && c !== "end" && (i.generated.line = t,
            i.generated.column = r - 1,
            u.source && u.source.start ? (i.source = this.sourcePath(u),
            i.original.line = u.source.start.line,
            i.original.column = u.source.start.column - 1,
            this.map.addMapping(i)) : (i.source = n,
            i.original.line = 1,
            i.original.column = 0,
            this.map.addMapping(i))),
            s = a.match(/\n/g),
            s ? (t += s.length,
            o = a.lastIndexOf(`
`),
            r = a.length - o) : r += a.length,
            u && c !== "start") {
                let l = u.parent || {
                    raws: {}
                };
                (!(u.type === "decl" || u.type === "atrule" && !u.nodes) || u !== l.last || l.raws.semicolon) && (u.source && u.source.end ? (i.source = this.sourcePath(u),
                i.original.line = u.source.end.line,
                i.original.column = u.source.end.column - 1,
                i.generated.line = t,
                i.generated.column = r - 2,
                this.map.addMapping(i)) : (i.source = n,
                i.original.line = 1,
                i.original.column = 0,
                i.generated.line = t,
                i.generated.column = r - 1,
                this.map.addMapping(i)))
            }
        }
        )
    }
    isAnnotation() {
        return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some(t => t.annotation) : !0
    }
    isInline() {
        if (typeof this.mapOpts.inline < "u")
            return this.mapOpts.inline;
        let t = this.mapOpts.annotation;
        return typeof t < "u" && t !== !0 ? !1 : this.previous().length ? this.previous().some(r => r.inline) : !0
    }
    isMap() {
        return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0
    }
    isSourcesContent() {
        return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some(t => t.withContent()) : !0
    }
    outputFile() {
        return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css"
    }
    path(t) {
        if (this.mapOpts.absolute || t.charCodeAt(0) === 60 || /^\w+:\/\//.test(t))
            return t;
        let r = this.memoizedPaths.get(t);
        if (r)
            return r;
        let n = this.opts.to ? ml(this.opts.to) : ".";
        typeof this.mapOpts.annotation == "string" && (n = ml(qx(n, this.mapOpts.annotation)));
        let i = Hx(n, t);
        return this.memoizedPaths.set(t, i),
        i
    }
    previous() {
        if (!this.previousMaps)
            if (this.previousMaps = [],
            this.root)
                this.root.walk(t => {
                    if (t.source && t.source.input.map) {
                        let r = t.source.input.map;
                        this.previousMaps.includes(r) || this.previousMaps.push(r)
                    }
                }
                );
            else {
                let t = new XL(this.originalCSS,this.opts);
                t.map && this.previousMaps.push(t.map)
            }
        return this.previousMaps
    }
    setSourcesContent() {
        let t = {};
        if (this.root)
            this.root.walk(r => {
                if (r.source) {
                    let n = r.source.input.from;
                    if (n && !t[n]) {
                        t[n] = !0;
                        let i = this.usesFileUrls ? this.toFileUrl(n) : this.toUrl(this.path(n));
                        this.map.setSourceContent(i, r.source.input.css)
                    }
                }
            }
            );
        else if (this.css) {
            let r = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
            this.map.setSourceContent(r, this.css)
        }
    }
    sourcePath(t) {
        return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(t.source.input.from) : this.toUrl(this.path(t.source.input.from))
    }
    toBase64(t) {
        return Buffer ? Buffer.from(t).toString("base64") : window.btoa(unescape(encodeURIComponent(t)))
    }
    toFileUrl(t) {
        let r = this.memoizedFileURLs.get(t);
        if (r)
            return r;
        if (Gy) {
            let n = Gy(t).toString();
            return this.memoizedFileURLs.set(t, n),
            n
        } else
            throw new Error("`map.absolute` option is not available in this PostCSS build")
    }
    toUrl(t) {
        let r = this.memoizedURLs.get(t);
        if (r)
            return r;
        Wx === "\\" && (t = t.replace(/\\/g, "/"));
        let n = encodeURI(t).replace(/[#?]/g, encodeURIComponent);
        return this.memoizedURLs.set(t, n),
        n
    }
}
;
var Vx = rO;
let nO = ed
  , Yh = class extends nO {
    constructor(t) {
        super(t),
        this.type = "comment"
    }
}
;
var nd = Yh;
Yh.default = Yh;
let {isClean: Kx, my: Gx} = uc, Qx = td, Yx = nd, iO = ed, Zx, $g, Fg, Jx;
function Xx(e) {
    return e.map(t => (t.nodes && (t.nodes = Xx(t.nodes)),
    delete t.source,
    t))
}
function e3(e) {
    if (e[Kx] = !1,
    e.proxyOf.nodes)
        for (let t of e.proxyOf.nodes)
            e3(t)
}
let yi = class t3 extends iO {
    append(...t) {
        for (let r of t) {
            let n = this.normalize(r, this.last);
            for (let i of n)
                this.proxyOf.nodes.push(i)
        }
        return this.markDirty(),
        this
    }
    cleanRaws(t) {
        if (super.cleanRaws(t),
        this.nodes)
            for (let r of this.nodes)
                r.cleanRaws(t)
    }
    each(t) {
        if (!this.proxyOf.nodes)
            return;
        let r = this.getIterator(), n, i;
        for (; this.indexes[r] < this.proxyOf.nodes.length && (n = this.indexes[r],
        i = t(this.proxyOf.nodes[n], n),
        i !== !1); )
            this.indexes[r] += 1;
        return delete this.indexes[r],
        i
    }
    every(t) {
        return this.nodes.every(t)
    }
    getIterator() {
        this.lastEach || (this.lastEach = 0),
        this.indexes || (this.indexes = {}),
        this.lastEach += 1;
        let t = this.lastEach;
        return this.indexes[t] = 0,
        t
    }
    getProxyProcessor() {
        return {
            get(t, r) {
                return r === "proxyOf" ? t : t[r] ? r === "each" || typeof r == "string" && r.startsWith("walk") ? (...n) => t[r](...n.map(i => typeof i == "function" ? (s, o) => i(s.toProxy(), o) : i)) : r === "every" || r === "some" ? n => t[r]( (i, ...s) => n(i.toProxy(), ...s)) : r === "root" ? () => t.root().toProxy() : r === "nodes" ? t.nodes.map(n => n.toProxy()) : r === "first" || r === "last" ? t[r].toProxy() : t[r] : t[r]
            },
            set(t, r, n) {
                return t[r] === n || (t[r] = n,
                (r === "name" || r === "params" || r === "selector") && t.markDirty()),
                !0
            }
        }
    }
    index(t) {
        return typeof t == "number" ? t : (t.proxyOf && (t = t.proxyOf),
        this.proxyOf.nodes.indexOf(t))
    }
    insertAfter(t, r) {
        let n = this.index(t)
          , i = this.normalize(r, this.proxyOf.nodes[n]).reverse();
        n = this.index(t);
        for (let o of i)
            this.proxyOf.nodes.splice(n + 1, 0, o);
        let s;
        for (let o in this.indexes)
            s = this.indexes[o],
            n < s && (this.indexes[o] = s + i.length);
        return this.markDirty(),
        this
    }
    insertBefore(t, r) {
        let n = this.index(t)
          , i = n === 0 ? "prepend" : !1
          , s = this.normalize(r, this.proxyOf.nodes[n], i).reverse();
        n = this.index(t);
        for (let a of s)
            this.proxyOf.nodes.splice(n, 0, a);
        let o;
        for (let a in this.indexes)
            o = this.indexes[a],
            n <= o && (this.indexes[a] = o + s.length);
        return this.markDirty(),
        this
    }
    normalize(t, r) {
        if (typeof t == "string")
            t = Xx(Zx(t).nodes);
        else if (typeof t > "u")
            t = [];
        else if (Array.isArray(t)) {
            t = t.slice(0);
            for (let i of t)
                i.parent && i.parent.removeChild(i, "ignore")
        } else if (t.type === "root" && this.type !== "document") {
            t = t.nodes.slice(0);
            for (let i of t)
                i.parent && i.parent.removeChild(i, "ignore")
        } else if (t.type)
            t = [t];
        else if (t.prop) {
            if (typeof t.value > "u")
                throw new Error("Value field is missed in node creation");
            typeof t.value != "string" && (t.value = String(t.value)),
            t = [new Qx(t)]
        } else if (t.selector)
            t = [new $g(t)];
        else if (t.name)
            t = [new Fg(t)];
        else if (t.text)
            t = [new Yx(t)];
        else
            throw new Error("Unknown node type in node creation");
        return t.map(i => (i[Gx] || t3.rebuild(i),
        i = i.proxyOf,
        i.parent && i.parent.removeChild(i),
        i[Kx] && e3(i),
        typeof i.raws.before > "u" && r && typeof r.raws.before < "u" && (i.raws.before = r.raws.before.replace(/\S/g, "")),
        i.parent = this.proxyOf,
        i))
    }
    prepend(...t) {
        t = t.reverse();
        for (let r of t) {
            let n = this.normalize(r, this.first, "prepend").reverse();
            for (let i of n)
                this.proxyOf.nodes.unshift(i);
            for (let i in this.indexes)
                this.indexes[i] = this.indexes[i] + n.length
        }
        return this.markDirty(),
        this
    }
    push(t) {
        return t.parent = this,
        this.proxyOf.nodes.push(t),
        this
    }
    removeAll() {
        for (let t of this.proxyOf.nodes)
            t.parent = void 0;
        return this.proxyOf.nodes = [],
        this.markDirty(),
        this
    }
    removeChild(t) {
        t = this.index(t),
        this.proxyOf.nodes[t].parent = void 0,
        this.proxyOf.nodes.splice(t, 1);
        let r;
        for (let n in this.indexes)
            r = this.indexes[n],
            r >= t && (this.indexes[n] = r - 1);
        return this.markDirty(),
        this
    }
    replaceValues(t, r, n) {
        return n || (n = r,
        r = {}),
        this.walkDecls(i => {
            r.props && !r.props.includes(i.prop) || r.fast && !i.value.includes(r.fast) || (i.value = i.value.replace(t, n))
        }
        ),
        this.markDirty(),
        this
    }
    some(t) {
        return this.nodes.some(t)
    }
    walk(t) {
        return this.each( (r, n) => {
            let i;
            try {
                i = t(r, n)
            } catch (s) {
                throw r.addToError(s)
            }
            return i !== !1 && r.walk && (i = r.walk(t)),
            i
        }
        )
    }
    walkAtRules(t, r) {
        return r ? t instanceof RegExp ? this.walk( (n, i) => {
            if (n.type === "atrule" && t.test(n.name))
                return r(n, i)
        }
        ) : this.walk( (n, i) => {
            if (n.type === "atrule" && n.name === t)
                return r(n, i)
        }
        ) : (r = t,
        this.walk( (n, i) => {
            if (n.type === "atrule")
                return r(n, i)
        }
        ))
    }
    walkComments(t) {
        return this.walk( (r, n) => {
            if (r.type === "comment")
                return t(r, n)
        }
        )
    }
    walkDecls(t, r) {
        return r ? t instanceof RegExp ? this.walk( (n, i) => {
            if (n.type === "decl" && t.test(n.prop))
                return r(n, i)
        }
        ) : this.walk( (n, i) => {
            if (n.type === "decl" && n.prop === t)
                return r(n, i)
        }
        ) : (r = t,
        this.walk( (n, i) => {
            if (n.type === "decl")
                return r(n, i)
        }
        ))
    }
    walkRules(t, r) {
        return r ? t instanceof RegExp ? this.walk( (n, i) => {
            if (n.type === "rule" && t.test(n.selector))
                return r(n, i)
        }
        ) : this.walk( (n, i) => {
            if (n.type === "rule" && n.selector === t)
                return r(n, i)
        }
        ) : (r = t,
        this.walk( (n, i) => {
            if (n.type === "rule")
                return r(n, i)
        }
        ))
    }
    get first() {
        if (this.proxyOf.nodes)
            return this.proxyOf.nodes[0]
    }
    get last() {
        if (this.proxyOf.nodes)
            return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
    }
}
;
yi.registerParse = e => {
    Zx = e
}
;
yi.registerRule = e => {
    $g = e
}
;
yi.registerAtRule = e => {
    Fg = e
}
;
yi.registerRoot = e => {
    Jx = e
}
;
var eo = yi;
yi.default = yi;
yi.rebuild = e => {
    e.type === "atrule" ? Object.setPrototypeOf(e, Fg.prototype) : e.type === "rule" ? Object.setPrototypeOf(e, $g.prototype) : e.type === "decl" ? Object.setPrototypeOf(e, Qx.prototype) : e.type === "comment" ? Object.setPrototypeOf(e, Yx.prototype) : e.type === "root" && Object.setPrototypeOf(e, Jx.prototype),
    e[Gx] = !0,
    e.nodes && e.nodes.forEach(t => {
        yi.rebuild(t)
    }
    )
}
;
let sO = eo, r3, n3, yu = class extends sO {
    constructor(t) {
        super({
            type: "document",
            ...t
        }),
        this.nodes || (this.nodes = [])
    }
    toResult(t={}) {
        return new r3(new n3,this,t).stringify()
    }
}
;
yu.registerLazyResult = e => {
    r3 = e
}
;
yu.registerProcessor = e => {
    n3 = e
}
;
var Hg = yu;
yu.default = yu;
let Zh = class {
    constructor(t, r={}) {
        if (this.type = "warning",
        this.text = t,
        r.node && r.node.source) {
            let n = r.node.rangeBy(r);
            this.line = n.start.line,
            this.column = n.start.column,
            this.endLine = n.end.line,
            this.endColumn = n.end.column
        }
        for (let n in r)
            this[n] = r[n]
    }
    toString() {
        return this.node ? this.node.error(this.text, {
            index: this.index,
            plugin: this.plugin,
            word: this.word
        }).message : this.plugin ? this.plugin + ": " + this.text : this.text
    }
}
;
var i3 = Zh;
Zh.default = Zh;
let oO = i3
  , Jh = class {
    constructor(t, r, n) {
        this.processor = t,
        this.messages = [],
        this.root = r,
        this.opts = n,
        this.css = void 0,
        this.map = void 0
    }
    toString() {
        return this.css
    }
    warn(t, r={}) {
        r.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (r.plugin = this.lastPlugin.postcssPlugin);
        let n = new oO(t,r);
        return this.messages.push(n),
        n
    }
    warnings() {
        return this.messages.filter(t => t.type === "warning")
    }
    get content() {
        return this.css
    }
}
;
var qg = Jh;
Jh.default = Jh;
const v0 = 39
  , Qy = 34
  , zc = 92
  , Yy = 47
  , $c = 10
  , Ta = 32
  , Fc = 12
  , Hc = 9
  , qc = 13
  , aO = 91
  , uO = 93
  , cO = 40
  , lO = 41
  , fO = 123
  , dO = 125
  , hO = 59
  , pO = 42
  , gO = 58
  , mO = 64
  , Wc = /[\t\n\f\r "#'()/;[\\\]{}]/g
  , Vc = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g
  , yO = /.[\r\n"'(/\\]/
  , Zy = /[\da-f]/i;
var bO = function(t, r={}) {
    let n = t.css.valueOf(), i = r.ignoreErrors, s, o, a, u, c, l, p, h, g, S, x = n.length, v = 0, I = [], M = [];
    function A() {
        return v
    }
    function k(D) {
        throw t.error("Unclosed " + D, v)
    }
    function L() {
        return M.length === 0 && v >= x
    }
    function O(D) {
        if (M.length)
            return M.pop();
        if (v >= x)
            return;
        let K = D ? D.ignoreUnclosed : !1;
        switch (s = n.charCodeAt(v),
        s) {
        case $c:
        case Ta:
        case Hc:
        case qc:
        case Fc:
            {
                o = v;
                do
                    o += 1,
                    s = n.charCodeAt(o);
                while (s === Ta || s === $c || s === Hc || s === qc || s === Fc);
                S = ["space", n.slice(v, o)],
                v = o - 1;
                break
            }
        case aO:
        case uO:
        case fO:
        case dO:
        case gO:
        case hO:
        case lO:
            {
                let G = String.fromCharCode(s);
                S = [G, G, v];
                break
            }
        case cO:
            {
                if (h = I.length ? I.pop()[1] : "",
                g = n.charCodeAt(v + 1),
                h === "url" && g !== v0 && g !== Qy && g !== Ta && g !== $c && g !== Hc && g !== Fc && g !== qc) {
                    o = v;
                    do {
                        if (l = !1,
                        o = n.indexOf(")", o + 1),
                        o === -1)
                            if (i || K) {
                                o = v;
                                break
                            } else
                                k("bracket");
                        for (p = o; n.charCodeAt(p - 1) === zc; )
                            p -= 1,
                            l = !l
                    } while (l);
                    S = ["brackets", n.slice(v, o + 1), v, o],
                    v = o
                } else
                    o = n.indexOf(")", v + 1),
                    u = n.slice(v, o + 1),
                    o === -1 || yO.test(u) ? S = ["(", "(", v] : (S = ["brackets", u, v, o],
                    v = o);
                break
            }
        case v0:
        case Qy:
            {
                a = s === v0 ? "'" : '"',
                o = v;
                do {
                    if (l = !1,
                    o = n.indexOf(a, o + 1),
                    o === -1)
                        if (i || K) {
                            o = v + 1;
                            break
                        } else
                            k("string");
                    for (p = o; n.charCodeAt(p - 1) === zc; )
                        p -= 1,
                        l = !l
                } while (l);
                S = ["string", n.slice(v, o + 1), v, o],
                v = o;
                break
            }
        case mO:
            {
                Wc.lastIndex = v + 1,
                Wc.test(n),
                Wc.lastIndex === 0 ? o = n.length - 1 : o = Wc.lastIndex - 2,
                S = ["at-word", n.slice(v, o + 1), v, o],
                v = o;
                break
            }
        case zc:
            {
                for (o = v,
                c = !0; n.charCodeAt(o + 1) === zc; )
                    o += 1,
                    c = !c;
                if (s = n.charCodeAt(o + 1),
                c && s !== Yy && s !== Ta && s !== $c && s !== Hc && s !== qc && s !== Fc && (o += 1,
                Zy.test(n.charAt(o)))) {
                    for (; Zy.test(n.charAt(o + 1)); )
                        o += 1;
                    n.charCodeAt(o + 1) === Ta && (o += 1)
                }
                S = ["word", n.slice(v, o + 1), v, o],
                v = o;
                break
            }
        default:
            {
                s === Yy && n.charCodeAt(v + 1) === pO ? (o = n.indexOf("*/", v + 2) + 1,
                o === 0 && (i || K ? o = n.length : k("comment")),
                S = ["comment", n.slice(v, o + 1), v, o],
                v = o) : (Vc.lastIndex = v + 1,
                Vc.test(n),
                Vc.lastIndex === 0 ? o = n.length - 1 : o = Vc.lastIndex - 2,
                S = ["word", n.slice(v, o + 1), v, o],
                I.push(S),
                v = o);
                break
            }
        }
        return v++,
        S
    }
    function $(D) {
        M.push(D)
    }
    return {
        back: $,
        endOfFile: L,
        nextToken: O,
        position: A
    }
};
let s3 = eo
  , ef = class extends s3 {
    constructor(t) {
        super(t),
        this.type = "atrule"
    }
    append(...t) {
        return this.proxyOf.nodes || (this.nodes = []),
        super.append(...t)
    }
    prepend(...t) {
        return this.proxyOf.nodes || (this.nodes = []),
        super.prepend(...t)
    }
}
;
var Wg = ef;
ef.default = ef;
s3.registerAtRule(ef);
let o3 = eo, a3, u3, Vo = class extends o3 {
    constructor(t) {
        super(t),
        this.type = "root",
        this.nodes || (this.nodes = [])
    }
    normalize(t, r, n) {
        let i = super.normalize(t);
        if (r) {
            if (n === "prepend")
                this.nodes.length > 1 ? r.raws.before = this.nodes[1].raws.before : delete r.raws.before;
            else if (this.first !== r)
                for (let s of i)
                    s.raws.before = r.raws.before
        }
        return i
    }
    removeChild(t, r) {
        let n = this.index(t);
        return !r && n === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n].raws.before),
        super.removeChild(t)
    }
    toResult(t={}) {
        return new a3(new u3,this,t).stringify()
    }
}
;
Vo.registerLazyResult = e => {
    a3 = e
}
;
Vo.registerProcessor = e => {
    u3 = e
}
;
var cc = Vo;
Vo.default = Vo;
o3.registerRoot(Vo);
let bu = {
    comma(e) {
        return bu.split(e, [","], !0)
    },
    space(e) {
        let t = [" ", `
`, "	"];
        return bu.split(e, t)
    },
    split(e, t, r) {
        let n = []
          , i = ""
          , s = !1
          , o = 0
          , a = !1
          , u = ""
          , c = !1;
        for (let l of e)
            c ? c = !1 : l === "\\" ? c = !0 : a ? l === u && (a = !1) : l === '"' || l === "'" ? (a = !0,
            u = l) : l === "(" ? o += 1 : l === ")" ? o > 0 && (o -= 1) : o === 0 && t.includes(l) && (s = !0),
            s ? (i !== "" && n.push(i.trim()),
            i = "",
            s = !1) : i += l;
        return (r || i !== "") && n.push(i.trim()),
        n
    }
};
var c3 = bu;
bu.default = bu;
let l3 = eo
  , wO = c3
  , tf = class extends l3 {
    constructor(t) {
        super(t),
        this.type = "rule",
        this.nodes || (this.nodes = [])
    }
    get selectors() {
        return wO.comma(this.selector)
    }
    set selectors(t) {
        let r = this.selector ? this.selector.match(/,\s*/) : null
          , n = r ? r[0] : "," + this.raw("between", "beforeOpen");
        this.selector = t.join(n)
    }
}
;
var Vg = tf;
tf.default = tf;
l3.registerRule(tf);
let vO = td
  , xO = bO
  , EO = nd
  , SO = Wg
  , _O = cc
  , Jy = Vg;
const Xy = {
    empty: !0,
    space: !0
};
function AO(e) {
    for (let t = e.length - 1; t >= 0; t--) {
        let r = e[t]
          , n = r[3] || r[2];
        if (n)
            return n
    }
}
let MO = class {
    constructor(t) {
        this.input = t,
        this.root = new _O,
        this.current = this.root,
        this.spaces = "",
        this.semicolon = !1,
        this.createTokenizer(),
        this.root.source = {
            input: t,
            start: {
                column: 1,
                line: 1,
                offset: 0
            }
        }
    }
    atrule(t) {
        let r = new SO;
        r.name = t[1].slice(1),
        r.name === "" && this.unnamedAtrule(r, t),
        this.init(r, t[2]);
        let n, i, s, o = !1, a = !1, u = [], c = [];
        for (; !this.tokenizer.endOfFile(); ) {
            if (t = this.tokenizer.nextToken(),
            n = t[0],
            n === "(" || n === "[" ? c.push(n === "(" ? ")" : "]") : n === "{" && c.length > 0 ? c.push("}") : n === c[c.length - 1] && c.pop(),
            c.length === 0)
                if (n === ";") {
                    r.source.end = this.getPosition(t[2]),
                    r.source.end.offset++,
                    this.semicolon = !0;
                    break
                } else if (n === "{") {
                    a = !0;
                    break
                } else if (n === "}") {
                    if (u.length > 0) {
                        for (s = u.length - 1,
                        i = u[s]; i && i[0] === "space"; )
                            i = u[--s];
                        i && (r.source.end = this.getPosition(i[3] || i[2]),
                        r.source.end.offset++)
                    }
                    this.end(t);
                    break
                } else
                    u.push(t);
            else
                u.push(t);
            if (this.tokenizer.endOfFile()) {
                o = !0;
                break
            }
        }
        r.raws.between = this.spacesAndCommentsFromEnd(u),
        u.length ? (r.raws.afterName = this.spacesAndCommentsFromStart(u),
        this.raw(r, "params", u),
        o && (t = u[u.length - 1],
        r.source.end = this.getPosition(t[3] || t[2]),
        r.source.end.offset++,
        this.spaces = r.raws.between,
        r.raws.between = "")) : (r.raws.afterName = "",
        r.params = ""),
        a && (r.nodes = [],
        this.current = r)
    }
    checkMissedSemicolon(t) {
        let r = this.colon(t);
        if (r === !1)
            return;
        let n = 0, i;
        for (let s = r - 1; s >= 0 && (i = t[s],
        !(i[0] !== "space" && (n += 1,
        n === 2))); s--)
            ;
        throw this.input.error("Missed semicolon", i[0] === "word" ? i[3] + 1 : i[2])
    }
    colon(t) {
        let r = 0, n, i, s;
        for (let[o,a] of t.entries()) {
            if (n = a,
            i = n[0],
            i === "(" && (r += 1),
            i === ")" && (r -= 1),
            r === 0 && i === ":")
                if (!s)
                    this.doubleColon(n);
                else {
                    if (s[0] === "word" && s[1] === "progid")
                        continue;
                    return o
                }
            s = n
        }
        return !1
    }
    comment(t) {
        let r = new EO;
        this.init(r, t[2]),
        r.source.end = this.getPosition(t[3] || t[2]),
        r.source.end.offset++;
        let n = t[1].slice(2, -2);
        if (/^\s*$/.test(n))
            r.text = "",
            r.raws.left = n,
            r.raws.right = "";
        else {
            let i = n.match(/^(\s*)([^]*\S)(\s*)$/);
            r.text = i[2],
            r.raws.left = i[1],
            r.raws.right = i[3]
        }
    }
    createTokenizer() {
        this.tokenizer = xO(this.input)
    }
    decl(t, r) {
        let n = new vO;
        this.init(n, t[0][2]);
        let i = t[t.length - 1];
        for (i[0] === ";" && (this.semicolon = !0,
        t.pop()),
        n.source.end = this.getPosition(i[3] || i[2] || AO(t)),
        n.source.end.offset++; t[0][0] !== "word"; )
            t.length === 1 && this.unknownWord(t),
            n.raws.before += t.shift()[1];
        for (n.source.start = this.getPosition(t[0][2]),
        n.prop = ""; t.length; ) {
            let c = t[0][0];
            if (c === ":" || c === "space" || c === "comment")
                break;
            n.prop += t.shift()[1]
        }
        n.raws.between = "";
        let s;
        for (; t.length; )
            if (s = t.shift(),
            s[0] === ":") {
                n.raws.between += s[1];
                break
            } else
                s[0] === "word" && /\w/.test(s[1]) && this.unknownWord([s]),
                n.raws.between += s[1];
        (n.prop[0] === "_" || n.prop[0] === "*") && (n.raws.before += n.prop[0],
        n.prop = n.prop.slice(1));
        let o = [], a;
        for (; t.length && (a = t[0][0],
        !(a !== "space" && a !== "comment")); )
            o.push(t.shift());
        this.precheckMissedSemicolon(t);
        for (let c = t.length - 1; c >= 0; c--) {
            if (s = t[c],
            s[1].toLowerCase() === "!important") {
                n.important = !0;
                let l = this.stringFrom(t, c);
                l = this.spacesFromEnd(t) + l,
                l !== " !important" && (n.raws.important = l);
                break
            } else if (s[1].toLowerCase() === "important") {
                let l = t.slice(0)
                  , p = "";
                for (let h = c; h > 0; h--) {
                    let g = l[h][0];
                    if (p.trim().indexOf("!") === 0 && g !== "space")
                        break;
                    p = l.pop()[1] + p
                }
                p.trim().indexOf("!") === 0 && (n.important = !0,
                n.raws.important = p,
                t = l)
            }
            if (s[0] !== "space" && s[0] !== "comment")
                break
        }
        t.some(c => c[0] !== "space" && c[0] !== "comment") && (n.raws.between += o.map(c => c[1]).join(""),
        o = []),
        this.raw(n, "value", o.concat(t), r),
        n.value.includes(":") && !r && this.checkMissedSemicolon(t)
    }
    doubleColon(t) {
        throw this.input.error("Double colon", {
            offset: t[2]
        }, {
            offset: t[2] + t[1].length
        })
    }
    emptyRule(t) {
        let r = new Jy;
        this.init(r, t[2]),
        r.selector = "",
        r.raws.between = "",
        this.current = r
    }
    end(t) {
        this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon),
        this.semicolon = !1,
        this.current.raws.after = (this.current.raws.after || "") + this.spaces,
        this.spaces = "",
        this.current.parent ? (this.current.source.end = this.getPosition(t[2]),
        this.current.source.end.offset++,
        this.current = this.current.parent) : this.unexpectedClose(t)
    }
    endFile() {
        this.current.parent && this.unclosedBlock(),
        this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon),
        this.current.raws.after = (this.current.raws.after || "") + this.spaces,
        this.root.source.end = this.getPosition(this.tokenizer.position())
    }
    freeSemicolon(t) {
        if (this.spaces += t[1],
        this.current.nodes) {
            let r = this.current.nodes[this.current.nodes.length - 1];
            r && r.type === "rule" && !r.raws.ownSemicolon && (r.raws.ownSemicolon = this.spaces,
            this.spaces = "")
        }
    }
    getPosition(t) {
        let r = this.input.fromOffset(t);
        return {
            column: r.col,
            line: r.line,
            offset: t
        }
    }
    init(t, r) {
        this.current.push(t),
        t.source = {
            input: this.input,
            start: this.getPosition(r)
        },
        t.raws.before = this.spaces,
        this.spaces = "",
        t.type !== "comment" && (this.semicolon = !1)
    }
    other(t) {
        let r = !1
          , n = null
          , i = !1
          , s = null
          , o = []
          , a = t[1].startsWith("--")
          , u = []
          , c = t;
        for (; c; ) {
            if (n = c[0],
            u.push(c),
            n === "(" || n === "[")
                s || (s = c),
                o.push(n === "(" ? ")" : "]");
            else if (a && i && n === "{")
                s || (s = c),
                o.push("}");
            else if (o.length === 0)
                if (n === ";")
                    if (i) {
                        this.decl(u, a);
                        return
                    } else
                        break;
                else if (n === "{") {
                    this.rule(u);
                    return
                } else if (n === "}") {
                    this.tokenizer.back(u.pop()),
                    r = !0;
                    break
                } else
                    n === ":" && (i = !0);
            else
                n === o[o.length - 1] && (o.pop(),
                o.length === 0 && (s = null));
            c = this.tokenizer.nextToken()
        }
        if (this.tokenizer.endOfFile() && (r = !0),
        o.length > 0 && this.unclosedBracket(s),
        r && i) {
            if (!a)
                for (; u.length && (c = u[u.length - 1][0],
                !(c !== "space" && c !== "comment")); )
                    this.tokenizer.back(u.pop());
            this.decl(u, a)
        } else
            this.unknownWord(u)
    }
    parse() {
        let t;
        for (; !this.tokenizer.endOfFile(); )
            switch (t = this.tokenizer.nextToken(),
            t[0]) {
            case "space":
                this.spaces += t[1];
                break;
            case ";":
                this.freeSemicolon(t);
                break;
            case "}":
                this.end(t);
                break;
            case "comment":
                this.comment(t);
                break;
            case "at-word":
                this.atrule(t);
                break;
            case "{":
                this.emptyRule(t);
                break;
            default:
                this.other(t);
                break
            }
        this.endFile()
    }
    precheckMissedSemicolon() {}
    raw(t, r, n, i) {
        let s, o, a = n.length, u = "", c = !0, l, p;
        for (let h = 0; h < a; h += 1)
            s = n[h],
            o = s[0],
            o === "space" && h === a - 1 && !i ? c = !1 : o === "comment" ? (p = n[h - 1] ? n[h - 1][0] : "empty",
            l = n[h + 1] ? n[h + 1][0] : "empty",
            !Xy[p] && !Xy[l] ? u.slice(-1) === "," ? c = !1 : u += s[1] : c = !1) : u += s[1];
        if (!c) {
            let h = n.reduce( (g, S) => g + S[1], "");
            t.raws[r] = {
                raw: h,
                value: u
            }
        }
        t[r] = u
    }
    rule(t) {
        t.pop();
        let r = new Jy;
        this.init(r, t[0][2]),
        r.raws.between = this.spacesAndCommentsFromEnd(t),
        this.raw(r, "selector", t),
        this.current = r
    }
    spacesAndCommentsFromEnd(t) {
        let r, n = "";
        for (; t.length && (r = t[t.length - 1][0],
        !(r !== "space" && r !== "comment")); )
            n = t.pop()[1] + n;
        return n
    }
    spacesAndCommentsFromStart(t) {
        let r, n = "";
        for (; t.length && (r = t[0][0],
        !(r !== "space" && r !== "comment")); )
            n += t.shift()[1];
        return n
    }
    spacesFromEnd(t) {
        let r, n = "";
        for (; t.length && (r = t[t.length - 1][0],
        r === "space"); )
            n = t.pop()[1] + n;
        return n
    }
    stringFrom(t, r) {
        let n = "";
        for (let i = r; i < t.length; i++)
            n += t[i][1];
        return t.splice(r, t.length - r),
        n
    }
    unclosedBlock() {
        let t = this.current.source.start;
        throw this.input.error("Unclosed block", t.line, t.column)
    }
    unclosedBracket(t) {
        throw this.input.error("Unclosed bracket", {
            offset: t[2]
        }, {
            offset: t[2] + 1
        })
    }
    unexpectedClose(t) {
        throw this.input.error("Unexpected }", {
            offset: t[2]
        }, {
            offset: t[2] + 1
        })
    }
    unknownWord(t) {
        throw this.input.error("Unknown word", {
            offset: t[0][2]
        }, {
            offset: t[0][2] + t[0][1].length
        })
    }
    unnamedAtrule(t, r) {
        throw this.input.error("At-rule without name", {
            offset: r[2]
        }, {
            offset: r[2] + r[1].length
        })
    }
}
;
var IO = MO;
let TO = eo
  , CO = IO
  , kO = rd;
function rf(e, t) {
    let r = new kO(e,t)
      , n = new CO(r);
    try {
        n.parse()
    } catch (i) {
        throw i
    }
    return n.root
}
var Kg = rf;
rf.default = rf;
TO.registerParse(rf);
let {isClean: Ln, my: LO} = uc
  , OO = Vx
  , NO = Xf
  , RO = eo
  , BO = Hg
  , eb = qg
  , PO = Kg
  , jO = cc;
const DO = {
    atrule: "AtRule",
    comment: "Comment",
    decl: "Declaration",
    document: "Document",
    root: "Root",
    rule: "Rule"
}
  , UO = {
    AtRule: !0,
    AtRuleExit: !0,
    Comment: !0,
    CommentExit: !0,
    Declaration: !0,
    DeclarationExit: !0,
    Document: !0,
    DocumentExit: !0,
    Once: !0,
    OnceExit: !0,
    postcssPlugin: !0,
    prepare: !0,
    Root: !0,
    RootExit: !0,
    Rule: !0,
    RuleExit: !0
}
  , zO = {
    Once: !0,
    postcssPlugin: !0,
    prepare: !0
}
  , Ko = 0;
function Ca(e) {
    return typeof e == "object" && typeof e.then == "function"
}
function f3(e) {
    let t = !1
      , r = DO[e.type];
    return e.type === "decl" ? t = e.prop.toLowerCase() : e.type === "atrule" && (t = e.name.toLowerCase()),
    t && e.append ? [r, r + "-" + t, Ko, r + "Exit", r + "Exit-" + t] : t ? [r, r + "-" + t, r + "Exit", r + "Exit-" + t] : e.append ? [r, Ko, r + "Exit"] : [r, r + "Exit"]
}
function tb(e) {
    let t;
    return e.type === "document" ? t = ["Document", Ko, "DocumentExit"] : e.type === "root" ? t = ["Root", Ko, "RootExit"] : t = f3(e),
    {
        eventIndex: 0,
        events: t,
        iterator: 0,
        node: e,
        visitorIndex: 0,
        visitors: []
    }
}
function Xh(e) {
    return e[Ln] = !1,
    e.nodes && e.nodes.forEach(t => Xh(t)),
    e
}
let ep = {}
  , Go = class d3 {
    constructor(t, r, n) {
        this.stringified = !1,
        this.processed = !1;
        let i;
        if (typeof r == "object" && r !== null && (r.type === "root" || r.type === "document"))
            i = Xh(r);
        else if (r instanceof d3 || r instanceof eb)
            i = Xh(r.root),
            r.map && (typeof n.map > "u" && (n.map = {}),
            n.map.inline || (n.map.inline = !1),
            n.map.prev = r.map);
        else {
            let s = PO;
            n.syntax && (s = n.syntax.parse),
            n.parser && (s = n.parser),
            s.parse && (s = s.parse);
            try {
                i = s(r, n)
            } catch (o) {
                this.processed = !0,
                this.error = o
            }
            i && !i[LO] && RO.rebuild(i)
        }
        this.result = new eb(t,i,n),
        this.helpers = {
            ...ep,
            postcss: ep,
            result: this.result
        },
        this.plugins = this.processor.plugins.map(s => typeof s == "object" && s.prepare ? {
            ...s,
            ...s.prepare(this.result)
        } : s)
    }
    async() {
        return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()),
        this.processing)
    }
    catch(t) {
        return this.async().catch(t)
    }
    finally(t) {
        return this.async().then(t, t)
    }
    getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins")
    }
    handleError(t, r) {
        let n = this.result.lastPlugin;
        try {
            r && r.addToError(t),
            this.error = t,
            t.name === "CssSyntaxError" && !t.plugin ? (t.plugin = n.postcssPlugin,
            t.setMessage()) : n.postcssVersion
        } catch (i) {
            console && console.error && console.error(i)
        }
        return t
    }
    prepareVisitors() {
        this.listeners = {};
        let t = (r, n, i) => {
            this.listeners[n] || (this.listeners[n] = []),
            this.listeners[n].push([r, i])
        }
        ;
        for (let r of this.plugins)
            if (typeof r == "object")
                for (let n in r) {
                    if (!UO[n] && /^[A-Z]/.test(n))
                        throw new Error(`Unknown event ${n} in ${r.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
                    if (!zO[n])
                        if (typeof r[n] == "object")
                            for (let i in r[n])
                                i === "*" ? t(r, n, r[n][i]) : t(r, n + "-" + i.toLowerCase(), r[n][i]);
                        else
                            typeof r[n] == "function" && t(r, n, r[n])
                }
        this.hasListener = Object.keys(this.listeners).length > 0
    }
    async runAsync() {
        this.plugin = 0;
        for (let t = 0; t < this.plugins.length; t++) {
            let r = this.plugins[t]
              , n = this.runOnRoot(r);
            if (Ca(n))
                try {
                    await n
                } catch (i) {
                    throw this.handleError(i)
                }
        }
        if (this.prepareVisitors(),
        this.hasListener) {
            let t = this.result.root;
            for (; !t[Ln]; ) {
                t[Ln] = !0;
                let r = [tb(t)];
                for (; r.length > 0; ) {
                    let n = this.visitTick(r);
                    if (Ca(n))
                        try {
                            await n
                        } catch (i) {
                            let s = r[r.length - 1].node;
                            throw this.handleError(i, s)
                        }
                }
            }
            if (this.listeners.OnceExit)
                for (let[r,n] of this.listeners.OnceExit) {
                    this.result.lastPlugin = r;
                    try {
                        if (t.type === "document") {
                            let i = t.nodes.map(s => n(s, this.helpers));
                            await Promise.all(i)
                        } else
                            await n(t, this.helpers)
                    } catch (i) {
                        throw this.handleError(i)
                    }
                }
        }
        return this.processed = !0,
        this.stringify()
    }
    runOnRoot(t) {
        this.result.lastPlugin = t;
        try {
            if (typeof t == "object" && t.Once) {
                if (this.result.root.type === "document") {
                    let r = this.result.root.nodes.map(n => t.Once(n, this.helpers));
                    return Ca(r[0]) ? Promise.all(r) : r
                }
                return t.Once(this.result.root, this.helpers)
            } else if (typeof t == "function")
                return t(this.result.root, this.result)
        } catch (r) {
            throw this.handleError(r)
        }
    }
    stringify() {
        if (this.error)
            throw this.error;
        if (this.stringified)
            return this.result;
        this.stringified = !0,
        this.sync();
        let t = this.result.opts
          , r = NO;
        t.syntax && (r = t.syntax.stringify),
        t.stringifier && (r = t.stringifier),
        r.stringify && (r = r.stringify);
        let i = new OO(r,this.result.root,this.result.opts).generate();
        return this.result.css = i[0],
        this.result.map = i[1],
        this.result
    }
    sync() {
        if (this.error)
            throw this.error;
        if (this.processed)
            return this.result;
        if (this.processed = !0,
        this.processing)
            throw this.getAsyncError();
        for (let t of this.plugins) {
            let r = this.runOnRoot(t);
            if (Ca(r))
                throw this.getAsyncError()
        }
        if (this.prepareVisitors(),
        this.hasListener) {
            let t = this.result.root;
            for (; !t[Ln]; )
                t[Ln] = !0,
                this.walkSync(t);
            if (this.listeners.OnceExit)
                if (t.type === "document")
                    for (let r of t.nodes)
                        this.visitSync(this.listeners.OnceExit, r);
                else
                    this.visitSync(this.listeners.OnceExit, t)
        }
        return this.result
    }
    then(t, r) {
        return this.async().then(t, r)
    }
    toString() {
        return this.css
    }
    visitSync(t, r) {
        for (let[n,i] of t) {
            this.result.lastPlugin = n;
            let s;
            try {
                s = i(r, this.helpers)
            } catch (o) {
                throw this.handleError(o, r.proxyOf)
            }
            if (r.type !== "root" && r.type !== "document" && !r.parent)
                return !0;
            if (Ca(s))
                throw this.getAsyncError()
        }
    }
    visitTick(t) {
        let r = t[t.length - 1]
          , {node: n, visitors: i} = r;
        if (n.type !== "root" && n.type !== "document" && !n.parent) {
            t.pop();
            return
        }
        if (i.length > 0 && r.visitorIndex < i.length) {
            let[o,a] = i[r.visitorIndex];
            r.visitorIndex += 1,
            r.visitorIndex === i.length && (r.visitors = [],
            r.visitorIndex = 0),
            this.result.lastPlugin = o;
            try {
                return a(n.toProxy(), this.helpers)
            } catch (u) {
                throw this.handleError(u, n)
            }
        }
        if (r.iterator !== 0) {
            let o = r.iterator, a;
            for (; a = n.nodes[n.indexes[o]]; )
                if (n.indexes[o] += 1,
                !a[Ln]) {
                    a[Ln] = !0,
                    t.push(tb(a));
                    return
                }
            r.iterator = 0,
            delete n.indexes[o]
        }
        let s = r.events;
        for (; r.eventIndex < s.length; ) {
            let o = s[r.eventIndex];
            if (r.eventIndex += 1,
            o === Ko) {
                n.nodes && n.nodes.length && (n[Ln] = !0,
                r.iterator = n.getIterator());
                return
            } else if (this.listeners[o]) {
                r.visitors = this.listeners[o];
                return
            }
        }
        t.pop()
    }
    walkSync(t) {
        t[Ln] = !0;
        let r = f3(t);
        for (let n of r)
            if (n === Ko)
                t.nodes && t.each(i => {
                    i[Ln] || this.walkSync(i)
                }
                );
            else {
                let i = this.listeners[n];
                if (i && this.visitSync(i, t.toProxy()))
                    return
            }
    }
    warnings() {
        return this.sync().warnings()
    }
    get content() {
        return this.stringify().content
    }
    get css() {
        return this.stringify().css
    }
    get map() {
        return this.stringify().map
    }
    get messages() {
        return this.sync().messages
    }
    get opts() {
        return this.result.opts
    }
    get processor() {
        return this.result.processor
    }
    get root() {
        return this.sync().root
    }
    get[Symbol.toStringTag]() {
        return "LazyResult"
    }
}
;
Go.registerPostcss = e => {
    ep = e
}
;
var h3 = Go;
Go.default = Go;
jO.registerLazyResult(Go);
BO.registerLazyResult(Go);
let $O = Vx
  , FO = Xf
  , HO = Kg;
const qO = qg;
let tp = class {
    constructor(t, r, n) {
        r = r.toString(),
        this.stringified = !1,
        this._processor = t,
        this._css = r,
        this._opts = n,
        this._map = void 0;
        let i, s = FO;
        this.result = new qO(this._processor,i,this._opts),
        this.result.css = r;
        let o = this;
        Object.defineProperty(this.result, "root", {
            get() {
                return o.root
            }
        });
        let a = new $O(s,i,this._opts,r);
        if (a.isMap()) {
            let[u,c] = a.generate();
            u && (this.result.css = u),
            c && (this.result.map = c)
        } else
            a.clearAnnotation(),
            this.result.css = a.css
    }
    async() {
        return this.error ? Promise.reject(this.error) : Promise.resolve(this.result)
    }
    catch(t) {
        return this.async().catch(t)
    }
    finally(t) {
        return this.async().then(t, t)
    }
    sync() {
        if (this.error)
            throw this.error;
        return this.result
    }
    then(t, r) {
        return this.async().then(t, r)
    }
    toString() {
        return this._css
    }
    warnings() {
        return []
    }
    get content() {
        return this.result.css
    }
    get css() {
        return this.result.css
    }
    get map() {
        return this.result.map
    }
    get messages() {
        return []
    }
    get opts() {
        return this.result.opts
    }
    get processor() {
        return this.result.processor
    }
    get root() {
        if (this._root)
            return this._root;
        let t, r = HO;
        try {
            t = r(this._css, this._opts)
        } catch (n) {
            this.error = n
        }
        if (this.error)
            throw this.error;
        return this._root = t,
        t
    }
    get[Symbol.toStringTag]() {
        return "NoWorkResult"
    }
}
;
var WO = tp;
tp.default = tp;
let VO = WO
  , KO = h3
  , GO = Hg
  , QO = cc
  , wu = class {
    constructor(t=[]) {
        this.version = "8.4.38",
        this.plugins = this.normalize(t)
    }
    normalize(t) {
        let r = [];
        for (let n of t)
            if (n.postcss === !0 ? n = n() : n.postcss && (n = n.postcss),
            typeof n == "object" && Array.isArray(n.plugins))
                r = r.concat(n.plugins);
            else if (typeof n == "object" && n.postcssPlugin)
                r.push(n);
            else if (typeof n == "function")
                r.push(n);
            else if (!(typeof n == "object" && (n.parse || n.stringify)))
                throw new Error(n + " is not a PostCSS plugin");
        return r
    }
    process(t, r={}) {
        return !this.plugins.length && !r.parser && !r.stringifier && !r.syntax ? new VO(this,t,r) : new KO(this,t,r)
    }
    use(t) {
        return this.plugins = this.plugins.concat(this.normalize([t])),
        this
    }
}
;
var YO = wu;
wu.default = wu;
QO.registerProcessor(wu);
GO.registerProcessor(wu);
let ZO = td
  , JO = $x
  , XO = nd
  , e9 = Wg
  , t9 = rd
  , r9 = cc
  , n9 = Vg;
function vu(e, t) {
    if (Array.isArray(e))
        return e.map(i => vu(i));
    let {inputs: r, ...n} = e;
    if (r) {
        t = [];
        for (let i of r) {
            let s = {
                ...i,
                __proto__: t9.prototype
            };
            s.map && (s.map = {
                ...s.map,
                __proto__: JO.prototype
            }),
            t.push(s)
        }
    }
    if (n.nodes && (n.nodes = e.nodes.map(i => vu(i, t))),
    n.source) {
        let {inputId: i, ...s} = n.source;
        n.source = s,
        i != null && (n.source.input = t[i])
    }
    if (n.type === "root")
        return new r9(n);
    if (n.type === "decl")
        return new ZO(n);
    if (n.type === "rule")
        return new n9(n);
    if (n.type === "comment")
        return new XO(n);
    if (n.type === "atrule")
        return new e9(n);
    throw new Error("Unknown node type: " + e.type)
}
var i9 = vu;
vu.default = vu;
var rb = {};
let s9 = zg
  , p3 = td
  , o9 = h3
  , a9 = eo
  , Gg = YO
  , u9 = Xf
  , c9 = i9
  , g3 = Hg
  , l9 = i3
  , m3 = nd
  , y3 = Wg
  , f9 = qg
  , d9 = rd
  , h9 = Kg
  , p9 = c3
  , b3 = Vg
  , w3 = cc
  , g9 = ed;
function nt(...e) {
    return e.length === 1 && Array.isArray(e[0]) && (e = e[0]),
    new Gg(e)
}
nt.plugin = function(t, r) {
    let n = !1;
    function i(...o) {
        console && console.warn && !n && (n = !0,
        console.warn(t + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`),
        rb.LANG && rb.LANG.startsWith("cn") && console.warn(t + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`));
        let a = r(...o);
        return a.postcssPlugin = t,
        a.postcssVersion = new Gg().version,
        a
    }
    let s;
    return Object.defineProperty(i, "postcss", {
        get() {
            return s || (s = i()),
            s
        }
    }),
    i.process = function(o, a, u) {
        return nt([i(u)]).process(o, a)
    }
    ,
    i
}
;
nt.stringify = u9;
nt.parse = h9;
nt.fromJSON = c9;
nt.list = p9;
nt.comment = e => new m3(e);
nt.atRule = e => new y3(e);
nt.decl = e => new p3(e);
nt.rule = e => new b3(e);
nt.root = e => new w3(e);
nt.document = e => new g3(e);
nt.CssSyntaxError = s9;
nt.Declaration = p3;
nt.Container = a9;
nt.Processor = Gg;
nt.Document = g3;
nt.Comment = m3;
nt.Warning = l9;
nt.AtRule = y3;
nt.Result = f9;
nt.Input = d9;
nt.Rule = b3;
nt.Root = w3;
nt.Node = g9;
o9.registerPostcss(nt);
var m9 = nt;
nt.default = nt;
const y9 = cx
  , nb = hL
  , {isPlainObject: b9} = Dg
  , ib = TL
  , w9 = CL
  , {parse: v9} = m9
  , x9 = ["img", "audio", "video", "picture", "svg", "object", "map", "iframe", "embed"]
  , E9 = ["script", "style"];
function za(e, t) {
    e && Object.keys(e).forEach(function(r) {
        t(e[r], r)
    })
}
function si(e, t) {
    return {}.hasOwnProperty.call(e, t)
}
function sb(e, t) {
    const r = [];
    return za(e, function(n) {
        t(n) && r.push(n)
    }),
    r
}
function S9(e) {
    for (const t in e)
        if (si(e, t))
            return !1;
    return !0
}
function _9(e) {
    return e.map(function(t) {
        if (!t.url)
            throw new Error("URL missing");
        return t.url + (t.w ? ` ${t.w}w` : "") + (t.h ? ` ${t.h}h` : "") + (t.d ? ` ${t.d}x` : "")
    }).join(", ")
}
var A9 = xu;
const M9 = /^[^\0\t\n\f\r /<=>]+$/;
function xu(e, t, r) {
    if (e == null)
        return "";
    typeof e == "number" && (e = e.toString());
    let n = ""
      , i = "";
    function s(b, _) {
        const T = this;
        this.tag = b,
        this.attribs = _ || {},
        this.tagPosition = n.length,
        this.text = "",
        this.mediaChildren = [],
        this.updateParentNodeText = function() {
            if (v.length) {
                const C = v[v.length - 1];
                C.text += T.text
            }
        }
        ,
        this.updateParentNodeMediaChildren = function() {
            v.length && x9.includes(this.tag) && v[v.length - 1].mediaChildren.push(this.tag)
        }
    }
    t = Object.assign({}, xu.defaults, t),
    t.parser = Object.assign({}, I9, t.parser);
    const o = function(b) {
        return t.allowedTags === !1 || (t.allowedTags || []).indexOf(b) > -1
    };
    E9.forEach(function(b) {
        o(b) && !t.allowVulnerableTags && console.warn(`

 Your \`allowedTags\` option includes, \`${b}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`)
    });
    const a = t.nonTextTags || ["script", "style", "textarea", "option"];
    let u, c;
    t.allowedAttributes && (u = {},
    c = {},
    za(t.allowedAttributes, function(b, _) {
        u[_] = [];
        const T = [];
        b.forEach(function(C) {
            typeof C == "string" && C.indexOf("*") >= 0 ? T.push(nb(C).replace(/\\\*/g, ".*")) : u[_].push(C)
        }),
        T.length && (c[_] = new RegExp("^(" + T.join("|") + ")$"))
    }));
    const l = {}
      , p = {}
      , h = {};
    za(t.allowedClasses, function(b, _) {
        if (u && (si(u, _) || (u[_] = []),
        u[_].push("class")),
        l[_] = b,
        Array.isArray(b)) {
            const T = [];
            l[_] = [],
            h[_] = [],
            b.forEach(function(C) {
                typeof C == "string" && C.indexOf("*") >= 0 ? T.push(nb(C).replace(/\\\*/g, ".*")) : C instanceof RegExp ? h[_].push(C) : l[_].push(C)
            }),
            T.length && (p[_] = new RegExp("^(" + T.join("|") + ")$"))
        }
    });
    const g = {};
    let S;
    za(t.transformTags, function(b, _) {
        let T;
        typeof b == "function" ? T = b : typeof b == "string" && (T = xu.simpleTransform(b)),
        _ === "*" ? S = T : g[_] = T
    });
    let x, v, I, M, A, k, L = !1;
    $();
    const O = new y9.Parser({
        onopentag: function(b, _) {
            if (t.enforceHtmlBoundary && b === "html" && $(),
            A) {
                k++;
                return
            }
            const T = new s(b,_);
            v.push(T);
            let C = !1;
            const P = !!T.text;
            let W;
            if (si(g, b) && (W = g[b](b, _),
            T.attribs = _ = W.attribs,
            W.text !== void 0 && (T.innerText = W.text),
            b !== W.tagName && (T.name = b = W.tagName,
            M[x] = W.tagName)),
            S && (W = S(b, _),
            T.attribs = _ = W.attribs,
            b !== W.tagName && (T.name = b = W.tagName,
            M[x] = W.tagName)),
            (!o(b) || t.disallowedTagsMode === "recursiveEscape" && !S9(I) || t.nestingLimit != null && x >= t.nestingLimit) && (C = !0,
            I[x] = !0,
            (t.disallowedTagsMode === "discard" || t.disallowedTagsMode === "completelyDiscard") && a.indexOf(b) !== -1 && (A = !0,
            k = 1),
            I[x] = !0),
            x++,
            C) {
                if (t.disallowedTagsMode === "discard" || t.disallowedTagsMode === "completelyDiscard")
                    return;
                i = n,
                n = ""
            }
            n += "<" + b,
            b === "script" && (t.allowedScriptHostnames || t.allowedScriptDomains) && (T.innerText = ""),
            (!u || si(u, b) || u["*"]) && za(_, function(N, w) {
                if (!M9.test(w)) {
                    delete T.attribs[w];
                    return
                }
                if (N === "" && !t.allowedEmptyAttributes.includes(w) && (t.nonBooleanAttributes.includes(w) || t.nonBooleanAttributes.includes("*"))) {
                    delete T.attribs[w];
                    return
                }
                let U = !1;
                if (!u || si(u, b) && u[b].indexOf(w) !== -1 || u["*"] && u["*"].indexOf(w) !== -1 || si(c, b) && c[b].test(w) || c["*"] && c["*"].test(w))
                    U = !0;
                else if (u && u[b]) {
                    for (const re of u[b])
                        if (b9(re) && re.name && re.name === w) {
                            U = !0;
                            let ie = "";
                            if (re.multiple === !0) {
                                const ue = N.split(" ");
                                for (const Q of ue)
                                    re.values.indexOf(Q) !== -1 && (ie === "" ? ie = Q : ie += " " + Q)
                            } else
                                re.values.indexOf(N) >= 0 && (ie = N);
                            N = ie
                        }
                }
                if (U) {
                    if (t.allowedSchemesAppliedToAttributes.indexOf(w) !== -1 && K(b, N)) {
                        delete T.attribs[w];
                        return
                    }
                    if (b === "script" && w === "src") {
                        let re = !0;
                        try {
                            const ie = G(N);
                            if (t.allowedScriptHostnames || t.allowedScriptDomains) {
                                const ue = (t.allowedScriptHostnames || []).find(function(ee) {
                                    return ee === ie.url.hostname
                                })
                                  , Q = (t.allowedScriptDomains || []).find(function(ee) {
                                    return ie.url.hostname === ee || ie.url.hostname.endsWith(`.${ee}`)
                                });
                                re = ue || Q
                            }
                        } catch {
                            re = !1
                        }
                        if (!re) {
                            delete T.attribs[w];
                            return
                        }
                    }
                    if (b === "iframe" && w === "src") {
                        let re = !0;
                        try {
                            const ie = G(N);
                            if (ie.isRelativeUrl)
                                re = si(t, "allowIframeRelativeUrls") ? t.allowIframeRelativeUrls : !t.allowedIframeHostnames && !t.allowedIframeDomains;
                            else if (t.allowedIframeHostnames || t.allowedIframeDomains) {
                                const ue = (t.allowedIframeHostnames || []).find(function(ee) {
                                    return ee === ie.url.hostname
                                })
                                  , Q = (t.allowedIframeDomains || []).find(function(ee) {
                                    return ie.url.hostname === ee || ie.url.hostname.endsWith(`.${ee}`)
                                });
                                re = ue || Q
                            }
                        } catch {
                            re = !1
                        }
                        if (!re) {
                            delete T.attribs[w];
                            return
                        }
                    }
                    if (w === "srcset")
                        try {
                            let re = w9(N);
                            if (re.forEach(function(ie) {
                                K("srcset", ie.url) && (ie.evil = !0)
                            }),
                            re = sb(re, function(ie) {
                                return !ie.evil
                            }),
                            re.length)
                                N = _9(sb(re, function(ie) {
                                    return !ie.evil
                                })),
                                T.attribs[w] = N;
                            else {
                                delete T.attribs[w];
                                return
                            }
                        } catch {
                            delete T.attribs[w];
                            return
                        }
                    if (w === "class") {
                        const re = l[b]
                          , ie = l["*"]
                          , ue = p[b]
                          , Q = h[b]
                          , ee = p["*"]
                          , te = [ue, ee].concat(Q).filter(function(he) {
                            return he
                        });
                        if (re && ie ? N = y(N, ib(re, ie), te) : N = y(N, re || ie, te),
                        !N.length) {
                            delete T.attribs[w];
                            return
                        }
                    }
                    if (w === "style") {
                        if (t.parseStyleAttributes)
                            try {
                                const re = v9(b + " {" + N + "}", {
                                    map: !1
                                })
                                  , ie = F(re, t.allowedStyles);
                                if (N = q(ie),
                                N.length === 0) {
                                    delete T.attribs[w];
                                    return
                                }
                            } catch {
                                typeof window < "u" && console.warn('Failed to parse "' + b + " {" + N + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`),
                                delete T.attribs[w];
                                return
                            }
                        else if (t.allowedStyles)
                            throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.")
                    }
                    n += " " + w,
                    N && N.length ? n += '="' + D(N, !0) + '"' : t.allowedEmptyAttributes.includes(w) && (n += '=""')
                } else
                    delete T.attribs[w]
            }),
            t.selfClosing.indexOf(b) !== -1 ? n += " />" : (n += ">",
            T.innerText && !P && !t.textFilter && (n += D(T.innerText),
            L = !0)),
            C && (n = i + D(n),
            i = "")
        },
        ontext: function(b) {
            if (A)
                return;
            const _ = v[v.length - 1];
            let T;
            if (_ && (T = _.tag,
            b = _.innerText !== void 0 ? _.innerText : b),
            t.disallowedTagsMode === "completelyDiscard" && !o(T))
                b = "";
            else if ((t.disallowedTagsMode === "discard" || t.disallowedTagsMode === "completelyDiscard") && (T === "script" || T === "style"))
                n += b;
            else {
                const C = D(b, !1);
                t.textFilter && !L ? n += t.textFilter(C, T) : L || (n += C)
            }
            if (v.length) {
                const C = v[v.length - 1];
                C.text += b
            }
        },
        onclosetag: function(b, _) {
            if (A)
                if (k--,
                !k)
                    A = !1;
                else
                    return;
            const T = v.pop();
            if (!T)
                return;
            if (T.tag !== b) {
                v.push(T);
                return
            }
            A = t.enforceHtmlBoundary ? b === "html" : !1,
            x--;
            const C = I[x];
            if (C) {
                if (delete I[x],
                t.disallowedTagsMode === "discard" || t.disallowedTagsMode === "completelyDiscard") {
                    T.updateParentNodeText();
                    return
                }
                i = n,
                n = ""
            }
            if (M[x] && (b = M[x],
            delete M[x]),
            t.exclusiveFilter && t.exclusiveFilter(T)) {
                n = n.substr(0, T.tagPosition);
                return
            }
            if (T.updateParentNodeMediaChildren(),
            T.updateParentNodeText(),
            t.selfClosing.indexOf(b) !== -1 || _ && !o(b) && ["escape", "recursiveEscape"].indexOf(t.disallowedTagsMode) >= 0) {
                C && (n = i,
                i = "");
                return
            }
            n += "</" + b + ">",
            C && (n = i + D(n),
            i = ""),
            L = !1
        }
    },t.parser);
    return O.write(e),
    O.end(),
    n;
    function $() {
        n = "",
        x = 0,
        v = [],
        I = {},
        M = {},
        A = !1,
        k = 0
    }
    function D(b, _) {
        return typeof b != "string" && (b = b + ""),
        t.parser.decodeEntities && (b = b.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
        _ && (b = b.replace(/"/g, "&quot;"))),
        b = b.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
        _ && (b = b.replace(/"/g, "&quot;")),
        b
    }
    function K(b, _) {
        for (_ = _.replace(/[\x00-\x20]+/g, ""); ; ) {
            const P = _.indexOf("<!--");
            if (P === -1)
                break;
            const W = _.indexOf("-->", P + 4);
            if (W === -1)
                break;
            _ = _.substring(0, P) + _.substring(W + 3)
        }
        const T = _.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
        if (!T)
            return _.match(/^[/\\]{2}/) ? !t.allowProtocolRelative : !1;
        const C = T[1].toLowerCase();
        return si(t.allowedSchemesByTag, b) ? t.allowedSchemesByTag[b].indexOf(C) === -1 : !t.allowedSchemes || t.allowedSchemes.indexOf(C) === -1
    }
    function G(b) {
        if (b = b.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//"),
        b.startsWith("relative:"))
            throw new Error("relative: exploit attempt");
        let _ = "relative://relative-site";
        for (let P = 0; P < 100; P++)
            _ += `/${P}`;
        const T = new URL(b,_);
        return {
            isRelativeUrl: T && T.hostname === "relative-site" && T.protocol === "relative:",
            url: T
        }
    }
    function F(b, _) {
        if (!_)
            return b;
        const T = b.nodes[0];
        let C;
        return _[T.selector] && _["*"] ? C = ib(_[T.selector], _["*"]) : C = _[T.selector] || _["*"],
        C && (b.nodes[0].nodes = T.nodes.reduce(B(C), [])),
        b
    }
    function q(b) {
        return b.nodes[0].nodes.reduce(function(_, T) {
            return _.push(`${T.prop}:${T.value}${T.important ? " !important" : ""}`),
            _
        }, []).join(";")
    }
    function B(b) {
        return function(_, T) {
            return si(b, T.prop) && b[T.prop].some(function(P) {
                return P.test(T.value)
            }) && _.push(T),
            _
        }
    }
    function y(b, _, T) {
        return _ ? (b = b.split(/\s+/),
        b.filter(function(C) {
            return _.indexOf(C) !== -1 || T.some(function(P) {
                return P.test(C)
            })
        }).join(" ")) : b
    }
}
const I9 = {
    decodeEntities: !0
};
xu.defaults = {
    allowedTags: ["address", "article", "aside", "footer", "header", "h1", "h2", "h3", "h4", "h5", "h6", "hgroup", "main", "nav", "section", "blockquote", "dd", "div", "dl", "dt", "figcaption", "figure", "hr", "li", "main", "ol", "p", "pre", "ul", "a", "abbr", "b", "bdi", "bdo", "br", "cite", "code", "data", "dfn", "em", "i", "kbd", "mark", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "small", "span", "strong", "sub", "sup", "time", "u", "var", "wbr", "caption", "col", "colgroup", "table", "tbody", "td", "tfoot", "th", "thead", "tr"],
    nonBooleanAttributes: ["abbr", "accept", "accept-charset", "accesskey", "action", "allow", "alt", "as", "autocapitalize", "autocomplete", "blocking", "charset", "cite", "class", "color", "cols", "colspan", "content", "contenteditable", "coords", "crossorigin", "data", "datetime", "decoding", "dir", "dirname", "download", "draggable", "enctype", "enterkeyhint", "fetchpriority", "for", "form", "formaction", "formenctype", "formmethod", "formtarget", "headers", "height", "hidden", "high", "href", "hreflang", "http-equiv", "id", "imagesizes", "imagesrcset", "inputmode", "integrity", "is", "itemid", "itemprop", "itemref", "itemtype", "kind", "label", "lang", "list", "loading", "low", "max", "maxlength", "media", "method", "min", "minlength", "name", "nonce", "optimum", "pattern", "ping", "placeholder", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "referrerpolicy", "rel", "rows", "rowspan", "sandbox", "scope", "shape", "size", "sizes", "slot", "span", "spellcheck", "src", "srcdoc", "srclang", "srcset", "start", "step", "style", "tabindex", "target", "title", "translate", "type", "usemap", "value", "width", "wrap", "onauxclick", "onafterprint", "onbeforematch", "onbeforeprint", "onbeforeunload", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onformdata", "onhashchange", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onlanguagechange", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onmessage", "onmessageerror", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onoffline", "ononline", "onpagehide", "onpageshow", "onpaste", "onpause", "onplay", "onplaying", "onpopstate", "onprogress", "onratechange", "onreset", "onresize", "onrejectionhandled", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onslotchange", "onstalled", "onstorage", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "onunhandledrejection", "onunload", "onvolumechange", "onwaiting", "onwheel"],
    disallowedTagsMode: "discard",
    allowedAttributes: {
        a: ["href", "name", "target"],
        img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
    },
    allowedEmptyAttributes: ["alt"],
    selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
    allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
    allowedSchemesByTag: {},
    allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
    allowProtocolRelative: !0,
    enforceHtmlBoundary: !1,
    parseStyleAttributes: !0
};
xu.simpleTransform = function(e, t, r) {
    return r = r === void 0 ? !0 : r,
    t = t || {},
    function(n, i) {
        let s;
        if (r)
            for (s in t)
                i[s] = t[s];
        else
            i = t;
        return {
            tagName: e,
            attribs: i
        }
    }
}
;
const nf = ic(A9)
  , T9 = _t(e => {
    function t(s, o) {
        return s.highlight ? {
            config: JC,
            input: o
        } : {
            config: ZC,
            input: o
        }
    }
    function r(s, {modifiers: o, oldValue: a, value: u}) {
        if (u !== a) {
            const {config: c, input: l} = t(o, u);
            s.innerHTML = ky(nf(l, c.sanitize), c.linkify)
        }
    }
    function n({modifiers: s, value: o}) {
        const {config: a, input: u} = t(s, o);
        return {
            innerHTML: ky(nf(u, a.sanitize), a.linkify)
        }
    }
    const i = {
        getSSRProps: n,
        inserted: r,
        mounted: r,
        update: r,
        updated: r
    };
    e.vueApp.directive("linkify", i)
}
)
  , C9 = _t(e => {
    function t(s, o) {
        return {
            config: Cg,
            input: o
        }
    }
    function r(s, {modifiers: o, oldValue: a, value: u}) {
        if (u !== a) {
            const {config: c, input: l} = t(o, u);
            s.innerHTML = nf(l, c)
        }
    }
    function n({modifiers: s, value: o}) {
        const {config: a, input: u} = t(s, o);
        return {
            innerHTML: nf(u, a)
        }
    }
    const i = {
        getSSRProps: n,
        inserted: r,
        mounted: r,
        update: r,
        updated: r
    };
    e.vueApp.directive("sanitize", i)
}
);
var v3 = {
    exports: {}
};
(function(e) {
    var t = Object.prototype.hasOwnProperty
      , r = "~";
    function n() {}
    Object.create && (n.prototype = Object.create(null),
    new n().__proto__ || (r = !1));
    function i(u, c, l) {
        this.fn = u,
        this.context = c,
        this.once = l || !1
    }
    function s(u, c, l, p, h) {
        if (typeof l != "function")
            throw new TypeError("The listener must be a function");
        var g = new i(l,p || u,h)
          , S = r ? r + c : c;
        return u._events[S] ? u._events[S].fn ? u._events[S] = [u._events[S], g] : u._events[S].push(g) : (u._events[S] = g,
        u._eventsCount++),
        u
    }
    function o(u, c) {
        --u._eventsCount === 0 ? u._events = new n : delete u._events[c]
    }
    function a() {
        this._events = new n,
        this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var c = [], l, p;
        if (this._eventsCount === 0)
            return c;
        for (p in l = this._events)
            t.call(l, p) && c.push(r ? p.slice(1) : p);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(l)) : c
    }
    ,
    a.prototype.listeners = function(c) {
        var l = r ? r + c : c
          , p = this._events[l];
        if (!p)
            return [];
        if (p.fn)
            return [p.fn];
        for (var h = 0, g = p.length, S = new Array(g); h < g; h++)
            S[h] = p[h].fn;
        return S
    }
    ,
    a.prototype.listenerCount = function(c) {
        var l = r ? r + c : c
          , p = this._events[l];
        return p ? p.fn ? 1 : p.length : 0
    }
    ,
    a.prototype.emit = function(c, l, p, h, g, S) {
        var x = r ? r + c : c;
        if (!this._events[x])
            return !1;
        var v = this._events[x], I = arguments.length, M, A;
        if (v.fn) {
            switch (v.once && this.removeListener(c, v.fn, void 0, !0),
            I) {
            case 1:
                return v.fn.call(v.context),
                !0;
            case 2:
                return v.fn.call(v.context, l),
                !0;
            case 3:
                return v.fn.call(v.context, l, p),
                !0;
            case 4:
                return v.fn.call(v.context, l, p, h),
                !0;
            case 5:
                return v.fn.call(v.context, l, p, h, g),
                !0;
            case 6:
                return v.fn.call(v.context, l, p, h, g, S),
                !0
            }
            for (A = 1,
            M = new Array(I - 1); A < I; A++)
                M[A - 1] = arguments[A];
            v.fn.apply(v.context, M)
        } else {
            var k = v.length, L;
            for (A = 0; A < k; A++)
                switch (v[A].once && this.removeListener(c, v[A].fn, void 0, !0),
                I) {
                case 1:
                    v[A].fn.call(v[A].context);
                    break;
                case 2:
                    v[A].fn.call(v[A].context, l);
                    break;
                case 3:
                    v[A].fn.call(v[A].context, l, p);
                    break;
                case 4:
                    v[A].fn.call(v[A].context, l, p, h);
                    break;
                default:
                    if (!M)
                        for (L = 1,
                        M = new Array(I - 1); L < I; L++)
                            M[L - 1] = arguments[L];
                    v[A].fn.apply(v[A].context, M)
                }
        }
        return !0
    }
    ,
    a.prototype.on = function(c, l, p) {
        return s(this, c, l, p, !1)
    }
    ,
    a.prototype.once = function(c, l, p) {
        return s(this, c, l, p, !0)
    }
    ,
    a.prototype.removeListener = function(c, l, p, h) {
        var g = r ? r + c : c;
        if (!this._events[g])
            return this;
        if (!l)
            return o(this, g),
            this;
        var S = this._events[g];
        if (S.fn)
            S.fn === l && (!h || S.once) && (!p || S.context === p) && o(this, g);
        else {
            for (var x = 0, v = [], I = S.length; x < I; x++)
                (S[x].fn !== l || h && !S[x].once || p && S[x].context !== p) && v.push(S[x]);
            v.length ? this._events[g] = v.length === 1 ? v[0] : v : o(this, g)
        }
        return this
    }
    ,
    a.prototype.removeAllListeners = function(c) {
        var l;
        return c ? (l = r ? r + c : c,
        this._events[l] && o(this, l)) : (this._events = new n,
        this._eventsCount = 0),
        this
    }
    ,
    a.prototype.off = a.prototype.removeListener,
    a.prototype.addListener = a.prototype.on,
    a.prefixed = r,
    a.EventEmitter = a,
    e.exports = a
}
)(v3);
var Qg = v3.exports;
const k9 = ic(Qg);
class nr extends Error {
    constructor(t, r) {
        super(t),
        this.error = r
    }
}
class qs extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletNotReadyError"
    }
}
class L9 extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletLoadError"
    }
}
class Xa extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletConfigError"
    }
}
class Qo extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletConnectionError"
    }
}
class id extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletDisconnectedError"
    }
}
class Yg extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletDisconnectionError"
    }
}
class eu extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletAccountError"
    }
}
class Ws extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletPublicKeyError"
    }
}
class It extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletNotConnectedError"
    }
}
class fi extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletSendTransactionError"
    }
}
class fn extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletSignTransactionError"
    }
}
class Eu extends nr {
    constructor() {
        super(...arguments),
        this.name = "WalletSignMessageError"
    }
}
var Qe;
(function(e) {
    e.Installed = "Installed",
    e.NotDetected = "NotDetected",
    e.Loadable = "Loadable",
    e.Unsupported = "Unsupported"
}
)(Qe || (Qe = {}));
class x3 extends k9 {
    get connected() {
        return !!this.publicKey
    }
    async autoConnect() {
        await this.connect()
    }
    async prepareTransaction(t, r, n={}) {
        const i = this.publicKey;
        if (!i)
            throw new It;
        return t.feePayer = t.feePayer || i,
        t.recentBlockhash = t.recentBlockhash || (await r.getLatestBlockhash({
            commitment: n.preflightCommitment,
            minContextSlot: n.minContextSlot
        })).blockhash,
        t
    }
}
function E3(e) {
    if (typeof window > "u" || typeof document > "u")
        return;
    const t = [];
    function r() {
        if (e())
            for (const s of t)
                s()
    }
    const n = setInterval(r, 1e3);
    t.push( () => clearInterval(n)),
    document.readyState === "loading" && (document.addEventListener("DOMContentLoaded", r, {
        once: !0
    }),
    t.push( () => document.removeEventListener("DOMContentLoaded", r))),
    document.readyState !== "complete" && (window.addEventListener("load", r, {
        once: !0
    }),
    t.push( () => window.removeEventListener("load", r))),
    r()
}
function rp() {
    if (!navigator)
        return !1;
    const e = navigator.userAgent.toLowerCase()
      , t = e.includes("iphone") || e.includes("ipad")
      , r = e.includes("safari");
    return t && r
}
function sf(e) {
    return "version"in e
}
class O9 extends x3 {
    async sendTransaction(t, r, n={}) {
        let i = !0;
        try {
            if (sf(t)) {
                if (!this.supportedTransactionVersions)
                    throw new fi("Sending versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has(t.version))
                    throw new fi(`Sending transaction version ${t.version} isn't supported by this wallet`);
                try {
                    t = await this.signTransaction(t);
                    const s = t.serialize();
                    return await r.sendRawTransaction(s, n)
                } catch (s) {
                    throw s instanceof fn ? (i = !1,
                    s) : new fi(s == null ? void 0 : s.message,s)
                }
            } else
                try {
                    const {signers: s, ...o} = n;
                    t = await this.prepareTransaction(t, r, o),
                    s != null && s.length && t.partialSign(...s),
                    t = await this.signTransaction(t);
                    const a = t.serialize();
                    return await r.sendRawTransaction(a, o)
                } catch (s) {
                    throw s instanceof fn ? (i = !1,
                    s) : new fi(s == null ? void 0 : s.message,s)
                }
        } catch (s) {
            throw i && this.emit("error", s),
            s
        }
    }
    async signAllTransactions(t) {
        for (const n of t)
            if (sf(n)) {
                if (!this.supportedTransactionVersions)
                    throw new fn("Signing versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has(n.version))
                    throw new fn(`Signing transaction version ${n.version} isn't supported by this wallet`)
            }
        const r = [];
        for (const n of t)
            r.push(await this.signTransaction(n));
        return r
    }
}
class Zg extends O9 {
}
const N9 = "solana:signAndSendTransaction"
  , R9 = "solana:signMessage"
  , B9 = "solana:signTransaction"
  , P9 = "standard:connect"
  , j9 = "standard:disconnect"
  , D9 = "standard:events";
var $e = {}
  , sd = {};
sd.byteLength = $9;
sd.toByteArray = H9;
sd.fromByteArray = V9;
var jn = []
  , tn = []
  , U9 = typeof Uint8Array < "u" ? Uint8Array : Array
  , x0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ao = 0, z9 = x0.length; ao < z9; ++ao)
    jn[ao] = x0[ao],
    tn[x0.charCodeAt(ao)] = ao;
tn[45] = 62;
tn[95] = 63;
function S3(e) {
    var t = e.length;
    if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var r = e.indexOf("=");
    r === -1 && (r = t);
    var n = r === t ? 0 : 4 - r % 4;
    return [r, n]
}
function $9(e) {
    var t = S3(e)
      , r = t[0]
      , n = t[1];
    return (r + n) * 3 / 4 - n
}
function F9(e, t, r) {
    return (t + r) * 3 / 4 - r
}
function H9(e) {
    var t, r = S3(e), n = r[0], i = r[1], s = new U9(F9(e, n, i)), o = 0, a = i > 0 ? n - 4 : n, u;
    for (u = 0; u < a; u += 4)
        t = tn[e.charCodeAt(u)] << 18 | tn[e.charCodeAt(u + 1)] << 12 | tn[e.charCodeAt(u + 2)] << 6 | tn[e.charCodeAt(u + 3)],
        s[o++] = t >> 16 & 255,
        s[o++] = t >> 8 & 255,
        s[o++] = t & 255;
    return i === 2 && (t = tn[e.charCodeAt(u)] << 2 | tn[e.charCodeAt(u + 1)] >> 4,
    s[o++] = t & 255),
    i === 1 && (t = tn[e.charCodeAt(u)] << 10 | tn[e.charCodeAt(u + 1)] << 4 | tn[e.charCodeAt(u + 2)] >> 2,
    s[o++] = t >> 8 & 255,
    s[o++] = t & 255),
    s
}
function q9(e) {
    return jn[e >> 18 & 63] + jn[e >> 12 & 63] + jn[e >> 6 & 63] + jn[e & 63]
}
function W9(e, t, r) {
    for (var n, i = [], s = t; s < r; s += 3)
        n = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255),
        i.push(q9(n));
    return i.join("")
}
function V9(e) {
    for (var t, r = e.length, n = r % 3, i = [], s = 16383, o = 0, a = r - n; o < a; o += s)
        i.push(W9(e, o, o + s > a ? a : o + s));
    return n === 1 ? (t = e[r - 1],
    i.push(jn[t >> 2] + jn[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1],
    i.push(jn[t >> 10] + jn[t >> 4 & 63] + jn[t << 2 & 63] + "=")),
    i.join("")
}
var Jg = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Jg.read = function(e, t, r, n, i) {
    var s, o, a = i * 8 - n - 1, u = (1 << a) - 1, c = u >> 1, l = -7, p = r ? i - 1 : 0, h = r ? -1 : 1, g = e[t + p];
    for (p += h,
    s = g & (1 << -l) - 1,
    g >>= -l,
    l += a; l > 0; s = s * 256 + e[t + p],
    p += h,
    l -= 8)
        ;
    for (o = s & (1 << -l) - 1,
    s >>= -l,
    l += n; l > 0; o = o * 256 + e[t + p],
    p += h,
    l -= 8)
        ;
    if (s === 0)
        s = 1 - c;
    else {
        if (s === u)
            return o ? NaN : (g ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, n),
        s = s - c
    }
    return (g ? -1 : 1) * o * Math.pow(2, s - n)
}
;
Jg.write = function(e, t, r, n, i, s) {
    var o, a, u, c = s * 8 - i - 1, l = (1 << c) - 1, p = l >> 1, h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = n ? 0 : s - 1, S = n ? 1 : -1, x = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for (t = Math.abs(t),
    isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0,
    o = l) : (o = Math.floor(Math.log(t) / Math.LN2),
    t * (u = Math.pow(2, -o)) < 1 && (o--,
    u *= 2),
    o + p >= 1 ? t += h / u : t += h * Math.pow(2, 1 - p),
    t * u >= 2 && (o++,
    u /= 2),
    o + p >= l ? (a = 0,
    o = l) : o + p >= 1 ? (a = (t * u - 1) * Math.pow(2, i),
    o = o + p) : (a = t * Math.pow(2, p - 1) * Math.pow(2, i),
    o = 0)); i >= 8; e[r + g] = a & 255,
    g += S,
    a /= 256,
    i -= 8)
        ;
    for (o = o << i | a,
    c += i; c > 0; e[r + g] = o & 255,
    g += S,
    o /= 256,
    c -= 8)
        ;
    e[r + g - S] |= x * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
    const t = sd
      , r = Jg
      , n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = a,
    e.SlowBuffer = M,
    e.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    e.kMaxLength = i,
    a.TYPED_ARRAY_SUPPORT = s(),
    !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function s() {
        try {
            const m = new Uint8Array(1)
              , f = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(f, Uint8Array.prototype),
            Object.setPrototypeOf(m, f),
            m.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this))
                return this.byteOffset
        }
    });
    function o(m) {
        if (m > i)
            throw new RangeError('The value "' + m + '" is invalid for option "size"');
        const f = new Uint8Array(m);
        return Object.setPrototypeOf(f, a.prototype),
        f
    }
    function a(m, f, d) {
        if (typeof m == "number") {
            if (typeof f == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return p(m)
        }
        return u(m, f, d)
    }
    a.poolSize = 8192;
    function u(m, f, d) {
        if (typeof m == "string")
            return h(m, f);
        if (ArrayBuffer.isView(m))
            return S(m);
        if (m == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m);
        if (ne(m, ArrayBuffer) || m && ne(m.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ne(m, SharedArrayBuffer) || m && ne(m.buffer, SharedArrayBuffer)))
            return x(m, f, d);
        if (typeof m == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const E = m.valueOf && m.valueOf();
        if (E != null && E !== m)
            return a.from(E, f, d);
        const R = v(m);
        if (R)
            return R;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof m[Symbol.toPrimitive] == "function")
            return a.from(m[Symbol.toPrimitive]("string"), f, d);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m)
    }
    a.from = function(m, f, d) {
        return u(m, f, d)
    }
    ,
    Object.setPrototypeOf(a.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(a, Uint8Array);
    function c(m) {
        if (typeof m != "number")
            throw new TypeError('"size" argument must be of type number');
        if (m < 0)
            throw new RangeError('The value "' + m + '" is invalid for option "size"')
    }
    function l(m, f, d) {
        return c(m),
        m <= 0 ? o(m) : f !== void 0 ? typeof d == "string" ? o(m).fill(f, d) : o(m).fill(f) : o(m)
    }
    a.alloc = function(m, f, d) {
        return l(m, f, d)
    }
    ;
    function p(m) {
        return c(m),
        o(m < 0 ? 0 : I(m) | 0)
    }
    a.allocUnsafe = function(m) {
        return p(m)
    }
    ,
    a.allocUnsafeSlow = function(m) {
        return p(m)
    }
    ;
    function h(m, f) {
        if ((typeof f != "string" || f === "") && (f = "utf8"),
        !a.isEncoding(f))
            throw new TypeError("Unknown encoding: " + f);
        const d = A(m, f) | 0;
        let E = o(d);
        const R = E.write(m, f);
        return R !== d && (E = E.slice(0, R)),
        E
    }
    function g(m) {
        const f = m.length < 0 ? 0 : I(m.length) | 0
          , d = o(f);
        for (let E = 0; E < f; E += 1)
            d[E] = m[E] & 255;
        return d
    }
    function S(m) {
        if (ne(m, Uint8Array)) {
            const f = new Uint8Array(m);
            return x(f.buffer, f.byteOffset, f.byteLength)
        }
        return g(m)
    }
    function x(m, f, d) {
        if (f < 0 || m.byteLength < f)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (m.byteLength < f + (d || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let E;
        return f === void 0 && d === void 0 ? E = new Uint8Array(m) : d === void 0 ? E = new Uint8Array(m,f) : E = new Uint8Array(m,f,d),
        Object.setPrototypeOf(E, a.prototype),
        E
    }
    function v(m) {
        if (a.isBuffer(m)) {
            const f = I(m.length) | 0
              , d = o(f);
            return d.length === 0 || m.copy(d, 0, 0, f),
            d
        }
        if (m.length !== void 0)
            return typeof m.length != "number" || de(m.length) ? o(0) : g(m);
        if (m.type === "Buffer" && Array.isArray(m.data))
            return g(m.data)
    }
    function I(m) {
        if (m >= i)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return m | 0
    }
    function M(m) {
        return +m != m && (m = 0),
        a.alloc(+m)
    }
    a.isBuffer = function(f) {
        return f != null && f._isBuffer === !0 && f !== a.prototype
    }
    ,
    a.compare = function(f, d) {
        if (ne(f, Uint8Array) && (f = a.from(f, f.offset, f.byteLength)),
        ne(d, Uint8Array) && (d = a.from(d, d.offset, d.byteLength)),
        !a.isBuffer(f) || !a.isBuffer(d))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (f === d)
            return 0;
        let E = f.length
          , R = d.length;
        for (let j = 0, V = Math.min(E, R); j < V; ++j)
            if (f[j] !== d[j]) {
                E = f[j],
                R = d[j];
                break
            }
        return E < R ? -1 : R < E ? 1 : 0
    }
    ,
    a.isEncoding = function(f) {
        switch (String(f).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    a.concat = function(f, d) {
        if (!Array.isArray(f))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (f.length === 0)
            return a.alloc(0);
        let E;
        if (d === void 0)
            for (d = 0,
            E = 0; E < f.length; ++E)
                d += f[E].length;
        const R = a.allocUnsafe(d);
        let j = 0;
        for (E = 0; E < f.length; ++E) {
            let V = f[E];
            if (ne(V, Uint8Array))
                j + V.length > R.length ? (a.isBuffer(V) || (V = a.from(V)),
                V.copy(R, j)) : Uint8Array.prototype.set.call(R, V, j);
            else if (a.isBuffer(V))
                V.copy(R, j);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            j += V.length
        }
        return R
    }
    ;
    function A(m, f) {
        if (a.isBuffer(m))
            return m.length;
        if (ArrayBuffer.isView(m) || ne(m, ArrayBuffer))
            return m.byteLength;
        if (typeof m != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof m);
        const d = m.length
          , E = arguments.length > 2 && arguments[2] === !0;
        if (!E && d === 0)
            return 0;
        let R = !1;
        for (; ; )
            switch (f) {
            case "ascii":
            case "latin1":
            case "binary":
                return d;
            case "utf8":
            case "utf-8":
                return X(m).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return d * 2;
            case "hex":
                return d >>> 1;
            case "base64":
                return oe(m).length;
            default:
                if (R)
                    return E ? -1 : X(m).length;
                f = ("" + f).toLowerCase(),
                R = !0
            }
    }
    a.byteLength = A;
    function k(m, f, d) {
        let E = !1;
        if ((f === void 0 || f < 0) && (f = 0),
        f > this.length || ((d === void 0 || d > this.length) && (d = this.length),
        d <= 0) || (d >>>= 0,
        f >>>= 0,
        d <= f))
            return "";
        for (m || (m = "utf8"); ; )
            switch (m) {
            case "hex":
                return P(this, f, d);
            case "utf8":
            case "utf-8":
                return y(this, f, d);
            case "ascii":
                return T(this, f, d);
            case "latin1":
            case "binary":
                return C(this, f, d);
            case "base64":
                return B(this, f, d);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return W(this, f, d);
            default:
                if (E)
                    throw new TypeError("Unknown encoding: " + m);
                m = (m + "").toLowerCase(),
                E = !0
            }
    }
    a.prototype._isBuffer = !0;
    function L(m, f, d) {
        const E = m[f];
        m[f] = m[d],
        m[d] = E
    }
    a.prototype.swap16 = function() {
        const f = this.length;
        if (f % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let d = 0; d < f; d += 2)
            L(this, d, d + 1);
        return this
    }
    ,
    a.prototype.swap32 = function() {
        const f = this.length;
        if (f % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let d = 0; d < f; d += 4)
            L(this, d, d + 3),
            L(this, d + 1, d + 2);
        return this
    }
    ,
    a.prototype.swap64 = function() {
        const f = this.length;
        if (f % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let d = 0; d < f; d += 8)
            L(this, d, d + 7),
            L(this, d + 1, d + 6),
            L(this, d + 2, d + 5),
            L(this, d + 3, d + 4);
        return this
    }
    ,
    a.prototype.toString = function() {
        const f = this.length;
        return f === 0 ? "" : arguments.length === 0 ? y(this, 0, f) : k.apply(this, arguments)
    }
    ,
    a.prototype.toLocaleString = a.prototype.toString,
    a.prototype.equals = function(f) {
        if (!a.isBuffer(f))
            throw new TypeError("Argument must be a Buffer");
        return this === f ? !0 : a.compare(this, f) === 0
    }
    ,
    a.prototype.inspect = function() {
        let f = "";
        const d = e.INSPECT_MAX_BYTES;
        return f = this.toString("hex", 0, d).replace(/(.{2})/g, "$1 ").trim(),
        this.length > d && (f += " ... "),
        "<Buffer " + f + ">"
    }
    ,
    n && (a.prototype[n] = a.prototype.inspect),
    a.prototype.compare = function(f, d, E, R, j) {
        if (ne(f, Uint8Array) && (f = a.from(f, f.offset, f.byteLength)),
        !a.isBuffer(f))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof f);
        if (d === void 0 && (d = 0),
        E === void 0 && (E = f ? f.length : 0),
        R === void 0 && (R = 0),
        j === void 0 && (j = this.length),
        d < 0 || E > f.length || R < 0 || j > this.length)
            throw new RangeError("out of range index");
        if (R >= j && d >= E)
            return 0;
        if (R >= j)
            return -1;
        if (d >= E)
            return 1;
        if (d >>>= 0,
        E >>>= 0,
        R >>>= 0,
        j >>>= 0,
        this === f)
            return 0;
        let V = j - R
          , pe = E - d;
        const _e = Math.min(V, pe)
          , ge = this.slice(R, j)
          , Ce = f.slice(d, E);
        for (let we = 0; we < _e; ++we)
            if (ge[we] !== Ce[we]) {
                V = ge[we],
                pe = Ce[we];
                break
            }
        return V < pe ? -1 : pe < V ? 1 : 0
    }
    ;
    function O(m, f, d, E, R) {
        if (m.length === 0)
            return -1;
        if (typeof d == "string" ? (E = d,
        d = 0) : d > 2147483647 ? d = 2147483647 : d < -2147483648 && (d = -2147483648),
        d = +d,
        de(d) && (d = R ? 0 : m.length - 1),
        d < 0 && (d = m.length + d),
        d >= m.length) {
            if (R)
                return -1;
            d = m.length - 1
        } else if (d < 0)
            if (R)
                d = 0;
            else
                return -1;
        if (typeof f == "string" && (f = a.from(f, E)),
        a.isBuffer(f))
            return f.length === 0 ? -1 : $(m, f, d, E, R);
        if (typeof f == "number")
            return f = f & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? R ? Uint8Array.prototype.indexOf.call(m, f, d) : Uint8Array.prototype.lastIndexOf.call(m, f, d) : $(m, [f], d, E, R);
        throw new TypeError("val must be string, number or Buffer")
    }
    function $(m, f, d, E, R) {
        let j = 1
          , V = m.length
          , pe = f.length;
        if (E !== void 0 && (E = String(E).toLowerCase(),
        E === "ucs2" || E === "ucs-2" || E === "utf16le" || E === "utf-16le")) {
            if (m.length < 2 || f.length < 2)
                return -1;
            j = 2,
            V /= 2,
            pe /= 2,
            d /= 2
        }
        function _e(Ce, we) {
            return j === 1 ? Ce[we] : Ce.readUInt16BE(we * j)
        }
        let ge;
        if (R) {
            let Ce = -1;
            for (ge = d; ge < V; ge++)
                if (_e(m, ge) === _e(f, Ce === -1 ? 0 : ge - Ce)) {
                    if (Ce === -1 && (Ce = ge),
                    ge - Ce + 1 === pe)
                        return Ce * j
                } else
                    Ce !== -1 && (ge -= ge - Ce),
                    Ce = -1
        } else
            for (d + pe > V && (d = V - pe),
            ge = d; ge >= 0; ge--) {
                let Ce = !0;
                for (let we = 0; we < pe; we++)
                    if (_e(m, ge + we) !== _e(f, we)) {
                        Ce = !1;
                        break
                    }
                if (Ce)
                    return ge
            }
        return -1
    }
    a.prototype.includes = function(f, d, E) {
        return this.indexOf(f, d, E) !== -1
    }
    ,
    a.prototype.indexOf = function(f, d, E) {
        return O(this, f, d, E, !0)
    }
    ,
    a.prototype.lastIndexOf = function(f, d, E) {
        return O(this, f, d, E, !1)
    }
    ;
    function D(m, f, d, E) {
        d = Number(d) || 0;
        const R = m.length - d;
        E ? (E = Number(E),
        E > R && (E = R)) : E = R;
        const j = f.length;
        E > j / 2 && (E = j / 2);
        let V;
        for (V = 0; V < E; ++V) {
            const pe = parseInt(f.substr(V * 2, 2), 16);
            if (de(pe))
                return V;
            m[d + V] = pe
        }
        return V
    }
    function K(m, f, d, E) {
        return ae(X(f, m.length - d), m, d, E)
    }
    function G(m, f, d, E) {
        return ae(ce(f), m, d, E)
    }
    function F(m, f, d, E) {
        return ae(oe(f), m, d, E)
    }
    function q(m, f, d, E) {
        return ae(me(f, m.length - d), m, d, E)
    }
    a.prototype.write = function(f, d, E, R) {
        if (d === void 0)
            R = "utf8",
            E = this.length,
            d = 0;
        else if (E === void 0 && typeof d == "string")
            R = d,
            E = this.length,
            d = 0;
        else if (isFinite(d))
            d = d >>> 0,
            isFinite(E) ? (E = E >>> 0,
            R === void 0 && (R = "utf8")) : (R = E,
            E = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const j = this.length - d;
        if ((E === void 0 || E > j) && (E = j),
        f.length > 0 && (E < 0 || d < 0) || d > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        R || (R = "utf8");
        let V = !1;
        for (; ; )
            switch (R) {
            case "hex":
                return D(this, f, d, E);
            case "utf8":
            case "utf-8":
                return K(this, f, d, E);
            case "ascii":
            case "latin1":
            case "binary":
                return G(this, f, d, E);
            case "base64":
                return F(this, f, d, E);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return q(this, f, d, E);
            default:
                if (V)
                    throw new TypeError("Unknown encoding: " + R);
                R = ("" + R).toLowerCase(),
                V = !0
            }
    }
    ,
    a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function B(m, f, d) {
        return f === 0 && d === m.length ? t.fromByteArray(m) : t.fromByteArray(m.slice(f, d))
    }
    function y(m, f, d) {
        d = Math.min(m.length, d);
        const E = [];
        let R = f;
        for (; R < d; ) {
            const j = m[R];
            let V = null
              , pe = j > 239 ? 4 : j > 223 ? 3 : j > 191 ? 2 : 1;
            if (R + pe <= d) {
                let _e, ge, Ce, we;
                switch (pe) {
                case 1:
                    j < 128 && (V = j);
                    break;
                case 2:
                    _e = m[R + 1],
                    (_e & 192) === 128 && (we = (j & 31) << 6 | _e & 63,
                    we > 127 && (V = we));
                    break;
                case 3:
                    _e = m[R + 1],
                    ge = m[R + 2],
                    (_e & 192) === 128 && (ge & 192) === 128 && (we = (j & 15) << 12 | (_e & 63) << 6 | ge & 63,
                    we > 2047 && (we < 55296 || we > 57343) && (V = we));
                    break;
                case 4:
                    _e = m[R + 1],
                    ge = m[R + 2],
                    Ce = m[R + 3],
                    (_e & 192) === 128 && (ge & 192) === 128 && (Ce & 192) === 128 && (we = (j & 15) << 18 | (_e & 63) << 12 | (ge & 63) << 6 | Ce & 63,
                    we > 65535 && we < 1114112 && (V = we))
                }
            }
            V === null ? (V = 65533,
            pe = 1) : V > 65535 && (V -= 65536,
            E.push(V >>> 10 & 1023 | 55296),
            V = 56320 | V & 1023),
            E.push(V),
            R += pe
        }
        return _(E)
    }
    const b = 4096;
    function _(m) {
        const f = m.length;
        if (f <= b)
            return String.fromCharCode.apply(String, m);
        let d = ""
          , E = 0;
        for (; E < f; )
            d += String.fromCharCode.apply(String, m.slice(E, E += b));
        return d
    }
    function T(m, f, d) {
        let E = "";
        d = Math.min(m.length, d);
        for (let R = f; R < d; ++R)
            E += String.fromCharCode(m[R] & 127);
        return E
    }
    function C(m, f, d) {
        let E = "";
        d = Math.min(m.length, d);
        for (let R = f; R < d; ++R)
            E += String.fromCharCode(m[R]);
        return E
    }
    function P(m, f, d) {
        const E = m.length;
        (!f || f < 0) && (f = 0),
        (!d || d < 0 || d > E) && (d = E);
        let R = "";
        for (let j = f; j < d; ++j)
            R += ye[m[j]];
        return R
    }
    function W(m, f, d) {
        const E = m.slice(f, d);
        let R = "";
        for (let j = 0; j < E.length - 1; j += 2)
            R += String.fromCharCode(E[j] + E[j + 1] * 256);
        return R
    }
    a.prototype.slice = function(f, d) {
        const E = this.length;
        f = ~~f,
        d = d === void 0 ? E : ~~d,
        f < 0 ? (f += E,
        f < 0 && (f = 0)) : f > E && (f = E),
        d < 0 ? (d += E,
        d < 0 && (d = 0)) : d > E && (d = E),
        d < f && (d = f);
        const R = this.subarray(f, d);
        return Object.setPrototypeOf(R, a.prototype),
        R
    }
    ;
    function N(m, f, d) {
        if (m % 1 !== 0 || m < 0)
            throw new RangeError("offset is not uint");
        if (m + f > d)
            throw new RangeError("Trying to access beyond buffer length")
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(f, d, E) {
        f = f >>> 0,
        d = d >>> 0,
        E || N(f, d, this.length);
        let R = this[f]
          , j = 1
          , V = 0;
        for (; ++V < d && (j *= 256); )
            R += this[f + V] * j;
        return R
    }
    ,
    a.prototype.readUintBE = a.prototype.readUIntBE = function(f, d, E) {
        f = f >>> 0,
        d = d >>> 0,
        E || N(f, d, this.length);
        let R = this[f + --d]
          , j = 1;
        for (; d > 0 && (j *= 256); )
            R += this[f + --d] * j;
        return R
    }
    ,
    a.prototype.readUint8 = a.prototype.readUInt8 = function(f, d) {
        return f = f >>> 0,
        d || N(f, 1, this.length),
        this[f]
    }
    ,
    a.prototype.readUint16LE = a.prototype.readUInt16LE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 2, this.length),
        this[f] | this[f + 1] << 8
    }
    ,
    a.prototype.readUint16BE = a.prototype.readUInt16BE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 2, this.length),
        this[f] << 8 | this[f + 1]
    }
    ,
    a.prototype.readUint32LE = a.prototype.readUInt32LE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        (this[f] | this[f + 1] << 8 | this[f + 2] << 16) + this[f + 3] * 16777216
    }
    ,
    a.prototype.readUint32BE = a.prototype.readUInt32BE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        this[f] * 16777216 + (this[f + 1] << 16 | this[f + 2] << 8 | this[f + 3])
    }
    ,
    a.prototype.readBigUInt64LE = ve(function(f) {
        f = f >>> 0,
        z(f, "offset");
        const d = this[f]
          , E = this[f + 7];
        (d === void 0 || E === void 0) && H(f, this.length - 8);
        const R = d + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24
          , j = this[++f] + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + E * 2 ** 24;
        return BigInt(R) + (BigInt(j) << BigInt(32))
    }),
    a.prototype.readBigUInt64BE = ve(function(f) {
        f = f >>> 0,
        z(f, "offset");
        const d = this[f]
          , E = this[f + 7];
        (d === void 0 || E === void 0) && H(f, this.length - 8);
        const R = d * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f]
          , j = this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + E;
        return (BigInt(R) << BigInt(32)) + BigInt(j)
    }),
    a.prototype.readIntLE = function(f, d, E) {
        f = f >>> 0,
        d = d >>> 0,
        E || N(f, d, this.length);
        let R = this[f]
          , j = 1
          , V = 0;
        for (; ++V < d && (j *= 256); )
            R += this[f + V] * j;
        return j *= 128,
        R >= j && (R -= Math.pow(2, 8 * d)),
        R
    }
    ,
    a.prototype.readIntBE = function(f, d, E) {
        f = f >>> 0,
        d = d >>> 0,
        E || N(f, d, this.length);
        let R = d
          , j = 1
          , V = this[f + --R];
        for (; R > 0 && (j *= 256); )
            V += this[f + --R] * j;
        return j *= 128,
        V >= j && (V -= Math.pow(2, 8 * d)),
        V
    }
    ,
    a.prototype.readInt8 = function(f, d) {
        return f = f >>> 0,
        d || N(f, 1, this.length),
        this[f] & 128 ? (255 - this[f] + 1) * -1 : this[f]
    }
    ,
    a.prototype.readInt16LE = function(f, d) {
        f = f >>> 0,
        d || N(f, 2, this.length);
        const E = this[f] | this[f + 1] << 8;
        return E & 32768 ? E | 4294901760 : E
    }
    ,
    a.prototype.readInt16BE = function(f, d) {
        f = f >>> 0,
        d || N(f, 2, this.length);
        const E = this[f + 1] | this[f] << 8;
        return E & 32768 ? E | 4294901760 : E
    }
    ,
    a.prototype.readInt32LE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        this[f] | this[f + 1] << 8 | this[f + 2] << 16 | this[f + 3] << 24
    }
    ,
    a.prototype.readInt32BE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        this[f] << 24 | this[f + 1] << 16 | this[f + 2] << 8 | this[f + 3]
    }
    ,
    a.prototype.readBigInt64LE = ve(function(f) {
        f = f >>> 0,
        z(f, "offset");
        const d = this[f]
          , E = this[f + 7];
        (d === void 0 || E === void 0) && H(f, this.length - 8);
        const R = this[f + 4] + this[f + 5] * 2 ** 8 + this[f + 6] * 2 ** 16 + (E << 24);
        return (BigInt(R) << BigInt(32)) + BigInt(d + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24)
    }),
    a.prototype.readBigInt64BE = ve(function(f) {
        f = f >>> 0,
        z(f, "offset");
        const d = this[f]
          , E = this[f + 7];
        (d === void 0 || E === void 0) && H(f, this.length - 8);
        const R = (d << 24) + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f];
        return (BigInt(R) << BigInt(32)) + BigInt(this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + E)
    }),
    a.prototype.readFloatLE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        r.read(this, f, !0, 23, 4)
    }
    ,
    a.prototype.readFloatBE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        r.read(this, f, !1, 23, 4)
    }
    ,
    a.prototype.readDoubleLE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 8, this.length),
        r.read(this, f, !0, 52, 8)
    }
    ,
    a.prototype.readDoubleBE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 8, this.length),
        r.read(this, f, !1, 52, 8)
    }
    ;
    function w(m, f, d, E, R, j) {
        if (!a.isBuffer(m))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (f > R || f < j)
            throw new RangeError('"value" argument is out of bounds');
        if (d + E > m.length)
            throw new RangeError("Index out of range")
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(f, d, E, R) {
        if (f = +f,
        d = d >>> 0,
        E = E >>> 0,
        !R) {
            const pe = Math.pow(2, 8 * E) - 1;
            w(this, f, d, E, pe, 0)
        }
        let j = 1
          , V = 0;
        for (this[d] = f & 255; ++V < E && (j *= 256); )
            this[d + V] = f / j & 255;
        return d + E
    }
    ,
    a.prototype.writeUintBE = a.prototype.writeUIntBE = function(f, d, E, R) {
        if (f = +f,
        d = d >>> 0,
        E = E >>> 0,
        !R) {
            const pe = Math.pow(2, 8 * E) - 1;
            w(this, f, d, E, pe, 0)
        }
        let j = E - 1
          , V = 1;
        for (this[d + j] = f & 255; --j >= 0 && (V *= 256); )
            this[d + j] = f / V & 255;
        return d + E
    }
    ,
    a.prototype.writeUint8 = a.prototype.writeUInt8 = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 1, 255, 0),
        this[d] = f & 255,
        d + 1
    }
    ,
    a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 2, 65535, 0),
        this[d] = f & 255,
        this[d + 1] = f >>> 8,
        d + 2
    }
    ,
    a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 2, 65535, 0),
        this[d] = f >>> 8,
        this[d + 1] = f & 255,
        d + 2
    }
    ,
    a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 4, 4294967295, 0),
        this[d + 3] = f >>> 24,
        this[d + 2] = f >>> 16,
        this[d + 1] = f >>> 8,
        this[d] = f & 255,
        d + 4
    }
    ,
    a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 4, 4294967295, 0),
        this[d] = f >>> 24,
        this[d + 1] = f >>> 16,
        this[d + 2] = f >>> 8,
        this[d + 3] = f & 255,
        d + 4
    }
    ;
    function U(m, f, d, E, R) {
        Ae(f, E, R, m, d, 7);
        let j = Number(f & BigInt(4294967295));
        m[d++] = j,
        j = j >> 8,
        m[d++] = j,
        j = j >> 8,
        m[d++] = j,
        j = j >> 8,
        m[d++] = j;
        let V = Number(f >> BigInt(32) & BigInt(4294967295));
        return m[d++] = V,
        V = V >> 8,
        m[d++] = V,
        V = V >> 8,
        m[d++] = V,
        V = V >> 8,
        m[d++] = V,
        d
    }
    function re(m, f, d, E, R) {
        Ae(f, E, R, m, d, 7);
        let j = Number(f & BigInt(4294967295));
        m[d + 7] = j,
        j = j >> 8,
        m[d + 6] = j,
        j = j >> 8,
        m[d + 5] = j,
        j = j >> 8,
        m[d + 4] = j;
        let V = Number(f >> BigInt(32) & BigInt(4294967295));
        return m[d + 3] = V,
        V = V >> 8,
        m[d + 2] = V,
        V = V >> 8,
        m[d + 1] = V,
        V = V >> 8,
        m[d] = V,
        d + 8
    }
    a.prototype.writeBigUInt64LE = ve(function(f, d=0) {
        return U(this, f, d, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    a.prototype.writeBigUInt64BE = ve(function(f, d=0) {
        return re(this, f, d, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    a.prototype.writeIntLE = function(f, d, E, R) {
        if (f = +f,
        d = d >>> 0,
        !R) {
            const _e = Math.pow(2, 8 * E - 1);
            w(this, f, d, E, _e - 1, -_e)
        }
        let j = 0
          , V = 1
          , pe = 0;
        for (this[d] = f & 255; ++j < E && (V *= 256); )
            f < 0 && pe === 0 && this[d + j - 1] !== 0 && (pe = 1),
            this[d + j] = (f / V >> 0) - pe & 255;
        return d + E
    }
    ,
    a.prototype.writeIntBE = function(f, d, E, R) {
        if (f = +f,
        d = d >>> 0,
        !R) {
            const _e = Math.pow(2, 8 * E - 1);
            w(this, f, d, E, _e - 1, -_e)
        }
        let j = E - 1
          , V = 1
          , pe = 0;
        for (this[d + j] = f & 255; --j >= 0 && (V *= 256); )
            f < 0 && pe === 0 && this[d + j + 1] !== 0 && (pe = 1),
            this[d + j] = (f / V >> 0) - pe & 255;
        return d + E
    }
    ,
    a.prototype.writeInt8 = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 1, 127, -128),
        f < 0 && (f = 255 + f + 1),
        this[d] = f & 255,
        d + 1
    }
    ,
    a.prototype.writeInt16LE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 2, 32767, -32768),
        this[d] = f & 255,
        this[d + 1] = f >>> 8,
        d + 2
    }
    ,
    a.prototype.writeInt16BE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 2, 32767, -32768),
        this[d] = f >>> 8,
        this[d + 1] = f & 255,
        d + 2
    }
    ,
    a.prototype.writeInt32LE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 4, 2147483647, -2147483648),
        this[d] = f & 255,
        this[d + 1] = f >>> 8,
        this[d + 2] = f >>> 16,
        this[d + 3] = f >>> 24,
        d + 4
    }
    ,
    a.prototype.writeInt32BE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 4, 2147483647, -2147483648),
        f < 0 && (f = 4294967295 + f + 1),
        this[d] = f >>> 24,
        this[d + 1] = f >>> 16,
        this[d + 2] = f >>> 8,
        this[d + 3] = f & 255,
        d + 4
    }
    ,
    a.prototype.writeBigInt64LE = ve(function(f, d=0) {
        return U(this, f, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    a.prototype.writeBigInt64BE = ve(function(f, d=0) {
        return re(this, f, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function ie(m, f, d, E, R, j) {
        if (d + E > m.length)
            throw new RangeError("Index out of range");
        if (d < 0)
            throw new RangeError("Index out of range")
    }
    function ue(m, f, d, E, R) {
        return f = +f,
        d = d >>> 0,
        R || ie(m, f, d, 4),
        r.write(m, f, d, E, 23, 4),
        d + 4
    }
    a.prototype.writeFloatLE = function(f, d, E) {
        return ue(this, f, d, !0, E)
    }
    ,
    a.prototype.writeFloatBE = function(f, d, E) {
        return ue(this, f, d, !1, E)
    }
    ;
    function Q(m, f, d, E, R) {
        return f = +f,
        d = d >>> 0,
        R || ie(m, f, d, 8),
        r.write(m, f, d, E, 52, 8),
        d + 8
    }
    a.prototype.writeDoubleLE = function(f, d, E) {
        return Q(this, f, d, !0, E)
    }
    ,
    a.prototype.writeDoubleBE = function(f, d, E) {
        return Q(this, f, d, !1, E)
    }
    ,
    a.prototype.copy = function(f, d, E, R) {
        if (!a.isBuffer(f))
            throw new TypeError("argument should be a Buffer");
        if (E || (E = 0),
        !R && R !== 0 && (R = this.length),
        d >= f.length && (d = f.length),
        d || (d = 0),
        R > 0 && R < E && (R = E),
        R === E || f.length === 0 || this.length === 0)
            return 0;
        if (d < 0)
            throw new RangeError("targetStart out of bounds");
        if (E < 0 || E >= this.length)
            throw new RangeError("Index out of range");
        if (R < 0)
            throw new RangeError("sourceEnd out of bounds");
        R > this.length && (R = this.length),
        f.length - d < R - E && (R = f.length - d + E);
        const j = R - E;
        return this === f && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(d, E, R) : Uint8Array.prototype.set.call(f, this.subarray(E, R), d),
        j
    }
    ,
    a.prototype.fill = function(f, d, E, R) {
        if (typeof f == "string") {
            if (typeof d == "string" ? (R = d,
            d = 0,
            E = this.length) : typeof E == "string" && (R = E,
            E = this.length),
            R !== void 0 && typeof R != "string")
                throw new TypeError("encoding must be a string");
            if (typeof R == "string" && !a.isEncoding(R))
                throw new TypeError("Unknown encoding: " + R);
            if (f.length === 1) {
                const V = f.charCodeAt(0);
                (R === "utf8" && V < 128 || R === "latin1") && (f = V)
            }
        } else
            typeof f == "number" ? f = f & 255 : typeof f == "boolean" && (f = Number(f));
        if (d < 0 || this.length < d || this.length < E)
            throw new RangeError("Out of range index");
        if (E <= d)
            return this;
        d = d >>> 0,
        E = E === void 0 ? this.length : E >>> 0,
        f || (f = 0);
        let j;
        if (typeof f == "number")
            for (j = d; j < E; ++j)
                this[j] = f;
        else {
            const V = a.isBuffer(f) ? f : a.from(f, R)
              , pe = V.length;
            if (pe === 0)
                throw new TypeError('The value "' + f + '" is invalid for argument "value"');
            for (j = 0; j < E - d; ++j)
                this[j + d] = V[j % pe]
        }
        return this
    }
    ;
    const ee = {};
    function te(m, f, d) {
        ee[m] = class extends d {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: f.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${m}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return m
            }
            set code(R) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: R,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${m}]: ${this.message}`
            }
        }
    }
    te("ERR_BUFFER_OUT_OF_BOUNDS", function(m) {
        return m ? `${m} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    te("ERR_INVALID_ARG_TYPE", function(m, f) {
        return `The "${m}" argument must be of type number. Received type ${typeof f}`
    }, TypeError),
    te("ERR_OUT_OF_RANGE", function(m, f, d) {
        let E = `The value of "${m}" is out of range.`
          , R = d;
        return Number.isInteger(d) && Math.abs(d) > 2 ** 32 ? R = he(String(d)) : typeof d == "bigint" && (R = String(d),
        (d > BigInt(2) ** BigInt(32) || d < -(BigInt(2) ** BigInt(32))) && (R = he(R)),
        R += "n"),
        E += ` It must be ${f}. Received ${R}`,
        E
    }, RangeError);
    function he(m) {
        let f = ""
          , d = m.length;
        const E = m[0] === "-" ? 1 : 0;
        for (; d >= E + 4; d -= 3)
            f = `_${m.slice(d - 3, d)}${f}`;
        return `${m.slice(0, d)}${f}`
    }
    function xe(m, f, d) {
        z(f, "offset"),
        (m[f] === void 0 || m[f + d] === void 0) && H(f, m.length - (d + 1))
    }
    function Ae(m, f, d, E, R, j) {
        if (m > d || m < f) {
            const V = typeof f == "bigint" ? "n" : "";
            let pe;
            throw j > 3 ? f === 0 || f === BigInt(0) ? pe = `>= 0${V} and < 2${V} ** ${(j + 1) * 8}${V}` : pe = `>= -(2${V} ** ${(j + 1) * 8 - 1}${V}) and < 2 ** ${(j + 1) * 8 - 1}${V}` : pe = `>= ${f}${V} and <= ${d}${V}`,
            new ee.ERR_OUT_OF_RANGE("value",pe,m)
        }
        xe(E, R, j)
    }
    function z(m, f) {
        if (typeof m != "number")
            throw new ee.ERR_INVALID_ARG_TYPE(f,"number",m)
    }
    function H(m, f, d) {
        throw Math.floor(m) !== m ? (z(m, d),
        new ee.ERR_OUT_OF_RANGE(d || "offset","an integer",m)) : f < 0 ? new ee.ERR_BUFFER_OUT_OF_BOUNDS : new ee.ERR_OUT_OF_RANGE(d || "offset",`>= ${d ? 1 : 0} and <= ${f}`,m)
    }
    const Y = /[^+/0-9A-Za-z-_]/g;
    function se(m) {
        if (m = m.split("=")[0],
        m = m.trim().replace(Y, ""),
        m.length < 2)
            return "";
        for (; m.length % 4 !== 0; )
            m = m + "=";
        return m
    }
    function X(m, f) {
        f = f || 1 / 0;
        let d;
        const E = m.length;
        let R = null;
        const j = [];
        for (let V = 0; V < E; ++V) {
            if (d = m.charCodeAt(V),
            d > 55295 && d < 57344) {
                if (!R) {
                    if (d > 56319) {
                        (f -= 3) > -1 && j.push(239, 191, 189);
                        continue
                    } else if (V + 1 === E) {
                        (f -= 3) > -1 && j.push(239, 191, 189);
                        continue
                    }
                    R = d;
                    continue
                }
                if (d < 56320) {
                    (f -= 3) > -1 && j.push(239, 191, 189),
                    R = d;
                    continue
                }
                d = (R - 55296 << 10 | d - 56320) + 65536
            } else
                R && (f -= 3) > -1 && j.push(239, 191, 189);
            if (R = null,
            d < 128) {
                if ((f -= 1) < 0)
                    break;
                j.push(d)
            } else if (d < 2048) {
                if ((f -= 2) < 0)
                    break;
                j.push(d >> 6 | 192, d & 63 | 128)
            } else if (d < 65536) {
                if ((f -= 3) < 0)
                    break;
                j.push(d >> 12 | 224, d >> 6 & 63 | 128, d & 63 | 128)
            } else if (d < 1114112) {
                if ((f -= 4) < 0)
                    break;
                j.push(d >> 18 | 240, d >> 12 & 63 | 128, d >> 6 & 63 | 128, d & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return j
    }
    function ce(m) {
        const f = [];
        for (let d = 0; d < m.length; ++d)
            f.push(m.charCodeAt(d) & 255);
        return f
    }
    function me(m, f) {
        let d, E, R;
        const j = [];
        for (let V = 0; V < m.length && !((f -= 2) < 0); ++V)
            d = m.charCodeAt(V),
            E = d >> 8,
            R = d % 256,
            j.push(R),
            j.push(E);
        return j
    }
    function oe(m) {
        return t.toByteArray(se(m))
    }
    function ae(m, f, d, E) {
        let R;
        for (R = 0; R < E && !(R + d >= f.length || R >= m.length); ++R)
            f[R + d] = m[R];
        return R
    }
    function ne(m, f) {
        return m instanceof f || m != null && m.constructor != null && m.constructor.name != null && m.constructor.name === f.name
    }
    function de(m) {
        return m !== m
    }
    const ye = function() {
        const m = "0123456789abcdef"
          , f = new Array(256);
        for (let d = 0; d < 16; ++d) {
            const E = d * 16;
            for (let R = 0; R < 16; ++R)
                f[E + R] = m[d] + m[R]
        }
        return f
    }();
    function ve(m) {
        return typeof BigInt > "u" ? Ee : m
    }
    function Ee() {
        throw new Error("BigInt not supported")
    }
}
)($e);
function ob(e) {
    if (!Number.isSafeInteger(e) || e < 0)
        throw new Error(`positive integer expected, not ${e}`)
}
function K9(e) {
    return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array"
}
function od(e, ...t) {
    if (!K9(e))
        throw new Error("Uint8Array expected");
    if (t.length > 0 && !t.includes(e.length))
        throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)
}
function G9(e) {
    if (typeof e != "function" || typeof e.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
    ob(e.outputLen),
    ob(e.blockLen)
}
function of(e, t=!0) {
    if (e.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (t && e.finished)
        throw new Error("Hash#digest() has already been called")
}
function Q9(e, t) {
    od(e);
    const r = t.outputLen;
    if (e.length < r)
        throw new Error(`digestInto() expects output buffer of length at least ${r}`)
}
const E0 = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const S0 = e => new DataView(e.buffer,e.byteOffset,e.byteLength)
  , kn = (e, t) => e << 32 - t | e >>> t;
new Uint8Array(new Uint32Array([287454020]).buffer)[0];
function _3(e) {
    if (typeof e != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e))
}
function Xg(e) {
    return typeof e == "string" && (e = _3(e)),
    od(e),
    e
}
function A3(...e) {
    let t = 0;
    for (let n = 0; n < e.length; n++) {
        const i = e[n];
        od(i),
        t += i.length
    }
    const r = new Uint8Array(t);
    for (let n = 0, i = 0; n < e.length; n++) {
        const s = e[n];
        r.set(s, i),
        i += s.length
    }
    return r
}
let M3 = class {
    clone() {
        return this._cloneInto()
    }
}
;
function I3(e) {
    const t = n => e().update(Xg(n)).digest()
      , r = e();
    return t.outputLen = r.outputLen,
    t.blockLen = r.blockLen,
    t.create = () => e(),
    t
}
function T3(e=32) {
    if (E0 && typeof E0.getRandomValues == "function")
        return E0.getRandomValues(new Uint8Array(e));
    throw new Error("crypto.getRandomValues must be defined")
}
function Y9(e, t, r, n) {
    if (typeof e.setBigUint64 == "function")
        return e.setBigUint64(t, r, n);
    const i = BigInt(32)
      , s = BigInt(4294967295)
      , o = Number(r >> i & s)
      , a = Number(r & s)
      , u = n ? 4 : 0
      , c = n ? 0 : 4;
    e.setUint32(t + u, o, n),
    e.setUint32(t + c, a, n)
}
const Z9 = (e, t, r) => e & t ^ ~e & r
  , J9 = (e, t, r) => e & t ^ e & r ^ t & r;
class C3 extends M3 {
    constructor(t, r, n, i) {
        super(),
        this.blockLen = t,
        this.outputLen = r,
        this.padOffset = n,
        this.isLE = i,
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.buffer = new Uint8Array(t),
        this.view = S0(this.buffer)
    }
    update(t) {
        of(this);
        const {view: r, buffer: n, blockLen: i} = this;
        t = Xg(t);
        const s = t.length;
        for (let o = 0; o < s; ) {
            const a = Math.min(i - this.pos, s - o);
            if (a === i) {
                const u = S0(t);
                for (; i <= s - o; o += i)
                    this.process(u, o);
                continue
            }
            n.set(t.subarray(o, o + a), this.pos),
            this.pos += a,
            o += a,
            this.pos === i && (this.process(r, 0),
            this.pos = 0)
        }
        return this.length += t.length,
        this.roundClean(),
        this
    }
    digestInto(t) {
        of(this),
        Q9(t, this),
        this.finished = !0;
        const {buffer: r, view: n, blockLen: i, isLE: s} = this;
        let {pos: o} = this;
        r[o++] = 128,
        this.buffer.subarray(o).fill(0),
        this.padOffset > i - o && (this.process(n, 0),
        o = 0);
        for (let p = o; p < i; p++)
            r[p] = 0;
        Y9(n, i - 8, BigInt(this.length * 8), s),
        this.process(n, 0);
        const a = S0(t)
          , u = this.outputLen;
        if (u % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = u / 4
          , l = this.get();
        if (c > l.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let p = 0; p < c; p++)
            a.setUint32(4 * p, l[p], s)
    }
    digest() {
        const {buffer: t, outputLen: r} = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(),
        n
    }
    _cloneInto(t) {
        t || (t = new this.constructor),
        t.set(...this.get());
        const {blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a} = this;
        return t.length = i,
        t.pos = a,
        t.finished = s,
        t.destroyed = o,
        i % r && t.buffer.set(n),
        t
    }
}
const Kc = BigInt(2 ** 32 - 1)
  , np = BigInt(32);
function k3(e, t=!1) {
    return t ? {
        h: Number(e & Kc),
        l: Number(e >> np & Kc)
    } : {
        h: Number(e >> np & Kc) | 0,
        l: Number(e & Kc) | 0
    }
}
function X9(e, t=!1) {
    let r = new Uint32Array(e.length)
      , n = new Uint32Array(e.length);
    for (let i = 0; i < e.length; i++) {
        const {h: s, l: o} = k3(e[i], t);
        [r[i],n[i]] = [s, o]
    }
    return [r, n]
}
const eN = (e, t) => BigInt(e >>> 0) << np | BigInt(t >>> 0)
  , tN = (e, t, r) => e >>> r
  , rN = (e, t, r) => e << 32 - r | t >>> r
  , nN = (e, t, r) => e >>> r | t << 32 - r
  , iN = (e, t, r) => e << 32 - r | t >>> r
  , sN = (e, t, r) => e << 64 - r | t >>> r - 32
  , oN = (e, t, r) => e >>> r - 32 | t << 64 - r
  , aN = (e, t) => t
  , uN = (e, t) => e
  , cN = (e, t, r) => e << r | t >>> 32 - r
  , lN = (e, t, r) => t << r | e >>> 32 - r
  , fN = (e, t, r) => t << r - 32 | e >>> 64 - r
  , dN = (e, t, r) => e << r - 32 | t >>> 64 - r;
function hN(e, t, r, n) {
    const i = (t >>> 0) + (n >>> 0);
    return {
        h: e + r + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    }
}
const pN = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0)
  , gN = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0
  , mN = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0)
  , yN = (e, t, r, n, i) => t + r + n + i + (e / 2 ** 32 | 0) | 0
  , bN = (e, t, r, n, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0)
  , wN = (e, t, r, n, i, s) => t + r + n + i + s + (e / 2 ** 32 | 0) | 0
  , He = {
    fromBig: k3,
    split: X9,
    toBig: eN,
    shrSH: tN,
    shrSL: rN,
    rotrSH: nN,
    rotrSL: iN,
    rotrBH: sN,
    rotrBL: oN,
    rotr32H: aN,
    rotr32L: uN,
    rotlSH: cN,
    rotlSL: lN,
    rotlBH: fN,
    rotlBL: dN,
    add: hN,
    add3L: pN,
    add3H: gN,
    add4L: mN,
    add4H: yN,
    add5H: wN,
    add5L: bN
}
  , [vN,xN] = He.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(e => BigInt(e)))
  , Ci = new Uint32Array(80)
  , ki = new Uint32Array(80);
class EN extends C3 {
    constructor() {
        super(128, 64, 16, !1),
        this.Ah = 1779033703,
        this.Al = -205731576,
        this.Bh = -1150833019,
        this.Bl = -2067093701,
        this.Ch = 1013904242,
        this.Cl = -23791573,
        this.Dh = -1521486534,
        this.Dl = 1595750129,
        this.Eh = 1359893119,
        this.El = -1377402159,
        this.Fh = -1694144372,
        this.Fl = 725511199,
        this.Gh = 528734635,
        this.Gl = -79577749,
        this.Hh = 1541459225,
        this.Hl = 327033209
    }
    get() {
        const {Ah: t, Al: r, Bh: n, Bl: i, Ch: s, Cl: o, Dh: a, Dl: u, Eh: c, El: l, Fh: p, Fl: h, Gh: g, Gl: S, Hh: x, Hl: v} = this;
        return [t, r, n, i, s, o, a, u, c, l, p, h, g, S, x, v]
    }
    set(t, r, n, i, s, o, a, u, c, l, p, h, g, S, x, v) {
        this.Ah = t | 0,
        this.Al = r | 0,
        this.Bh = n | 0,
        this.Bl = i | 0,
        this.Ch = s | 0,
        this.Cl = o | 0,
        this.Dh = a | 0,
        this.Dl = u | 0,
        this.Eh = c | 0,
        this.El = l | 0,
        this.Fh = p | 0,
        this.Fl = h | 0,
        this.Gh = g | 0,
        this.Gl = S | 0,
        this.Hh = x | 0,
        this.Hl = v | 0
    }
    process(t, r) {
        for (let A = 0; A < 16; A++,
        r += 4)
            Ci[A] = t.getUint32(r),
            ki[A] = t.getUint32(r += 4);
        for (let A = 16; A < 80; A++) {
            const k = Ci[A - 15] | 0
              , L = ki[A - 15] | 0
              , O = He.rotrSH(k, L, 1) ^ He.rotrSH(k, L, 8) ^ He.shrSH(k, L, 7)
              , $ = He.rotrSL(k, L, 1) ^ He.rotrSL(k, L, 8) ^ He.shrSL(k, L, 7)
              , D = Ci[A - 2] | 0
              , K = ki[A - 2] | 0
              , G = He.rotrSH(D, K, 19) ^ He.rotrBH(D, K, 61) ^ He.shrSH(D, K, 6)
              , F = He.rotrSL(D, K, 19) ^ He.rotrBL(D, K, 61) ^ He.shrSL(D, K, 6)
              , q = He.add4L($, F, ki[A - 7], ki[A - 16])
              , B = He.add4H(q, O, G, Ci[A - 7], Ci[A - 16]);
            Ci[A] = B | 0,
            ki[A] = q | 0
        }
        let {Ah: n, Al: i, Bh: s, Bl: o, Ch: a, Cl: u, Dh: c, Dl: l, Eh: p, El: h, Fh: g, Fl: S, Gh: x, Gl: v, Hh: I, Hl: M} = this;
        for (let A = 0; A < 80; A++) {
            const k = He.rotrSH(p, h, 14) ^ He.rotrSH(p, h, 18) ^ He.rotrBH(p, h, 41)
              , L = He.rotrSL(p, h, 14) ^ He.rotrSL(p, h, 18) ^ He.rotrBL(p, h, 41)
              , O = p & g ^ ~p & x
              , $ = h & S ^ ~h & v
              , D = He.add5L(M, L, $, xN[A], ki[A])
              , K = He.add5H(D, I, k, O, vN[A], Ci[A])
              , G = D | 0
              , F = He.rotrSH(n, i, 28) ^ He.rotrBH(n, i, 34) ^ He.rotrBH(n, i, 39)
              , q = He.rotrSL(n, i, 28) ^ He.rotrBL(n, i, 34) ^ He.rotrBL(n, i, 39)
              , B = n & s ^ n & a ^ s & a
              , y = i & o ^ i & u ^ o & u;
            I = x | 0,
            M = v | 0,
            x = g | 0,
            v = S | 0,
            g = p | 0,
            S = h | 0,
            {h: p, l: h} = He.add(c | 0, l | 0, K | 0, G | 0),
            c = a | 0,
            l = u | 0,
            a = s | 0,
            u = o | 0,
            s = n | 0,
            o = i | 0;
            const b = He.add3L(G, q, y);
            n = He.add3H(b, K, F, B),
            i = b | 0
        }
        ({h: n, l: i} = He.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)),
        {h: s, l: o} = He.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0),
        {h: a, l: u} = He.add(this.Ch | 0, this.Cl | 0, a | 0, u | 0),
        {h: c, l} = He.add(this.Dh | 0, this.Dl | 0, c | 0, l | 0),
        {h: p, l: h} = He.add(this.Eh | 0, this.El | 0, p | 0, h | 0),
        {h: g, l: S} = He.add(this.Fh | 0, this.Fl | 0, g | 0, S | 0),
        {h: x, l: v} = He.add(this.Gh | 0, this.Gl | 0, x | 0, v | 0),
        {h: I, l: M} = He.add(this.Hh | 0, this.Hl | 0, I | 0, M | 0),
        this.set(n, i, s, o, a, u, c, l, p, h, g, S, x, v, I, M)
    }
    roundClean() {
        Ci.fill(0),
        ki.fill(0)
    }
    destroy() {
        this.buffer.fill(0),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
const L3 = I3( () => new EN);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const O3 = BigInt(0)
  , ad = BigInt(1)
  , SN = BigInt(2);
function Vs(e) {
    return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array"
}
function lc(e) {
    if (!Vs(e))
        throw new Error("Uint8Array expected")
}
const _N = Array.from({
    length: 256
}, (e, t) => t.toString(16).padStart(2, "0"));
function Ks(e) {
    lc(e);
    let t = "";
    for (let r = 0; r < e.length; r++)
        t += _N[e[r]];
    return t
}
function N3(e) {
    const t = e.toString(16);
    return t.length & 1 ? `0${t}` : t
}
function em(e) {
    if (typeof e != "string")
        throw new Error("hex string expected, got " + typeof e);
    return BigInt(e === "" ? "0" : `0x${e}`)
}
const ri = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function ab(e) {
    if (e >= ri._0 && e <= ri._9)
        return e - ri._0;
    if (e >= ri._A && e <= ri._F)
        return e - (ri._A - 10);
    if (e >= ri._a && e <= ri._f)
        return e - (ri._a - 10)
}
function Yo(e) {
    if (typeof e != "string")
        throw new Error("hex string expected, got " + typeof e);
    const t = e.length
      , r = t / 2;
    if (t % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + t);
    const n = new Uint8Array(r);
    for (let i = 0, s = 0; i < r; i++,
    s += 2) {
        const o = ab(e.charCodeAt(s))
          , a = ab(e.charCodeAt(s + 1));
        if (o === void 0 || a === void 0) {
            const u = e[s] + e[s + 1];
            throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + s)
        }
        n[i] = o * 16 + a
    }
    return n
}
function Ds(e) {
    return em(Ks(e))
}
function Mo(e) {
    return lc(e),
    em(Ks(Uint8Array.from(e).reverse()))
}
function Zo(e, t) {
    return Yo(e.toString(16).padStart(t * 2, "0"))
}
function Su(e, t) {
    return Zo(e, t).reverse()
}
function AN(e) {
    return Yo(N3(e))
}
function Qt(e, t, r) {
    let n;
    if (typeof t == "string")
        try {
            n = Yo(t)
        } catch (s) {
            throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`)
        }
    else if (Vs(t))
        n = Uint8Array.from(t);
    else
        throw new Error(`${e} must be hex string or Uint8Array`);
    const i = n.length;
    if (typeof r == "number" && i !== r)
        throw new Error(`${e} expected ${r} bytes, got ${i}`);
    return n
}
function Gs(...e) {
    let t = 0;
    for (let n = 0; n < e.length; n++) {
        const i = e[n];
        lc(i),
        t += i.length
    }
    const r = new Uint8Array(t);
    for (let n = 0, i = 0; n < e.length; n++) {
        const s = e[n];
        r.set(s, i),
        i += s.length
    }
    return r
}
function MN(e, t) {
    if (e.length !== t.length)
        return !1;
    let r = 0;
    for (let n = 0; n < e.length; n++)
        r |= e[n] ^ t[n];
    return r === 0
}
function IN(e) {
    if (typeof e != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e))
}
function TN(e) {
    let t;
    for (t = 0; e > O3; e >>= ad,
    t += 1)
        ;
    return t
}
function CN(e, t) {
    return e >> BigInt(t) & ad
}
function kN(e, t, r) {
    return e | (r ? ad : O3) << BigInt(t)
}
const tm = e => (SN << BigInt(e - 1)) - ad
  , _0 = e => new Uint8Array(e)
  , ub = e => Uint8Array.from(e);
function R3(e, t, r) {
    if (typeof e != "number" || e < 2)
        throw new Error("hashLen must be a number");
    if (typeof t != "number" || t < 2)
        throw new Error("qByteLen must be a number");
    if (typeof r != "function")
        throw new Error("hmacFn must be a function");
    let n = _0(e)
      , i = _0(e)
      , s = 0;
    const o = () => {
        n.fill(1),
        i.fill(0),
        s = 0
    }
      , a = (...p) => r(i, n, ...p)
      , u = (p=_0()) => {
        i = a(ub([0]), p),
        n = a(),
        p.length !== 0 && (i = a(ub([1]), p),
        n = a())
    }
      , c = () => {
        if (s++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let p = 0;
        const h = [];
        for (; p < t; ) {
            n = a();
            const g = n.slice();
            h.push(g),
            p += n.length
        }
        return Gs(...h)
    }
    ;
    return (p, h) => {
        o(),
        u(p);
        let g;
        for (; !(g = h(c())); )
            u();
        return o(),
        g
    }
}
const LN = {
    bigint: e => typeof e == "bigint",
    function: e => typeof e == "function",
    boolean: e => typeof e == "boolean",
    string: e => typeof e == "string",
    stringOrUint8Array: e => typeof e == "string" || Vs(e),
    isSafeInteger: e => Number.isSafeInteger(e),
    array: e => Array.isArray(e),
    field: (e, t) => t.Fp.isValid(e),
    hash: e => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function ga(e, t, r={}) {
    const n = (i, s, o) => {
        const a = LN[s];
        if (typeof a != "function")
            throw new Error(`Invalid validator "${s}", expected function`);
        const u = e[i];
        if (!(o && u === void 0) && !a(u, e))
            throw new Error(`Invalid param ${String(i)}=${u} (${typeof u}), expected ${s}`)
    }
    ;
    for (const [i,s] of Object.entries(t))
        n(i, s, !1);
    for (const [i,s] of Object.entries(r))
        n(i, s, !0);
    return e
}
const ON = Object.freeze(Object.defineProperty({
    __proto__: null,
    abytes: lc,
    bitGet: CN,
    bitLen: TN,
    bitMask: tm,
    bitSet: kN,
    bytesToHex: Ks,
    bytesToNumberBE: Ds,
    bytesToNumberLE: Mo,
    concatBytes: Gs,
    createHmacDrbg: R3,
    ensureBytes: Qt,
    equalBytes: MN,
    hexToBytes: Yo,
    hexToNumber: em,
    isBytes: Vs,
    numberToBytesBE: Zo,
    numberToBytesLE: Su,
    numberToHexUnpadded: N3,
    numberToVarBytesBE: AN,
    utf8ToBytes: IN,
    validateObject: ga
}, Symbol.toStringTag, {
    value: "Module"
}));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const rr = BigInt(0)
  , St = BigInt(1)
  , ws = BigInt(2)
  , NN = BigInt(3)
  , ip = BigInt(4)
  , cb = BigInt(5)
  , lb = BigInt(8);
BigInt(9);
BigInt(16);
function wt(e, t) {
    const r = e % t;
    return r >= rr ? r : t + r
}
function RN(e, t, r) {
    if (r <= rr || t < rr)
        throw new Error("Expected power/modulo > 0");
    if (r === St)
        return rr;
    let n = St;
    for (; t > rr; )
        t & St && (n = n * e % r),
        e = e * e % r,
        t >>= St;
    return n
}
function Mt(e, t, r) {
    let n = e;
    for (; t-- > rr; )
        n *= n,
        n %= r;
    return n
}
function sp(e, t) {
    if (e === rr || t <= rr)
        throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
    let r = wt(e, t)
      , n = t
      , i = rr
      , s = St;
    for (; r !== rr; ) {
        const a = n / r
          , u = n % r
          , c = i - s * a;
        n = r,
        r = u,
        i = s,
        s = c
    }
    if (n !== St)
        throw new Error("invert: does not exist");
    return wt(i, t)
}
function BN(e) {
    const t = (e - St) / ws;
    let r, n, i;
    for (r = e - St,
    n = 0; r % ws === rr; r /= ws,
    n++)
        ;
    for (i = ws; i < e && RN(i, t, e) !== e - St; i++)
        ;
    if (n === 1) {
        const o = (e + St) / ip;
        return function(u, c) {
            const l = u.pow(c, o);
            if (!u.eql(u.sqr(l), c))
                throw new Error("Cannot find square root");
            return l
        }
    }
    const s = (r + St) / ws;
    return function(a, u) {
        if (a.pow(u, t) === a.neg(a.ONE))
            throw new Error("Cannot find square root");
        let c = n
          , l = a.pow(a.mul(a.ONE, i), r)
          , p = a.pow(u, s)
          , h = a.pow(u, r);
        for (; !a.eql(h, a.ONE); ) {
            if (a.eql(h, a.ZERO))
                return a.ZERO;
            let g = 1;
            for (let x = a.sqr(h); g < c && !a.eql(x, a.ONE); g++)
                x = a.sqr(x);
            const S = a.pow(l, St << BigInt(c - g - 1));
            l = a.sqr(S),
            p = a.mul(p, S),
            h = a.mul(h, l),
            c = g
        }
        return p
    }
}
function PN(e) {
    if (e % ip === NN) {
        const t = (e + St) / ip;
        return function(n, i) {
            const s = n.pow(i, t);
            if (!n.eql(n.sqr(s), i))
                throw new Error("Cannot find square root");
            return s
        }
    }
    if (e % lb === cb) {
        const t = (e - cb) / lb;
        return function(n, i) {
            const s = n.mul(i, ws)
              , o = n.pow(s, t)
              , a = n.mul(i, o)
              , u = n.mul(n.mul(a, ws), o)
              , c = n.mul(a, n.sub(u, n.ONE));
            if (!n.eql(n.sqr(c), i))
                throw new Error("Cannot find square root");
            return c
        }
    }
    return BN(e)
}
const jN = (e, t) => (wt(e, t) & St) === St
  , DN = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function UN(e) {
    const t = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }
      , r = DN.reduce( (n, i) => (n[i] = "function",
    n), t);
    return ga(e, r)
}
function zN(e, t, r) {
    if (r < rr)
        throw new Error("Expected power > 0");
    if (r === rr)
        return e.ONE;
    if (r === St)
        return t;
    let n = e.ONE
      , i = t;
    for (; r > rr; )
        r & St && (n = e.mul(n, i)),
        i = e.sqr(i),
        r >>= St;
    return n
}
function $N(e, t) {
    const r = new Array(t.length)
      , n = t.reduce( (s, o, a) => e.is0(o) ? s : (r[a] = s,
    e.mul(s, o)), e.ONE)
      , i = e.inv(n);
    return t.reduceRight( (s, o, a) => e.is0(o) ? s : (r[a] = e.mul(s, r[a]),
    e.mul(s, o)), i),
    r
}
function B3(e, t) {
    const r = t !== void 0 ? t : e.toString(2).length
      , n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    }
}
function P3(e, t, r=!1, n={}) {
    if (e <= rr)
        throw new Error(`Expected Field ORDER > 0, got ${e}`);
    const {nBitLength: i, nByteLength: s} = B3(e, t);
    if (s > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
    const o = PN(e)
      , a = Object.freeze({
        ORDER: e,
        BITS: i,
        BYTES: s,
        MASK: tm(i),
        ZERO: rr,
        ONE: St,
        create: u => wt(u, e),
        isValid: u => {
            if (typeof u != "bigint")
                throw new Error(`Invalid field element: expected bigint, got ${typeof u}`);
            return rr <= u && u < e
        }
        ,
        is0: u => u === rr,
        isOdd: u => (u & St) === St,
        neg: u => wt(-u, e),
        eql: (u, c) => u === c,
        sqr: u => wt(u * u, e),
        add: (u, c) => wt(u + c, e),
        sub: (u, c) => wt(u - c, e),
        mul: (u, c) => wt(u * c, e),
        pow: (u, c) => zN(a, u, c),
        div: (u, c) => wt(u * sp(c, e), e),
        sqrN: u => u * u,
        addN: (u, c) => u + c,
        subN: (u, c) => u - c,
        mulN: (u, c) => u * c,
        inv: u => sp(u, e),
        sqrt: n.sqrt || (u => o(a, u)),
        invertBatch: u => $N(a, u),
        cmov: (u, c, l) => l ? c : u,
        toBytes: u => r ? Su(u, s) : Zo(u, s),
        fromBytes: u => {
            if (u.length !== s)
                throw new Error(`Fp.fromBytes: expected ${s}, got ${u.length}`);
            return r ? Mo(u) : Ds(u)
        }
    });
    return Object.freeze(a)
}
function FN(e, t) {
    if (!e.isOdd)
        throw new Error("Field doesn't have isOdd");
    const r = e.sqrt(t);
    return e.isOdd(r) ? e.neg(r) : r
}
function j3(e) {
    if (typeof e != "bigint")
        throw new Error("field order must be bigint");
    const t = e.toString(2).length;
    return Math.ceil(t / 8)
}
function D3(e) {
    const t = j3(e);
    return t + Math.ceil(t / 2)
}
function HN(e, t, r=!1) {
    const n = e.length
      , i = j3(t)
      , s = D3(t);
    if (n < 16 || n < s || n > 1024)
        throw new Error(`expected ${s}-1024 bytes of input, got ${n}`);
    const o = r ? Ds(e) : Mo(e)
      , a = wt(o, t - St) + St;
    return r ? Su(a, i) : Zo(a, i)
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const qN = BigInt(0)
  , A0 = BigInt(1);
function U3(e, t) {
    const r = (i, s) => {
        const o = s.negate();
        return i ? o : s
    }
      , n = i => {
        const s = Math.ceil(t / i) + 1
          , o = 2 ** (i - 1);
        return {
            windows: s,
            windowSize: o
        }
    }
    ;
    return {
        constTimeNegate: r,
        unsafeLadder(i, s) {
            let o = e.ZERO
              , a = i;
            for (; s > qN; )
                s & A0 && (o = o.add(a)),
                a = a.double(),
                s >>= A0;
            return o
        },
        precomputeWindow(i, s) {
            const {windows: o, windowSize: a} = n(s)
              , u = [];
            let c = i
              , l = c;
            for (let p = 0; p < o; p++) {
                l = c,
                u.push(l);
                for (let h = 1; h < a; h++)
                    l = l.add(c),
                    u.push(l);
                c = l.double()
            }
            return u
        },
        wNAF(i, s, o) {
            const {windows: a, windowSize: u} = n(i);
            let c = e.ZERO
              , l = e.BASE;
            const p = BigInt(2 ** i - 1)
              , h = 2 ** i
              , g = BigInt(i);
            for (let S = 0; S < a; S++) {
                const x = S * u;
                let v = Number(o & p);
                o >>= g,
                v > u && (v -= h,
                o += A0);
                const I = x
                  , M = x + Math.abs(v) - 1
                  , A = S % 2 !== 0
                  , k = v < 0;
                v === 0 ? l = l.add(r(A, s[I])) : c = c.add(r(k, s[M]))
            }
            return {
                p: c,
                f: l
            }
        },
        wNAFCached(i, s, o, a) {
            const u = i._WINDOW_SIZE || 1;
            let c = s.get(i);
            return c || (c = this.precomputeWindow(i, u),
            u !== 1 && s.set(i, a(c))),
            this.wNAF(u, c, o)
        }
    }
}
function rm(e) {
    return UN(e.Fp),
    ga(e, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }),
    Object.freeze({
        ...B3(e.n, e.nBitLength),
        ...e,
        p: e.Fp.ORDER
    })
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const bn = BigInt(0)
  , Fr = BigInt(1)
  , Gc = BigInt(2)
  , WN = BigInt(8)
  , VN = {
    zip215: !0
};
function KN(e) {
    const t = rm(e);
    return ga(e, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }),
    Object.freeze({
        ...t
    })
}
function nm(e) {
    const t = KN(e)
      , {Fp: r, n, prehash: i, hash: s, randomBytes: o, nByteLength: a, h: u} = t
      , c = Gc << BigInt(a * 8) - Fr
      , l = r.create
      , p = t.uvRatio || ( (C, P) => {
        try {
            return {
                isValid: !0,
                value: r.sqrt(C * r.inv(P))
            }
        } catch {
            return {
                isValid: !1,
                value: bn
            }
        }
    }
    )
      , h = t.adjustScalarBytes || (C => C)
      , g = t.domain || ( (C, P, W) => {
        if (P.length || W)
            throw new Error("Contexts/pre-hash are not supported");
        return C
    }
    )
      , S = C => typeof C == "bigint" && bn < C
      , x = (C, P) => S(C) && S(P) && C < P
      , v = C => C === bn || x(C, c);
    function I(C, P) {
        if (x(C, P))
            return C;
        throw new Error(`Expected valid scalar < ${P}, got ${typeof C} ${C}`)
    }
    function M(C) {
        return C === bn ? C : I(C, n)
    }
    const A = new Map;
    function k(C) {
        if (!(C instanceof L))
            throw new Error("ExtendedPoint expected")
    }
    class L {
        constructor(P, W, N, w) {
            if (this.ex = P,
            this.ey = W,
            this.ez = N,
            this.et = w,
            !v(P))
                throw new Error("x required");
            if (!v(W))
                throw new Error("y required");
            if (!v(N))
                throw new Error("z required");
            if (!v(w))
                throw new Error("t required")
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static fromAffine(P) {
            if (P instanceof L)
                throw new Error("extended point not allowed");
            const {x: W, y: N} = P || {};
            if (!v(W) || !v(N))
                throw new Error("invalid affine point");
            return new L(W,N,Fr,l(W * N))
        }
        static normalizeZ(P) {
            const W = r.invertBatch(P.map(N => N.ez));
            return P.map( (N, w) => N.toAffine(W[w])).map(L.fromAffine)
        }
        _setWindowSize(P) {
            this._WINDOW_SIZE = P,
            A.delete(this)
        }
        assertValidity() {
            const {a: P, d: W} = t;
            if (this.is0())
                throw new Error("bad point: ZERO");
            const {ex: N, ey: w, ez: U, et: re} = this
              , ie = l(N * N)
              , ue = l(w * w)
              , Q = l(U * U)
              , ee = l(Q * Q)
              , te = l(ie * P)
              , he = l(Q * l(te + ue))
              , xe = l(ee + l(W * l(ie * ue)));
            if (he !== xe)
                throw new Error("bad point: equation left != right (1)");
            const Ae = l(N * w)
              , z = l(U * re);
            if (Ae !== z)
                throw new Error("bad point: equation left != right (2)")
        }
        equals(P) {
            k(P);
            const {ex: W, ey: N, ez: w} = this
              , {ex: U, ey: re, ez: ie} = P
              , ue = l(W * ie)
              , Q = l(U * w)
              , ee = l(N * ie)
              , te = l(re * w);
            return ue === Q && ee === te
        }
        is0() {
            return this.equals(L.ZERO)
        }
        negate() {
            return new L(l(-this.ex),this.ey,this.ez,l(-this.et))
        }
        double() {
            const {a: P} = t
              , {ex: W, ey: N, ez: w} = this
              , U = l(W * W)
              , re = l(N * N)
              , ie = l(Gc * l(w * w))
              , ue = l(P * U)
              , Q = W + N
              , ee = l(l(Q * Q) - U - re)
              , te = ue + re
              , he = te - ie
              , xe = ue - re
              , Ae = l(ee * he)
              , z = l(te * xe)
              , H = l(ee * xe)
              , Y = l(he * te);
            return new L(Ae,z,Y,H)
        }
        add(P) {
            k(P);
            const {a: W, d: N} = t
              , {ex: w, ey: U, ez: re, et: ie} = this
              , {ex: ue, ey: Q, ez: ee, et: te} = P;
            if (W === BigInt(-1)) {
                const ne = l((U - w) * (Q + ue))
                  , de = l((U + w) * (Q - ue))
                  , ye = l(de - ne);
                if (ye === bn)
                    return this.double();
                const ve = l(re * Gc * te)
                  , Ee = l(ie * Gc * ee)
                  , m = Ee + ve
                  , f = de + ne
                  , d = Ee - ve
                  , E = l(m * ye)
                  , R = l(f * d)
                  , j = l(m * d)
                  , V = l(ye * f);
                return new L(E,R,V,j)
            }
            const he = l(w * ue)
              , xe = l(U * Q)
              , Ae = l(ie * N * te)
              , z = l(re * ee)
              , H = l((w + U) * (ue + Q) - he - xe)
              , Y = z - Ae
              , se = z + Ae
              , X = l(xe - W * he)
              , ce = l(H * Y)
              , me = l(se * X)
              , oe = l(H * X)
              , ae = l(Y * se);
            return new L(ce,me,ae,oe)
        }
        subtract(P) {
            return this.add(P.negate())
        }
        wNAF(P) {
            return D.wNAFCached(this, A, P, L.normalizeZ)
        }
        multiply(P) {
            const {p: W, f: N} = this.wNAF(I(P, n));
            return L.normalizeZ([W, N])[0]
        }
        multiplyUnsafe(P) {
            let W = M(P);
            return W === bn ? $ : this.equals($) || W === Fr ? this : this.equals(O) ? this.wNAF(W).p : D.unsafeLadder(this, W)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(u).is0()
        }
        isTorsionFree() {
            return D.unsafeLadder(this, n).is0()
        }
        toAffine(P) {
            const {ex: W, ey: N, ez: w} = this
              , U = this.is0();
            P == null && (P = U ? WN : r.inv(w));
            const re = l(W * P)
              , ie = l(N * P)
              , ue = l(w * P);
            if (U)
                return {
                    x: bn,
                    y: Fr
                };
            if (ue !== Fr)
                throw new Error("invZ was invalid");
            return {
                x: re,
                y: ie
            }
        }
        clearCofactor() {
            const {h: P} = t;
            return P === Fr ? this : this.multiplyUnsafe(P)
        }
        static fromHex(P, W=!1) {
            const {d: N, a: w} = t
              , U = r.BYTES;
            P = Qt("pointHex", P, U);
            const re = P.slice()
              , ie = P[U - 1];
            re[U - 1] = ie & -129;
            const ue = Mo(re);
            ue === bn || (W ? I(ue, c) : I(ue, r.ORDER));
            const Q = l(ue * ue)
              , ee = l(Q - Fr)
              , te = l(N * Q - w);
            let {isValid: he, value: xe} = p(ee, te);
            if (!he)
                throw new Error("Point.fromHex: invalid y coordinate");
            const Ae = (xe & Fr) === Fr
              , z = (ie & 128) !== 0;
            if (!W && xe === bn && z)
                throw new Error("Point.fromHex: x=0 and x_0=1");
            return z !== Ae && (xe = l(-xe)),
            L.fromAffine({
                x: xe,
                y: ue
            })
        }
        static fromPrivateKey(P) {
            return F(P).point
        }
        toRawBytes() {
            const {x: P, y: W} = this.toAffine()
              , N = Su(W, r.BYTES);
            return N[N.length - 1] |= P & Fr ? 128 : 0,
            N
        }
        toHex() {
            return Ks(this.toRawBytes())
        }
    }
    L.BASE = new L(t.Gx,t.Gy,Fr,l(t.Gx * t.Gy)),
    L.ZERO = new L(bn,Fr,Fr,bn);
    const {BASE: O, ZERO: $} = L
      , D = U3(L, a * 8);
    function K(C) {
        return wt(C, n)
    }
    function G(C) {
        return K(Mo(C))
    }
    function F(C) {
        const P = a;
        C = Qt("private key", C, P);
        const W = Qt("hashed private key", s(C), 2 * P)
          , N = h(W.slice(0, P))
          , w = W.slice(P, 2 * P)
          , U = G(N)
          , re = O.multiply(U)
          , ie = re.toRawBytes();
        return {
            head: N,
            prefix: w,
            scalar: U,
            point: re,
            pointBytes: ie
        }
    }
    function q(C) {
        return F(C).pointBytes
    }
    function B(C=new Uint8Array, ...P) {
        const W = Gs(...P);
        return G(s(g(W, Qt("context", C), !!i)))
    }
    function y(C, P, W={}) {
        C = Qt("message", C),
        i && (C = i(C));
        const {prefix: N, scalar: w, pointBytes: U} = F(P)
          , re = B(W.context, N, C)
          , ie = O.multiply(re).toRawBytes()
          , ue = B(W.context, ie, U, C)
          , Q = K(re + ue * w);
        M(Q);
        const ee = Gs(ie, Su(Q, r.BYTES));
        return Qt("result", ee, a * 2)
    }
    const b = VN;
    function _(C, P, W, N=b) {
        const {context: w, zip215: U} = N
          , re = r.BYTES;
        C = Qt("signature", C, 2 * re),
        P = Qt("message", P),
        i && (P = i(P));
        const ie = Mo(C.slice(re, 2 * re));
        let ue, Q, ee;
        try {
            ue = L.fromHex(W, U),
            Q = L.fromHex(C.slice(0, re), U),
            ee = O.multiplyUnsafe(ie)
        } catch {
            return !1
        }
        if (!U && ue.isSmallOrder())
            return !1;
        const te = B(w, Q.toRawBytes(), ue.toRawBytes(), P);
        return Q.add(ue.multiplyUnsafe(te)).subtract(ee).clearCofactor().equals(L.ZERO)
    }
    return O._setWindowSize(8),
    {
        CURVE: t,
        getPublicKey: q,
        sign: y,
        verify: _,
        ExtendedPoint: L,
        utils: {
            getExtendedPublicKey: F,
            randomPrivateKey: () => o(r.BYTES),
            precompute(C=8, P=L.BASE) {
                return P._setWindowSize(C),
                P.multiply(BigInt(3)),
                P
            }
        }
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const im = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949")
  , fb = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const GN = BigInt(1)
  , op = BigInt(2)
  , QN = BigInt(5)
  , db = BigInt(10)
  , YN = BigInt(20)
  , ZN = BigInt(40)
  , hb = BigInt(80);
function JN(e) {
    const t = im
      , n = e * e % t * e % t
      , i = Mt(n, op, t) * n % t
      , s = Mt(i, GN, t) * e % t
      , o = Mt(s, QN, t) * s % t
      , a = Mt(o, db, t) * o % t
      , u = Mt(a, YN, t) * a % t
      , c = Mt(u, ZN, t) * u % t
      , l = Mt(c, hb, t) * c % t
      , p = Mt(l, hb, t) * c % t
      , h = Mt(p, db, t) * o % t;
    return {
        pow_p_5_8: Mt(h, op, t) * e % t,
        b2: n
    }
}
function XN(e) {
    return e[0] &= 248,
    e[31] &= 127,
    e[31] |= 64,
    e
}
function eR(e, t) {
    const r = im
      , n = wt(t * t * t, r)
      , i = wt(n * n * t, r)
      , s = JN(e * i).pow_p_5_8;
    let o = wt(e * n * s, r);
    const a = wt(t * o * o, r)
      , u = o
      , c = wt(o * fb, r)
      , l = a === e
      , p = a === wt(-e, r)
      , h = a === wt(-e * fb, r);
    return l && (o = u),
    (p || h) && (o = c),
    jN(o, r) && (o = wt(-o, r)),
    {
        isValid: l || p,
        value: o
    }
}
const pi = P3(im, void 0, !0)
  , sm = {
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp: pi,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: BigInt(8),
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: L3,
    randomBytes: T3,
    adjustScalarBytes: XN,
    uvRatio: eR
}
  , om = nm(sm);
function z3(e, t, r) {
    if (t.length > 255)
        throw new Error("Context is too big");
    return A3(_3("SigEd25519 no Ed25519 collisions"), new Uint8Array([r ? 1 : 0, t.length]), t, e)
}
({
    ...sm
});
({
    ...sm
});
const tR = (pi.ORDER + BigInt(3)) / BigInt(8);
pi.pow(op, tR);
pi.sqrt(pi.neg(pi.ONE));
(pi.ORDER - BigInt(5)) / BigInt(8);
BigInt(486662);
FN(pi, pi.neg(BigInt(486664)));
BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var am = {
    exports: {}
};
am.exports;
(function(e) {
    (function(t, r) {
        function n(B, y) {
            if (!B)
                throw new Error(y || "Assertion failed")
        }
        function i(B, y) {
            B.super_ = y;
            var b = function() {};
            b.prototype = y.prototype,
            B.prototype = new b,
            B.prototype.constructor = B
        }
        function s(B, y, b) {
            if (s.isBN(B))
                return B;
            this.negative = 0,
            this.words = null,
            this.length = 0,
            this.red = null,
            B !== null && ((y === "le" || y === "be") && (b = y,
            y = 10),
            this._init(B || 0, y || 10, b || "be"))
        }
        typeof t == "object" ? t.exports = s : r.BN = s,
        s.BN = s,
        s.wordSize = 26;
        var o;
        try {
            typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = mn.Buffer
        } catch {}
        s.isBN = function(y) {
            return y instanceof s ? !0 : y !== null && typeof y == "object" && y.constructor.wordSize === s.wordSize && Array.isArray(y.words)
        }
        ,
        s.max = function(y, b) {
            return y.cmp(b) > 0 ? y : b
        }
        ,
        s.min = function(y, b) {
            return y.cmp(b) < 0 ? y : b
        }
        ,
        s.prototype._init = function(y, b, _) {
            if (typeof y == "number")
                return this._initNumber(y, b, _);
            if (typeof y == "object")
                return this._initArray(y, b, _);
            b === "hex" && (b = 16),
            n(b === (b | 0) && b >= 2 && b <= 36),
            y = y.toString().replace(/\s+/g, "");
            var T = 0;
            y[0] === "-" && (T++,
            this.negative = 1),
            T < y.length && (b === 16 ? this._parseHex(y, T, _) : (this._parseBase(y, b, T),
            _ === "le" && this._initArray(this.toArray(), b, _)))
        }
        ,
        s.prototype._initNumber = function(y, b, _) {
            y < 0 && (this.negative = 1,
            y = -y),
            y < 67108864 ? (this.words = [y & 67108863],
            this.length = 1) : y < 4503599627370496 ? (this.words = [y & 67108863, y / 67108864 & 67108863],
            this.length = 2) : (n(y < 9007199254740992),
            this.words = [y & 67108863, y / 67108864 & 67108863, 1],
            this.length = 3),
            _ === "le" && this._initArray(this.toArray(), b, _)
        }
        ,
        s.prototype._initArray = function(y, b, _) {
            if (n(typeof y.length == "number"),
            y.length <= 0)
                return this.words = [0],
                this.length = 1,
                this;
            this.length = Math.ceil(y.length / 3),
            this.words = new Array(this.length);
            for (var T = 0; T < this.length; T++)
                this.words[T] = 0;
            var C, P, W = 0;
            if (_ === "be")
                for (T = y.length - 1,
                C = 0; T >= 0; T -= 3)
                    P = y[T] | y[T - 1] << 8 | y[T - 2] << 16,
                    this.words[C] |= P << W & 67108863,
                    this.words[C + 1] = P >>> 26 - W & 67108863,
                    W += 24,
                    W >= 26 && (W -= 26,
                    C++);
            else if (_ === "le")
                for (T = 0,
                C = 0; T < y.length; T += 3)
                    P = y[T] | y[T + 1] << 8 | y[T + 2] << 16,
                    this.words[C] |= P << W & 67108863,
                    this.words[C + 1] = P >>> 26 - W & 67108863,
                    W += 24,
                    W >= 26 && (W -= 26,
                    C++);
            return this._strip()
        }
        ;
        function a(B, y) {
            var b = B.charCodeAt(y);
            if (b >= 48 && b <= 57)
                return b - 48;
            if (b >= 65 && b <= 70)
                return b - 55;
            if (b >= 97 && b <= 102)
                return b - 87;
            n(!1, "Invalid character in " + B)
        }
        function u(B, y, b) {
            var _ = a(B, b);
            return b - 1 >= y && (_ |= a(B, b - 1) << 4),
            _
        }
        s.prototype._parseHex = function(y, b, _) {
            this.length = Math.ceil((y.length - b) / 6),
            this.words = new Array(this.length);
            for (var T = 0; T < this.length; T++)
                this.words[T] = 0;
            var C = 0, P = 0, W;
            if (_ === "be")
                for (T = y.length - 1; T >= b; T -= 2)
                    W = u(y, b, T) << C,
                    this.words[P] |= W & 67108863,
                    C >= 18 ? (C -= 18,
                    P += 1,
                    this.words[P] |= W >>> 26) : C += 8;
            else {
                var N = y.length - b;
                for (T = N % 2 === 0 ? b + 1 : b; T < y.length; T += 2)
                    W = u(y, b, T) << C,
                    this.words[P] |= W & 67108863,
                    C >= 18 ? (C -= 18,
                    P += 1,
                    this.words[P] |= W >>> 26) : C += 8
            }
            this._strip()
        }
        ;
        function c(B, y, b, _) {
            for (var T = 0, C = 0, P = Math.min(B.length, b), W = y; W < P; W++) {
                var N = B.charCodeAt(W) - 48;
                T *= _,
                N >= 49 ? C = N - 49 + 10 : N >= 17 ? C = N - 17 + 10 : C = N,
                n(N >= 0 && C < _, "Invalid character"),
                T += C
            }
            return T
        }
        s.prototype._parseBase = function(y, b, _) {
            this.words = [0],
            this.length = 1;
            for (var T = 0, C = 1; C <= 67108863; C *= b)
                T++;
            T--,
            C = C / b | 0;
            for (var P = y.length - _, W = P % T, N = Math.min(P, P - W) + _, w = 0, U = _; U < N; U += T)
                w = c(y, U, U + T, b),
                this.imuln(C),
                this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
            if (W !== 0) {
                var re = 1;
                for (w = c(y, U, y.length, b),
                U = 0; U < W; U++)
                    re *= b;
                this.imuln(re),
                this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w)
            }
            this._strip()
        }
        ,
        s.prototype.copy = function(y) {
            y.words = new Array(this.length);
            for (var b = 0; b < this.length; b++)
                y.words[b] = this.words[b];
            y.length = this.length,
            y.negative = this.negative,
            y.red = this.red
        }
        ;
        function l(B, y) {
            B.words = y.words,
            B.length = y.length,
            B.negative = y.negative,
            B.red = y.red
        }
        if (s.prototype._move = function(y) {
            l(y, this)
        }
        ,
        s.prototype.clone = function() {
            var y = new s(null);
            return this.copy(y),
            y
        }
        ,
        s.prototype._expand = function(y) {
            for (; this.length < y; )
                this.words[this.length++] = 0;
            return this
        }
        ,
        s.prototype._strip = function() {
            for (; this.length > 1 && this.words[this.length - 1] === 0; )
                this.length--;
            return this._normSign()
        }
        ,
        s.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
            this
        }
        ,
        typeof Symbol < "u" && typeof Symbol.for == "function")
            try {
                s.prototype[Symbol.for("nodejs.util.inspect.custom")] = p
            } catch {
                s.prototype.inspect = p
            }
        else
            s.prototype.inspect = p;
        function p() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
          , g = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
          , S = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        s.prototype.toString = function(y, b) {
            y = y || 10,
            b = b | 0 || 1;
            var _;
            if (y === 16 || y === "hex") {
                _ = "";
                for (var T = 0, C = 0, P = 0; P < this.length; P++) {
                    var W = this.words[P]
                      , N = ((W << T | C) & 16777215).toString(16);
                    C = W >>> 24 - T & 16777215,
                    T += 2,
                    T >= 26 && (T -= 26,
                    P--),
                    C !== 0 || P !== this.length - 1 ? _ = h[6 - N.length] + N + _ : _ = N + _
                }
                for (C !== 0 && (_ = C.toString(16) + _); _.length % b !== 0; )
                    _ = "0" + _;
                return this.negative !== 0 && (_ = "-" + _),
                _
            }
            if (y === (y | 0) && y >= 2 && y <= 36) {
                var w = g[y]
                  , U = S[y];
                _ = "";
                var re = this.clone();
                for (re.negative = 0; !re.isZero(); ) {
                    var ie = re.modrn(U).toString(y);
                    re = re.idivn(U),
                    re.isZero() ? _ = ie + _ : _ = h[w - ie.length] + ie + _
                }
                for (this.isZero() && (_ = "0" + _); _.length % b !== 0; )
                    _ = "0" + _;
                return this.negative !== 0 && (_ = "-" + _),
                _
            }
            n(!1, "Base should be between 2 and 36")
        }
        ,
        s.prototype.toNumber = function() {
            var y = this.words[0];
            return this.length === 2 ? y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"),
            this.negative !== 0 ? -y : y
        }
        ,
        s.prototype.toJSON = function() {
            return this.toString(16, 2)
        }
        ,
        o && (s.prototype.toBuffer = function(y, b) {
            return this.toArrayLike(o, y, b)
        }
        ),
        s.prototype.toArray = function(y, b) {
            return this.toArrayLike(Array, y, b)
        }
        ;
        var x = function(y, b) {
            return y.allocUnsafe ? y.allocUnsafe(b) : new y(b)
        };
        s.prototype.toArrayLike = function(y, b, _) {
            this._strip();
            var T = this.byteLength()
              , C = _ || Math.max(1, T);
            n(T <= C, "byte array longer than desired length"),
            n(C > 0, "Requested array length <= 0");
            var P = x(y, C)
              , W = b === "le" ? "LE" : "BE";
            return this["_toArrayLike" + W](P, T),
            P
        }
        ,
        s.prototype._toArrayLikeLE = function(y, b) {
            for (var _ = 0, T = 0, C = 0, P = 0; C < this.length; C++) {
                var W = this.words[C] << P | T;
                y[_++] = W & 255,
                _ < y.length && (y[_++] = W >> 8 & 255),
                _ < y.length && (y[_++] = W >> 16 & 255),
                P === 6 ? (_ < y.length && (y[_++] = W >> 24 & 255),
                T = 0,
                P = 0) : (T = W >>> 24,
                P += 2)
            }
            if (_ < y.length)
                for (y[_++] = T; _ < y.length; )
                    y[_++] = 0
        }
        ,
        s.prototype._toArrayLikeBE = function(y, b) {
            for (var _ = y.length - 1, T = 0, C = 0, P = 0; C < this.length; C++) {
                var W = this.words[C] << P | T;
                y[_--] = W & 255,
                _ >= 0 && (y[_--] = W >> 8 & 255),
                _ >= 0 && (y[_--] = W >> 16 & 255),
                P === 6 ? (_ >= 0 && (y[_--] = W >> 24 & 255),
                T = 0,
                P = 0) : (T = W >>> 24,
                P += 2)
            }
            if (_ >= 0)
                for (y[_--] = T; _ >= 0; )
                    y[_--] = 0
        }
        ,
        Math.clz32 ? s.prototype._countBits = function(y) {
            return 32 - Math.clz32(y)
        }
        : s.prototype._countBits = function(y) {
            var b = y
              , _ = 0;
            return b >= 4096 && (_ += 13,
            b >>>= 13),
            b >= 64 && (_ += 7,
            b >>>= 7),
            b >= 8 && (_ += 4,
            b >>>= 4),
            b >= 2 && (_ += 2,
            b >>>= 2),
            _ + b
        }
        ,
        s.prototype._zeroBits = function(y) {
            if (y === 0)
                return 26;
            var b = y
              , _ = 0;
            return b & 8191 || (_ += 13,
            b >>>= 13),
            b & 127 || (_ += 7,
            b >>>= 7),
            b & 15 || (_ += 4,
            b >>>= 4),
            b & 3 || (_ += 2,
            b >>>= 2),
            b & 1 || _++,
            _
        }
        ,
        s.prototype.bitLength = function() {
            var y = this.words[this.length - 1]
              , b = this._countBits(y);
            return (this.length - 1) * 26 + b
        }
        ;
        function v(B) {
            for (var y = new Array(B.bitLength()), b = 0; b < y.length; b++) {
                var _ = b / 26 | 0
                  , T = b % 26;
                y[b] = B.words[_] >>> T & 1
            }
            return y
        }
        s.prototype.zeroBits = function() {
            if (this.isZero())
                return 0;
            for (var y = 0, b = 0; b < this.length; b++) {
                var _ = this._zeroBits(this.words[b]);
                if (y += _,
                _ !== 26)
                    break
            }
            return y
        }
        ,
        s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }
        ,
        s.prototype.toTwos = function(y) {
            return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone()
        }
        ,
        s.prototype.fromTwos = function(y) {
            return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone()
        }
        ,
        s.prototype.isNeg = function() {
            return this.negative !== 0
        }
        ,
        s.prototype.neg = function() {
            return this.clone().ineg()
        }
        ,
        s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1),
            this
        }
        ,
        s.prototype.iuor = function(y) {
            for (; this.length < y.length; )
                this.words[this.length++] = 0;
            for (var b = 0; b < y.length; b++)
                this.words[b] = this.words[b] | y.words[b];
            return this._strip()
        }
        ,
        s.prototype.ior = function(y) {
            return n((this.negative | y.negative) === 0),
            this.iuor(y)
        }
        ,
        s.prototype.or = function(y) {
            return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this)
        }
        ,
        s.prototype.uor = function(y) {
            return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this)
        }
        ,
        s.prototype.iuand = function(y) {
            var b;
            this.length > y.length ? b = y : b = this;
            for (var _ = 0; _ < b.length; _++)
                this.words[_] = this.words[_] & y.words[_];
            return this.length = b.length,
            this._strip()
        }
        ,
        s.prototype.iand = function(y) {
            return n((this.negative | y.negative) === 0),
            this.iuand(y)
        }
        ,
        s.prototype.and = function(y) {
            return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this)
        }
        ,
        s.prototype.uand = function(y) {
            return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this)
        }
        ,
        s.prototype.iuxor = function(y) {
            var b, _;
            this.length > y.length ? (b = this,
            _ = y) : (b = y,
            _ = this);
            for (var T = 0; T < _.length; T++)
                this.words[T] = b.words[T] ^ _.words[T];
            if (this !== b)
                for (; T < b.length; T++)
                    this.words[T] = b.words[T];
            return this.length = b.length,
            this._strip()
        }
        ,
        s.prototype.ixor = function(y) {
            return n((this.negative | y.negative) === 0),
            this.iuxor(y)
        }
        ,
        s.prototype.xor = function(y) {
            return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this)
        }
        ,
        s.prototype.uxor = function(y) {
            return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this)
        }
        ,
        s.prototype.inotn = function(y) {
            n(typeof y == "number" && y >= 0);
            var b = Math.ceil(y / 26) | 0
              , _ = y % 26;
            this._expand(b),
            _ > 0 && b--;
            for (var T = 0; T < b; T++)
                this.words[T] = ~this.words[T] & 67108863;
            return _ > 0 && (this.words[T] = ~this.words[T] & 67108863 >> 26 - _),
            this._strip()
        }
        ,
        s.prototype.notn = function(y) {
            return this.clone().inotn(y)
        }
        ,
        s.prototype.setn = function(y, b) {
            n(typeof y == "number" && y >= 0);
            var _ = y / 26 | 0
              , T = y % 26;
            return this._expand(_ + 1),
            b ? this.words[_] = this.words[_] | 1 << T : this.words[_] = this.words[_] & ~(1 << T),
            this._strip()
        }
        ,
        s.prototype.iadd = function(y) {
            var b;
            if (this.negative !== 0 && y.negative === 0)
                return this.negative = 0,
                b = this.isub(y),
                this.negative ^= 1,
                this._normSign();
            if (this.negative === 0 && y.negative !== 0)
                return y.negative = 0,
                b = this.isub(y),
                y.negative = 1,
                b._normSign();
            var _, T;
            this.length > y.length ? (_ = this,
            T = y) : (_ = y,
            T = this);
            for (var C = 0, P = 0; P < T.length; P++)
                b = (_.words[P] | 0) + (T.words[P] | 0) + C,
                this.words[P] = b & 67108863,
                C = b >>> 26;
            for (; C !== 0 && P < _.length; P++)
                b = (_.words[P] | 0) + C,
                this.words[P] = b & 67108863,
                C = b >>> 26;
            if (this.length = _.length,
            C !== 0)
                this.words[this.length] = C,
                this.length++;
            else if (_ !== this)
                for (; P < _.length; P++)
                    this.words[P] = _.words[P];
            return this
        }
        ,
        s.prototype.add = function(y) {
            var b;
            return y.negative !== 0 && this.negative === 0 ? (y.negative = 0,
            b = this.sub(y),
            y.negative ^= 1,
            b) : y.negative === 0 && this.negative !== 0 ? (this.negative = 0,
            b = y.sub(this),
            this.negative = 1,
            b) : this.length > y.length ? this.clone().iadd(y) : y.clone().iadd(this)
        }
        ,
        s.prototype.isub = function(y) {
            if (y.negative !== 0) {
                y.negative = 0;
                var b = this.iadd(y);
                return y.negative = 1,
                b._normSign()
            } else if (this.negative !== 0)
                return this.negative = 0,
                this.iadd(y),
                this.negative = 1,
                this._normSign();
            var _ = this.cmp(y);
            if (_ === 0)
                return this.negative = 0,
                this.length = 1,
                this.words[0] = 0,
                this;
            var T, C;
            _ > 0 ? (T = this,
            C = y) : (T = y,
            C = this);
            for (var P = 0, W = 0; W < C.length; W++)
                b = (T.words[W] | 0) - (C.words[W] | 0) + P,
                P = b >> 26,
                this.words[W] = b & 67108863;
            for (; P !== 0 && W < T.length; W++)
                b = (T.words[W] | 0) + P,
                P = b >> 26,
                this.words[W] = b & 67108863;
            if (P === 0 && W < T.length && T !== this)
                for (; W < T.length; W++)
                    this.words[W] = T.words[W];
            return this.length = Math.max(this.length, W),
            T !== this && (this.negative = 1),
            this._strip()
        }
        ,
        s.prototype.sub = function(y) {
            return this.clone().isub(y)
        }
        ;
        function I(B, y, b) {
            b.negative = y.negative ^ B.negative;
            var _ = B.length + y.length | 0;
            b.length = _,
            _ = _ - 1 | 0;
            var T = B.words[0] | 0
              , C = y.words[0] | 0
              , P = T * C
              , W = P & 67108863
              , N = P / 67108864 | 0;
            b.words[0] = W;
            for (var w = 1; w < _; w++) {
                for (var U = N >>> 26, re = N & 67108863, ie = Math.min(w, y.length - 1), ue = Math.max(0, w - B.length + 1); ue <= ie; ue++) {
                    var Q = w - ue | 0;
                    T = B.words[Q] | 0,
                    C = y.words[ue] | 0,
                    P = T * C + re,
                    U += P / 67108864 | 0,
                    re = P & 67108863
                }
                b.words[w] = re | 0,
                N = U | 0
            }
            return N !== 0 ? b.words[w] = N | 0 : b.length--,
            b._strip()
        }
        var M = function(y, b, _) {
            var T = y.words, C = b.words, P = _.words, W = 0, N, w, U, re = T[0] | 0, ie = re & 8191, ue = re >>> 13, Q = T[1] | 0, ee = Q & 8191, te = Q >>> 13, he = T[2] | 0, xe = he & 8191, Ae = he >>> 13, z = T[3] | 0, H = z & 8191, Y = z >>> 13, se = T[4] | 0, X = se & 8191, ce = se >>> 13, me = T[5] | 0, oe = me & 8191, ae = me >>> 13, ne = T[6] | 0, de = ne & 8191, ye = ne >>> 13, ve = T[7] | 0, Ee = ve & 8191, m = ve >>> 13, f = T[8] | 0, d = f & 8191, E = f >>> 13, R = T[9] | 0, j = R & 8191, V = R >>> 13, pe = C[0] | 0, _e = pe & 8191, ge = pe >>> 13, Ce = C[1] | 0, we = Ce & 8191, Tt = Ce >>> 13, qm = C[2] | 0, Ct = qm & 8191, kt = qm >>> 13, Wm = C[3] | 0, Lt = Wm & 8191, Ot = Wm >>> 13, Vm = C[4] | 0, Nt = Vm & 8191, Rt = Vm >>> 13, Km = C[5] | 0, Bt = Km & 8191, Pt = Km >>> 13, Gm = C[6] | 0, jt = Gm & 8191, Dt = Gm >>> 13, Qm = C[7] | 0, Ut = Qm & 8191, zt = Qm >>> 13, Ym = C[8] | 0, $t = Ym & 8191, Ft = Ym >>> 13, Zm = C[9] | 0, Ht = Zm & 8191, qt = Zm >>> 13;
            _.negative = y.negative ^ b.negative,
            _.length = 19,
            N = Math.imul(ie, _e),
            w = Math.imul(ie, ge),
            w = w + Math.imul(ue, _e) | 0,
            U = Math.imul(ue, ge);
            var _d = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (_d >>> 26) | 0,
            _d &= 67108863,
            N = Math.imul(ee, _e),
            w = Math.imul(ee, ge),
            w = w + Math.imul(te, _e) | 0,
            U = Math.imul(te, ge),
            N = N + Math.imul(ie, we) | 0,
            w = w + Math.imul(ie, Tt) | 0,
            w = w + Math.imul(ue, we) | 0,
            U = U + Math.imul(ue, Tt) | 0;
            var Ad = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Ad >>> 26) | 0,
            Ad &= 67108863,
            N = Math.imul(xe, _e),
            w = Math.imul(xe, ge),
            w = w + Math.imul(Ae, _e) | 0,
            U = Math.imul(Ae, ge),
            N = N + Math.imul(ee, we) | 0,
            w = w + Math.imul(ee, Tt) | 0,
            w = w + Math.imul(te, we) | 0,
            U = U + Math.imul(te, Tt) | 0,
            N = N + Math.imul(ie, Ct) | 0,
            w = w + Math.imul(ie, kt) | 0,
            w = w + Math.imul(ue, Ct) | 0,
            U = U + Math.imul(ue, kt) | 0;
            var Md = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Md >>> 26) | 0,
            Md &= 67108863,
            N = Math.imul(H, _e),
            w = Math.imul(H, ge),
            w = w + Math.imul(Y, _e) | 0,
            U = Math.imul(Y, ge),
            N = N + Math.imul(xe, we) | 0,
            w = w + Math.imul(xe, Tt) | 0,
            w = w + Math.imul(Ae, we) | 0,
            U = U + Math.imul(Ae, Tt) | 0,
            N = N + Math.imul(ee, Ct) | 0,
            w = w + Math.imul(ee, kt) | 0,
            w = w + Math.imul(te, Ct) | 0,
            U = U + Math.imul(te, kt) | 0,
            N = N + Math.imul(ie, Lt) | 0,
            w = w + Math.imul(ie, Ot) | 0,
            w = w + Math.imul(ue, Lt) | 0,
            U = U + Math.imul(ue, Ot) | 0;
            var Id = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Id >>> 26) | 0,
            Id &= 67108863,
            N = Math.imul(X, _e),
            w = Math.imul(X, ge),
            w = w + Math.imul(ce, _e) | 0,
            U = Math.imul(ce, ge),
            N = N + Math.imul(H, we) | 0,
            w = w + Math.imul(H, Tt) | 0,
            w = w + Math.imul(Y, we) | 0,
            U = U + Math.imul(Y, Tt) | 0,
            N = N + Math.imul(xe, Ct) | 0,
            w = w + Math.imul(xe, kt) | 0,
            w = w + Math.imul(Ae, Ct) | 0,
            U = U + Math.imul(Ae, kt) | 0,
            N = N + Math.imul(ee, Lt) | 0,
            w = w + Math.imul(ee, Ot) | 0,
            w = w + Math.imul(te, Lt) | 0,
            U = U + Math.imul(te, Ot) | 0,
            N = N + Math.imul(ie, Nt) | 0,
            w = w + Math.imul(ie, Rt) | 0,
            w = w + Math.imul(ue, Nt) | 0,
            U = U + Math.imul(ue, Rt) | 0;
            var Td = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Td >>> 26) | 0,
            Td &= 67108863,
            N = Math.imul(oe, _e),
            w = Math.imul(oe, ge),
            w = w + Math.imul(ae, _e) | 0,
            U = Math.imul(ae, ge),
            N = N + Math.imul(X, we) | 0,
            w = w + Math.imul(X, Tt) | 0,
            w = w + Math.imul(ce, we) | 0,
            U = U + Math.imul(ce, Tt) | 0,
            N = N + Math.imul(H, Ct) | 0,
            w = w + Math.imul(H, kt) | 0,
            w = w + Math.imul(Y, Ct) | 0,
            U = U + Math.imul(Y, kt) | 0,
            N = N + Math.imul(xe, Lt) | 0,
            w = w + Math.imul(xe, Ot) | 0,
            w = w + Math.imul(Ae, Lt) | 0,
            U = U + Math.imul(Ae, Ot) | 0,
            N = N + Math.imul(ee, Nt) | 0,
            w = w + Math.imul(ee, Rt) | 0,
            w = w + Math.imul(te, Nt) | 0,
            U = U + Math.imul(te, Rt) | 0,
            N = N + Math.imul(ie, Bt) | 0,
            w = w + Math.imul(ie, Pt) | 0,
            w = w + Math.imul(ue, Bt) | 0,
            U = U + Math.imul(ue, Pt) | 0;
            var Cd = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Cd >>> 26) | 0,
            Cd &= 67108863,
            N = Math.imul(de, _e),
            w = Math.imul(de, ge),
            w = w + Math.imul(ye, _e) | 0,
            U = Math.imul(ye, ge),
            N = N + Math.imul(oe, we) | 0,
            w = w + Math.imul(oe, Tt) | 0,
            w = w + Math.imul(ae, we) | 0,
            U = U + Math.imul(ae, Tt) | 0,
            N = N + Math.imul(X, Ct) | 0,
            w = w + Math.imul(X, kt) | 0,
            w = w + Math.imul(ce, Ct) | 0,
            U = U + Math.imul(ce, kt) | 0,
            N = N + Math.imul(H, Lt) | 0,
            w = w + Math.imul(H, Ot) | 0,
            w = w + Math.imul(Y, Lt) | 0,
            U = U + Math.imul(Y, Ot) | 0,
            N = N + Math.imul(xe, Nt) | 0,
            w = w + Math.imul(xe, Rt) | 0,
            w = w + Math.imul(Ae, Nt) | 0,
            U = U + Math.imul(Ae, Rt) | 0,
            N = N + Math.imul(ee, Bt) | 0,
            w = w + Math.imul(ee, Pt) | 0,
            w = w + Math.imul(te, Bt) | 0,
            U = U + Math.imul(te, Pt) | 0,
            N = N + Math.imul(ie, jt) | 0,
            w = w + Math.imul(ie, Dt) | 0,
            w = w + Math.imul(ue, jt) | 0,
            U = U + Math.imul(ue, Dt) | 0;
            var kd = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (kd >>> 26) | 0,
            kd &= 67108863,
            N = Math.imul(Ee, _e),
            w = Math.imul(Ee, ge),
            w = w + Math.imul(m, _e) | 0,
            U = Math.imul(m, ge),
            N = N + Math.imul(de, we) | 0,
            w = w + Math.imul(de, Tt) | 0,
            w = w + Math.imul(ye, we) | 0,
            U = U + Math.imul(ye, Tt) | 0,
            N = N + Math.imul(oe, Ct) | 0,
            w = w + Math.imul(oe, kt) | 0,
            w = w + Math.imul(ae, Ct) | 0,
            U = U + Math.imul(ae, kt) | 0,
            N = N + Math.imul(X, Lt) | 0,
            w = w + Math.imul(X, Ot) | 0,
            w = w + Math.imul(ce, Lt) | 0,
            U = U + Math.imul(ce, Ot) | 0,
            N = N + Math.imul(H, Nt) | 0,
            w = w + Math.imul(H, Rt) | 0,
            w = w + Math.imul(Y, Nt) | 0,
            U = U + Math.imul(Y, Rt) | 0,
            N = N + Math.imul(xe, Bt) | 0,
            w = w + Math.imul(xe, Pt) | 0,
            w = w + Math.imul(Ae, Bt) | 0,
            U = U + Math.imul(Ae, Pt) | 0,
            N = N + Math.imul(ee, jt) | 0,
            w = w + Math.imul(ee, Dt) | 0,
            w = w + Math.imul(te, jt) | 0,
            U = U + Math.imul(te, Dt) | 0,
            N = N + Math.imul(ie, Ut) | 0,
            w = w + Math.imul(ie, zt) | 0,
            w = w + Math.imul(ue, Ut) | 0,
            U = U + Math.imul(ue, zt) | 0;
            var Ld = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Ld >>> 26) | 0,
            Ld &= 67108863,
            N = Math.imul(d, _e),
            w = Math.imul(d, ge),
            w = w + Math.imul(E, _e) | 0,
            U = Math.imul(E, ge),
            N = N + Math.imul(Ee, we) | 0,
            w = w + Math.imul(Ee, Tt) | 0,
            w = w + Math.imul(m, we) | 0,
            U = U + Math.imul(m, Tt) | 0,
            N = N + Math.imul(de, Ct) | 0,
            w = w + Math.imul(de, kt) | 0,
            w = w + Math.imul(ye, Ct) | 0,
            U = U + Math.imul(ye, kt) | 0,
            N = N + Math.imul(oe, Lt) | 0,
            w = w + Math.imul(oe, Ot) | 0,
            w = w + Math.imul(ae, Lt) | 0,
            U = U + Math.imul(ae, Ot) | 0,
            N = N + Math.imul(X, Nt) | 0,
            w = w + Math.imul(X, Rt) | 0,
            w = w + Math.imul(ce, Nt) | 0,
            U = U + Math.imul(ce, Rt) | 0,
            N = N + Math.imul(H, Bt) | 0,
            w = w + Math.imul(H, Pt) | 0,
            w = w + Math.imul(Y, Bt) | 0,
            U = U + Math.imul(Y, Pt) | 0,
            N = N + Math.imul(xe, jt) | 0,
            w = w + Math.imul(xe, Dt) | 0,
            w = w + Math.imul(Ae, jt) | 0,
            U = U + Math.imul(Ae, Dt) | 0,
            N = N + Math.imul(ee, Ut) | 0,
            w = w + Math.imul(ee, zt) | 0,
            w = w + Math.imul(te, Ut) | 0,
            U = U + Math.imul(te, zt) | 0,
            N = N + Math.imul(ie, $t) | 0,
            w = w + Math.imul(ie, Ft) | 0,
            w = w + Math.imul(ue, $t) | 0,
            U = U + Math.imul(ue, Ft) | 0;
            var Od = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Od >>> 26) | 0,
            Od &= 67108863,
            N = Math.imul(j, _e),
            w = Math.imul(j, ge),
            w = w + Math.imul(V, _e) | 0,
            U = Math.imul(V, ge),
            N = N + Math.imul(d, we) | 0,
            w = w + Math.imul(d, Tt) | 0,
            w = w + Math.imul(E, we) | 0,
            U = U + Math.imul(E, Tt) | 0,
            N = N + Math.imul(Ee, Ct) | 0,
            w = w + Math.imul(Ee, kt) | 0,
            w = w + Math.imul(m, Ct) | 0,
            U = U + Math.imul(m, kt) | 0,
            N = N + Math.imul(de, Lt) | 0,
            w = w + Math.imul(de, Ot) | 0,
            w = w + Math.imul(ye, Lt) | 0,
            U = U + Math.imul(ye, Ot) | 0,
            N = N + Math.imul(oe, Nt) | 0,
            w = w + Math.imul(oe, Rt) | 0,
            w = w + Math.imul(ae, Nt) | 0,
            U = U + Math.imul(ae, Rt) | 0,
            N = N + Math.imul(X, Bt) | 0,
            w = w + Math.imul(X, Pt) | 0,
            w = w + Math.imul(ce, Bt) | 0,
            U = U + Math.imul(ce, Pt) | 0,
            N = N + Math.imul(H, jt) | 0,
            w = w + Math.imul(H, Dt) | 0,
            w = w + Math.imul(Y, jt) | 0,
            U = U + Math.imul(Y, Dt) | 0,
            N = N + Math.imul(xe, Ut) | 0,
            w = w + Math.imul(xe, zt) | 0,
            w = w + Math.imul(Ae, Ut) | 0,
            U = U + Math.imul(Ae, zt) | 0,
            N = N + Math.imul(ee, $t) | 0,
            w = w + Math.imul(ee, Ft) | 0,
            w = w + Math.imul(te, $t) | 0,
            U = U + Math.imul(te, Ft) | 0,
            N = N + Math.imul(ie, Ht) | 0,
            w = w + Math.imul(ie, qt) | 0,
            w = w + Math.imul(ue, Ht) | 0,
            U = U + Math.imul(ue, qt) | 0;
            var Nd = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Nd >>> 26) | 0,
            Nd &= 67108863,
            N = Math.imul(j, we),
            w = Math.imul(j, Tt),
            w = w + Math.imul(V, we) | 0,
            U = Math.imul(V, Tt),
            N = N + Math.imul(d, Ct) | 0,
            w = w + Math.imul(d, kt) | 0,
            w = w + Math.imul(E, Ct) | 0,
            U = U + Math.imul(E, kt) | 0,
            N = N + Math.imul(Ee, Lt) | 0,
            w = w + Math.imul(Ee, Ot) | 0,
            w = w + Math.imul(m, Lt) | 0,
            U = U + Math.imul(m, Ot) | 0,
            N = N + Math.imul(de, Nt) | 0,
            w = w + Math.imul(de, Rt) | 0,
            w = w + Math.imul(ye, Nt) | 0,
            U = U + Math.imul(ye, Rt) | 0,
            N = N + Math.imul(oe, Bt) | 0,
            w = w + Math.imul(oe, Pt) | 0,
            w = w + Math.imul(ae, Bt) | 0,
            U = U + Math.imul(ae, Pt) | 0,
            N = N + Math.imul(X, jt) | 0,
            w = w + Math.imul(X, Dt) | 0,
            w = w + Math.imul(ce, jt) | 0,
            U = U + Math.imul(ce, Dt) | 0,
            N = N + Math.imul(H, Ut) | 0,
            w = w + Math.imul(H, zt) | 0,
            w = w + Math.imul(Y, Ut) | 0,
            U = U + Math.imul(Y, zt) | 0,
            N = N + Math.imul(xe, $t) | 0,
            w = w + Math.imul(xe, Ft) | 0,
            w = w + Math.imul(Ae, $t) | 0,
            U = U + Math.imul(Ae, Ft) | 0,
            N = N + Math.imul(ee, Ht) | 0,
            w = w + Math.imul(ee, qt) | 0,
            w = w + Math.imul(te, Ht) | 0,
            U = U + Math.imul(te, qt) | 0;
            var Rd = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Rd >>> 26) | 0,
            Rd &= 67108863,
            N = Math.imul(j, Ct),
            w = Math.imul(j, kt),
            w = w + Math.imul(V, Ct) | 0,
            U = Math.imul(V, kt),
            N = N + Math.imul(d, Lt) | 0,
            w = w + Math.imul(d, Ot) | 0,
            w = w + Math.imul(E, Lt) | 0,
            U = U + Math.imul(E, Ot) | 0,
            N = N + Math.imul(Ee, Nt) | 0,
            w = w + Math.imul(Ee, Rt) | 0,
            w = w + Math.imul(m, Nt) | 0,
            U = U + Math.imul(m, Rt) | 0,
            N = N + Math.imul(de, Bt) | 0,
            w = w + Math.imul(de, Pt) | 0,
            w = w + Math.imul(ye, Bt) | 0,
            U = U + Math.imul(ye, Pt) | 0,
            N = N + Math.imul(oe, jt) | 0,
            w = w + Math.imul(oe, Dt) | 0,
            w = w + Math.imul(ae, jt) | 0,
            U = U + Math.imul(ae, Dt) | 0,
            N = N + Math.imul(X, Ut) | 0,
            w = w + Math.imul(X, zt) | 0,
            w = w + Math.imul(ce, Ut) | 0,
            U = U + Math.imul(ce, zt) | 0,
            N = N + Math.imul(H, $t) | 0,
            w = w + Math.imul(H, Ft) | 0,
            w = w + Math.imul(Y, $t) | 0,
            U = U + Math.imul(Y, Ft) | 0,
            N = N + Math.imul(xe, Ht) | 0,
            w = w + Math.imul(xe, qt) | 0,
            w = w + Math.imul(Ae, Ht) | 0,
            U = U + Math.imul(Ae, qt) | 0;
            var Bd = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Bd >>> 26) | 0,
            Bd &= 67108863,
            N = Math.imul(j, Lt),
            w = Math.imul(j, Ot),
            w = w + Math.imul(V, Lt) | 0,
            U = Math.imul(V, Ot),
            N = N + Math.imul(d, Nt) | 0,
            w = w + Math.imul(d, Rt) | 0,
            w = w + Math.imul(E, Nt) | 0,
            U = U + Math.imul(E, Rt) | 0,
            N = N + Math.imul(Ee, Bt) | 0,
            w = w + Math.imul(Ee, Pt) | 0,
            w = w + Math.imul(m, Bt) | 0,
            U = U + Math.imul(m, Pt) | 0,
            N = N + Math.imul(de, jt) | 0,
            w = w + Math.imul(de, Dt) | 0,
            w = w + Math.imul(ye, jt) | 0,
            U = U + Math.imul(ye, Dt) | 0,
            N = N + Math.imul(oe, Ut) | 0,
            w = w + Math.imul(oe, zt) | 0,
            w = w + Math.imul(ae, Ut) | 0,
            U = U + Math.imul(ae, zt) | 0,
            N = N + Math.imul(X, $t) | 0,
            w = w + Math.imul(X, Ft) | 0,
            w = w + Math.imul(ce, $t) | 0,
            U = U + Math.imul(ce, Ft) | 0,
            N = N + Math.imul(H, Ht) | 0,
            w = w + Math.imul(H, qt) | 0,
            w = w + Math.imul(Y, Ht) | 0,
            U = U + Math.imul(Y, qt) | 0;
            var Pd = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Pd >>> 26) | 0,
            Pd &= 67108863,
            N = Math.imul(j, Nt),
            w = Math.imul(j, Rt),
            w = w + Math.imul(V, Nt) | 0,
            U = Math.imul(V, Rt),
            N = N + Math.imul(d, Bt) | 0,
            w = w + Math.imul(d, Pt) | 0,
            w = w + Math.imul(E, Bt) | 0,
            U = U + Math.imul(E, Pt) | 0,
            N = N + Math.imul(Ee, jt) | 0,
            w = w + Math.imul(Ee, Dt) | 0,
            w = w + Math.imul(m, jt) | 0,
            U = U + Math.imul(m, Dt) | 0,
            N = N + Math.imul(de, Ut) | 0,
            w = w + Math.imul(de, zt) | 0,
            w = w + Math.imul(ye, Ut) | 0,
            U = U + Math.imul(ye, zt) | 0,
            N = N + Math.imul(oe, $t) | 0,
            w = w + Math.imul(oe, Ft) | 0,
            w = w + Math.imul(ae, $t) | 0,
            U = U + Math.imul(ae, Ft) | 0,
            N = N + Math.imul(X, Ht) | 0,
            w = w + Math.imul(X, qt) | 0,
            w = w + Math.imul(ce, Ht) | 0,
            U = U + Math.imul(ce, qt) | 0;
            var jd = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (jd >>> 26) | 0,
            jd &= 67108863,
            N = Math.imul(j, Bt),
            w = Math.imul(j, Pt),
            w = w + Math.imul(V, Bt) | 0,
            U = Math.imul(V, Pt),
            N = N + Math.imul(d, jt) | 0,
            w = w + Math.imul(d, Dt) | 0,
            w = w + Math.imul(E, jt) | 0,
            U = U + Math.imul(E, Dt) | 0,
            N = N + Math.imul(Ee, Ut) | 0,
            w = w + Math.imul(Ee, zt) | 0,
            w = w + Math.imul(m, Ut) | 0,
            U = U + Math.imul(m, zt) | 0,
            N = N + Math.imul(de, $t) | 0,
            w = w + Math.imul(de, Ft) | 0,
            w = w + Math.imul(ye, $t) | 0,
            U = U + Math.imul(ye, Ft) | 0,
            N = N + Math.imul(oe, Ht) | 0,
            w = w + Math.imul(oe, qt) | 0,
            w = w + Math.imul(ae, Ht) | 0,
            U = U + Math.imul(ae, qt) | 0;
            var Dd = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Dd >>> 26) | 0,
            Dd &= 67108863,
            N = Math.imul(j, jt),
            w = Math.imul(j, Dt),
            w = w + Math.imul(V, jt) | 0,
            U = Math.imul(V, Dt),
            N = N + Math.imul(d, Ut) | 0,
            w = w + Math.imul(d, zt) | 0,
            w = w + Math.imul(E, Ut) | 0,
            U = U + Math.imul(E, zt) | 0,
            N = N + Math.imul(Ee, $t) | 0,
            w = w + Math.imul(Ee, Ft) | 0,
            w = w + Math.imul(m, $t) | 0,
            U = U + Math.imul(m, Ft) | 0,
            N = N + Math.imul(de, Ht) | 0,
            w = w + Math.imul(de, qt) | 0,
            w = w + Math.imul(ye, Ht) | 0,
            U = U + Math.imul(ye, qt) | 0;
            var Ud = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (Ud >>> 26) | 0,
            Ud &= 67108863,
            N = Math.imul(j, Ut),
            w = Math.imul(j, zt),
            w = w + Math.imul(V, Ut) | 0,
            U = Math.imul(V, zt),
            N = N + Math.imul(d, $t) | 0,
            w = w + Math.imul(d, Ft) | 0,
            w = w + Math.imul(E, $t) | 0,
            U = U + Math.imul(E, Ft) | 0,
            N = N + Math.imul(Ee, Ht) | 0,
            w = w + Math.imul(Ee, qt) | 0,
            w = w + Math.imul(m, Ht) | 0,
            U = U + Math.imul(m, qt) | 0;
            var zd = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + (zd >>> 26) | 0,
            zd &= 67108863,
            N = Math.imul(j, $t),
            w = Math.imul(j, Ft),
            w = w + Math.imul(V, $t) | 0,
            U = Math.imul(V, Ft),
            N = N + Math.imul(d, Ht) | 0,
            w = w + Math.imul(d, qt) | 0,
            w = w + Math.imul(E, Ht) | 0,
            U = U + Math.imul(E, qt) | 0;
            var $d = (W + N | 0) + ((w & 8191) << 13) | 0;
            W = (U + (w >>> 13) | 0) + ($d >>> 26) | 0,
            $d &= 67108863,
            N = Math.imul(j, Ht),
            w = Math.imul(j, qt),
            w = w + Math.imul(V, Ht) | 0,
            U = Math.imul(V, qt);
            var Fd = (W + N | 0) + ((w & 8191) << 13) | 0;
            return W = (U + (w >>> 13) | 0) + (Fd >>> 26) | 0,
            Fd &= 67108863,
            P[0] = _d,
            P[1] = Ad,
            P[2] = Md,
            P[3] = Id,
            P[4] = Td,
            P[5] = Cd,
            P[6] = kd,
            P[7] = Ld,
            P[8] = Od,
            P[9] = Nd,
            P[10] = Rd,
            P[11] = Bd,
            P[12] = Pd,
            P[13] = jd,
            P[14] = Dd,
            P[15] = Ud,
            P[16] = zd,
            P[17] = $d,
            P[18] = Fd,
            W !== 0 && (P[19] = W,
            _.length++),
            _
        };
        Math.imul || (M = I);
        function A(B, y, b) {
            b.negative = y.negative ^ B.negative,
            b.length = B.length + y.length;
            for (var _ = 0, T = 0, C = 0; C < b.length - 1; C++) {
                var P = T;
                T = 0;
                for (var W = _ & 67108863, N = Math.min(C, y.length - 1), w = Math.max(0, C - B.length + 1); w <= N; w++) {
                    var U = C - w
                      , re = B.words[U] | 0
                      , ie = y.words[w] | 0
                      , ue = re * ie
                      , Q = ue & 67108863;
                    P = P + (ue / 67108864 | 0) | 0,
                    Q = Q + W | 0,
                    W = Q & 67108863,
                    P = P + (Q >>> 26) | 0,
                    T += P >>> 26,
                    P &= 67108863
                }
                b.words[C] = W,
                _ = P,
                P = T
            }
            return _ !== 0 ? b.words[C] = _ : b.length--,
            b._strip()
        }
        function k(B, y, b) {
            return A(B, y, b)
        }
        s.prototype.mulTo = function(y, b) {
            var _, T = this.length + y.length;
            return this.length === 10 && y.length === 10 ? _ = M(this, y, b) : T < 63 ? _ = I(this, y, b) : T < 1024 ? _ = A(this, y, b) : _ = k(this, y, b),
            _
        }
        ,
        s.prototype.mul = function(y) {
            var b = new s(null);
            return b.words = new Array(this.length + y.length),
            this.mulTo(y, b)
        }
        ,
        s.prototype.mulf = function(y) {
            var b = new s(null);
            return b.words = new Array(this.length + y.length),
            k(this, y, b)
        }
        ,
        s.prototype.imul = function(y) {
            return this.clone().mulTo(y, this)
        }
        ,
        s.prototype.imuln = function(y) {
            var b = y < 0;
            b && (y = -y),
            n(typeof y == "number"),
            n(y < 67108864);
            for (var _ = 0, T = 0; T < this.length; T++) {
                var C = (this.words[T] | 0) * y
                  , P = (C & 67108863) + (_ & 67108863);
                _ >>= 26,
                _ += C / 67108864 | 0,
                _ += P >>> 26,
                this.words[T] = P & 67108863
            }
            return _ !== 0 && (this.words[T] = _,
            this.length++),
            b ? this.ineg() : this
        }
        ,
        s.prototype.muln = function(y) {
            return this.clone().imuln(y)
        }
        ,
        s.prototype.sqr = function() {
            return this.mul(this)
        }
        ,
        s.prototype.isqr = function() {
            return this.imul(this.clone())
        }
        ,
        s.prototype.pow = function(y) {
            var b = v(y);
            if (b.length === 0)
                return new s(1);
            for (var _ = this, T = 0; T < b.length && b[T] === 0; T++,
            _ = _.sqr())
                ;
            if (++T < b.length)
                for (var C = _.sqr(); T < b.length; T++,
                C = C.sqr())
                    b[T] !== 0 && (_ = _.mul(C));
            return _
        }
        ,
        s.prototype.iushln = function(y) {
            n(typeof y == "number" && y >= 0);
            var b = y % 26, _ = (y - b) / 26, T = 67108863 >>> 26 - b << 26 - b, C;
            if (b !== 0) {
                var P = 0;
                for (C = 0; C < this.length; C++) {
                    var W = this.words[C] & T
                      , N = (this.words[C] | 0) - W << b;
                    this.words[C] = N | P,
                    P = W >>> 26 - b
                }
                P && (this.words[C] = P,
                this.length++)
            }
            if (_ !== 0) {
                for (C = this.length - 1; C >= 0; C--)
                    this.words[C + _] = this.words[C];
                for (C = 0; C < _; C++)
                    this.words[C] = 0;
                this.length += _
            }
            return this._strip()
        }
        ,
        s.prototype.ishln = function(y) {
            return n(this.negative === 0),
            this.iushln(y)
        }
        ,
        s.prototype.iushrn = function(y, b, _) {
            n(typeof y == "number" && y >= 0);
            var T;
            b ? T = (b - b % 26) / 26 : T = 0;
            var C = y % 26
              , P = Math.min((y - C) / 26, this.length)
              , W = 67108863 ^ 67108863 >>> C << C
              , N = _;
            if (T -= P,
            T = Math.max(0, T),
            N) {
                for (var w = 0; w < P; w++)
                    N.words[w] = this.words[w];
                N.length = P
            }
            if (P !== 0)
                if (this.length > P)
                    for (this.length -= P,
                    w = 0; w < this.length; w++)
                        this.words[w] = this.words[w + P];
                else
                    this.words[0] = 0,
                    this.length = 1;
            var U = 0;
            for (w = this.length - 1; w >= 0 && (U !== 0 || w >= T); w--) {
                var re = this.words[w] | 0;
                this.words[w] = U << 26 - C | re >>> C,
                U = re & W
            }
            return N && U !== 0 && (N.words[N.length++] = U),
            this.length === 0 && (this.words[0] = 0,
            this.length = 1),
            this._strip()
        }
        ,
        s.prototype.ishrn = function(y, b, _) {
            return n(this.negative === 0),
            this.iushrn(y, b, _)
        }
        ,
        s.prototype.shln = function(y) {
            return this.clone().ishln(y)
        }
        ,
        s.prototype.ushln = function(y) {
            return this.clone().iushln(y)
        }
        ,
        s.prototype.shrn = function(y) {
            return this.clone().ishrn(y)
        }
        ,
        s.prototype.ushrn = function(y) {
            return this.clone().iushrn(y)
        }
        ,
        s.prototype.testn = function(y) {
            n(typeof y == "number" && y >= 0);
            var b = y % 26
              , _ = (y - b) / 26
              , T = 1 << b;
            if (this.length <= _)
                return !1;
            var C = this.words[_];
            return !!(C & T)
        }
        ,
        s.prototype.imaskn = function(y) {
            n(typeof y == "number" && y >= 0);
            var b = y % 26
              , _ = (y - b) / 26;
            if (n(this.negative === 0, "imaskn works only with positive numbers"),
            this.length <= _)
                return this;
            if (b !== 0 && _++,
            this.length = Math.min(_, this.length),
            b !== 0) {
                var T = 67108863 ^ 67108863 >>> b << b;
                this.words[this.length - 1] &= T
            }
            return this._strip()
        }
        ,
        s.prototype.maskn = function(y) {
            return this.clone().imaskn(y)
        }
        ,
        s.prototype.iaddn = function(y) {
            return n(typeof y == "number"),
            n(y < 67108864),
            y < 0 ? this.isubn(-y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= y ? (this.words[0] = y - (this.words[0] | 0),
            this.negative = 0,
            this) : (this.negative = 0,
            this.isubn(y),
            this.negative = 1,
            this) : this._iaddn(y)
        }
        ,
        s.prototype._iaddn = function(y) {
            this.words[0] += y;
            for (var b = 0; b < this.length && this.words[b] >= 67108864; b++)
                this.words[b] -= 67108864,
                b === this.length - 1 ? this.words[b + 1] = 1 : this.words[b + 1]++;
            return this.length = Math.max(this.length, b + 1),
            this
        }
        ,
        s.prototype.isubn = function(y) {
            if (n(typeof y == "number"),
            n(y < 67108864),
            y < 0)
                return this.iaddn(-y);
            if (this.negative !== 0)
                return this.negative = 0,
                this.iaddn(y),
                this.negative = 1,
                this;
            if (this.words[0] -= y,
            this.length === 1 && this.words[0] < 0)
                this.words[0] = -this.words[0],
                this.negative = 1;
            else
                for (var b = 0; b < this.length && this.words[b] < 0; b++)
                    this.words[b] += 67108864,
                    this.words[b + 1] -= 1;
            return this._strip()
        }
        ,
        s.prototype.addn = function(y) {
            return this.clone().iaddn(y)
        }
        ,
        s.prototype.subn = function(y) {
            return this.clone().isubn(y)
        }
        ,
        s.prototype.iabs = function() {
            return this.negative = 0,
            this
        }
        ,
        s.prototype.abs = function() {
            return this.clone().iabs()
        }
        ,
        s.prototype._ishlnsubmul = function(y, b, _) {
            var T = y.length + _, C;
            this._expand(T);
            var P, W = 0;
            for (C = 0; C < y.length; C++) {
                P = (this.words[C + _] | 0) + W;
                var N = (y.words[C] | 0) * b;
                P -= N & 67108863,
                W = (P >> 26) - (N / 67108864 | 0),
                this.words[C + _] = P & 67108863
            }
            for (; C < this.length - _; C++)
                P = (this.words[C + _] | 0) + W,
                W = P >> 26,
                this.words[C + _] = P & 67108863;
            if (W === 0)
                return this._strip();
            for (n(W === -1),
            W = 0,
            C = 0; C < this.length; C++)
                P = -(this.words[C] | 0) + W,
                W = P >> 26,
                this.words[C] = P & 67108863;
            return this.negative = 1,
            this._strip()
        }
        ,
        s.prototype._wordDiv = function(y, b) {
            var _ = this.length - y.length
              , T = this.clone()
              , C = y
              , P = C.words[C.length - 1] | 0
              , W = this._countBits(P);
            _ = 26 - W,
            _ !== 0 && (C = C.ushln(_),
            T.iushln(_),
            P = C.words[C.length - 1] | 0);
            var N = T.length - C.length, w;
            if (b !== "mod") {
                w = new s(null),
                w.length = N + 1,
                w.words = new Array(w.length);
                for (var U = 0; U < w.length; U++)
                    w.words[U] = 0
            }
            var re = T.clone()._ishlnsubmul(C, 1, N);
            re.negative === 0 && (T = re,
            w && (w.words[N] = 1));
            for (var ie = N - 1; ie >= 0; ie--) {
                var ue = (T.words[C.length + ie] | 0) * 67108864 + (T.words[C.length + ie - 1] | 0);
                for (ue = Math.min(ue / P | 0, 67108863),
                T._ishlnsubmul(C, ue, ie); T.negative !== 0; )
                    ue--,
                    T.negative = 0,
                    T._ishlnsubmul(C, 1, ie),
                    T.isZero() || (T.negative ^= 1);
                w && (w.words[ie] = ue)
            }
            return w && w._strip(),
            T._strip(),
            b !== "div" && _ !== 0 && T.iushrn(_),
            {
                div: w || null,
                mod: T
            }
        }
        ,
        s.prototype.divmod = function(y, b, _) {
            if (n(!y.isZero()),
            this.isZero())
                return {
                    div: new s(0),
                    mod: new s(0)
                };
            var T, C, P;
            return this.negative !== 0 && y.negative === 0 ? (P = this.neg().divmod(y, b),
            b !== "mod" && (T = P.div.neg()),
            b !== "div" && (C = P.mod.neg(),
            _ && C.negative !== 0 && C.iadd(y)),
            {
                div: T,
                mod: C
            }) : this.negative === 0 && y.negative !== 0 ? (P = this.divmod(y.neg(), b),
            b !== "mod" && (T = P.div.neg()),
            {
                div: T,
                mod: P.mod
            }) : this.negative & y.negative ? (P = this.neg().divmod(y.neg(), b),
            b !== "div" && (C = P.mod.neg(),
            _ && C.negative !== 0 && C.isub(y)),
            {
                div: P.div,
                mod: C
            }) : y.length > this.length || this.cmp(y) < 0 ? {
                div: new s(0),
                mod: this
            } : y.length === 1 ? b === "div" ? {
                div: this.divn(y.words[0]),
                mod: null
            } : b === "mod" ? {
                div: null,
                mod: new s(this.modrn(y.words[0]))
            } : {
                div: this.divn(y.words[0]),
                mod: new s(this.modrn(y.words[0]))
            } : this._wordDiv(y, b)
        }
        ,
        s.prototype.div = function(y) {
            return this.divmod(y, "div", !1).div
        }
        ,
        s.prototype.mod = function(y) {
            return this.divmod(y, "mod", !1).mod
        }
        ,
        s.prototype.umod = function(y) {
            return this.divmod(y, "mod", !0).mod
        }
        ,
        s.prototype.divRound = function(y) {
            var b = this.divmod(y);
            if (b.mod.isZero())
                return b.div;
            var _ = b.div.negative !== 0 ? b.mod.isub(y) : b.mod
              , T = y.ushrn(1)
              , C = y.andln(1)
              , P = _.cmp(T);
            return P < 0 || C === 1 && P === 0 ? b.div : b.div.negative !== 0 ? b.div.isubn(1) : b.div.iaddn(1)
        }
        ,
        s.prototype.modrn = function(y) {
            var b = y < 0;
            b && (y = -y),
            n(y <= 67108863);
            for (var _ = (1 << 26) % y, T = 0, C = this.length - 1; C >= 0; C--)
                T = (_ * T + (this.words[C] | 0)) % y;
            return b ? -T : T
        }
        ,
        s.prototype.modn = function(y) {
            return this.modrn(y)
        }
        ,
        s.prototype.idivn = function(y) {
            var b = y < 0;
            b && (y = -y),
            n(y <= 67108863);
            for (var _ = 0, T = this.length - 1; T >= 0; T--) {
                var C = (this.words[T] | 0) + _ * 67108864;
                this.words[T] = C / y | 0,
                _ = C % y
            }
            return this._strip(),
            b ? this.ineg() : this
        }
        ,
        s.prototype.divn = function(y) {
            return this.clone().idivn(y)
        }
        ,
        s.prototype.egcd = function(y) {
            n(y.negative === 0),
            n(!y.isZero());
            var b = this
              , _ = y.clone();
            b.negative !== 0 ? b = b.umod(y) : b = b.clone();
            for (var T = new s(1), C = new s(0), P = new s(0), W = new s(1), N = 0; b.isEven() && _.isEven(); )
                b.iushrn(1),
                _.iushrn(1),
                ++N;
            for (var w = _.clone(), U = b.clone(); !b.isZero(); ) {
                for (var re = 0, ie = 1; !(b.words[0] & ie) && re < 26; ++re,
                ie <<= 1)
                    ;
                if (re > 0)
                    for (b.iushrn(re); re-- > 0; )
                        (T.isOdd() || C.isOdd()) && (T.iadd(w),
                        C.isub(U)),
                        T.iushrn(1),
                        C.iushrn(1);
                for (var ue = 0, Q = 1; !(_.words[0] & Q) && ue < 26; ++ue,
                Q <<= 1)
                    ;
                if (ue > 0)
                    for (_.iushrn(ue); ue-- > 0; )
                        (P.isOdd() || W.isOdd()) && (P.iadd(w),
                        W.isub(U)),
                        P.iushrn(1),
                        W.iushrn(1);
                b.cmp(_) >= 0 ? (b.isub(_),
                T.isub(P),
                C.isub(W)) : (_.isub(b),
                P.isub(T),
                W.isub(C))
            }
            return {
                a: P,
                b: W,
                gcd: _.iushln(N)
            }
        }
        ,
        s.prototype._invmp = function(y) {
            n(y.negative === 0),
            n(!y.isZero());
            var b = this
              , _ = y.clone();
            b.negative !== 0 ? b = b.umod(y) : b = b.clone();
            for (var T = new s(1), C = new s(0), P = _.clone(); b.cmpn(1) > 0 && _.cmpn(1) > 0; ) {
                for (var W = 0, N = 1; !(b.words[0] & N) && W < 26; ++W,
                N <<= 1)
                    ;
                if (W > 0)
                    for (b.iushrn(W); W-- > 0; )
                        T.isOdd() && T.iadd(P),
                        T.iushrn(1);
                for (var w = 0, U = 1; !(_.words[0] & U) && w < 26; ++w,
                U <<= 1)
                    ;
                if (w > 0)
                    for (_.iushrn(w); w-- > 0; )
                        C.isOdd() && C.iadd(P),
                        C.iushrn(1);
                b.cmp(_) >= 0 ? (b.isub(_),
                T.isub(C)) : (_.isub(b),
                C.isub(T))
            }
            var re;
            return b.cmpn(1) === 0 ? re = T : re = C,
            re.cmpn(0) < 0 && re.iadd(y),
            re
        }
        ,
        s.prototype.gcd = function(y) {
            if (this.isZero())
                return y.abs();
            if (y.isZero())
                return this.abs();
            var b = this.clone()
              , _ = y.clone();
            b.negative = 0,
            _.negative = 0;
            for (var T = 0; b.isEven() && _.isEven(); T++)
                b.iushrn(1),
                _.iushrn(1);
            do {
                for (; b.isEven(); )
                    b.iushrn(1);
                for (; _.isEven(); )
                    _.iushrn(1);
                var C = b.cmp(_);
                if (C < 0) {
                    var P = b;
                    b = _,
                    _ = P
                } else if (C === 0 || _.cmpn(1) === 0)
                    break;
                b.isub(_)
            } while (!0);
            return _.iushln(T)
        }
        ,
        s.prototype.invm = function(y) {
            return this.egcd(y).a.umod(y)
        }
        ,
        s.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }
        ,
        s.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }
        ,
        s.prototype.andln = function(y) {
            return this.words[0] & y
        }
        ,
        s.prototype.bincn = function(y) {
            n(typeof y == "number");
            var b = y % 26
              , _ = (y - b) / 26
              , T = 1 << b;
            if (this.length <= _)
                return this._expand(_ + 1),
                this.words[_] |= T,
                this;
            for (var C = T, P = _; C !== 0 && P < this.length; P++) {
                var W = this.words[P] | 0;
                W += C,
                C = W >>> 26,
                W &= 67108863,
                this.words[P] = W
            }
            return C !== 0 && (this.words[P] = C,
            this.length++),
            this
        }
        ,
        s.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }
        ,
        s.prototype.cmpn = function(y) {
            var b = y < 0;
            if (this.negative !== 0 && !b)
                return -1;
            if (this.negative === 0 && b)
                return 1;
            this._strip();
            var _;
            if (this.length > 1)
                _ = 1;
            else {
                b && (y = -y),
                n(y <= 67108863, "Number is too big");
                var T = this.words[0] | 0;
                _ = T === y ? 0 : T < y ? -1 : 1
            }
            return this.negative !== 0 ? -_ | 0 : _
        }
        ,
        s.prototype.cmp = function(y) {
            if (this.negative !== 0 && y.negative === 0)
                return -1;
            if (this.negative === 0 && y.negative !== 0)
                return 1;
            var b = this.ucmp(y);
            return this.negative !== 0 ? -b | 0 : b
        }
        ,
        s.prototype.ucmp = function(y) {
            if (this.length > y.length)
                return 1;
            if (this.length < y.length)
                return -1;
            for (var b = 0, _ = this.length - 1; _ >= 0; _--) {
                var T = this.words[_] | 0
                  , C = y.words[_] | 0;
                if (T !== C) {
                    T < C ? b = -1 : T > C && (b = 1);
                    break
                }
            }
            return b
        }
        ,
        s.prototype.gtn = function(y) {
            return this.cmpn(y) === 1
        }
        ,
        s.prototype.gt = function(y) {
            return this.cmp(y) === 1
        }
        ,
        s.prototype.gten = function(y) {
            return this.cmpn(y) >= 0
        }
        ,
        s.prototype.gte = function(y) {
            return this.cmp(y) >= 0
        }
        ,
        s.prototype.ltn = function(y) {
            return this.cmpn(y) === -1
        }
        ,
        s.prototype.lt = function(y) {
            return this.cmp(y) === -1
        }
        ,
        s.prototype.lten = function(y) {
            return this.cmpn(y) <= 0
        }
        ,
        s.prototype.lte = function(y) {
            return this.cmp(y) <= 0
        }
        ,
        s.prototype.eqn = function(y) {
            return this.cmpn(y) === 0
        }
        ,
        s.prototype.eq = function(y) {
            return this.cmp(y) === 0
        }
        ,
        s.red = function(y) {
            return new F(y)
        }
        ,
        s.prototype.toRed = function(y) {
            return n(!this.red, "Already a number in reduction context"),
            n(this.negative === 0, "red works only with positives"),
            y.convertTo(this)._forceRed(y)
        }
        ,
        s.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"),
            this.red.convertFrom(this)
        }
        ,
        s.prototype._forceRed = function(y) {
            return this.red = y,
            this
        }
        ,
        s.prototype.forceRed = function(y) {
            return n(!this.red, "Already a number in reduction context"),
            this._forceRed(y)
        }
        ,
        s.prototype.redAdd = function(y) {
            return n(this.red, "redAdd works only with red numbers"),
            this.red.add(this, y)
        }
        ,
        s.prototype.redIAdd = function(y) {
            return n(this.red, "redIAdd works only with red numbers"),
            this.red.iadd(this, y)
        }
        ,
        s.prototype.redSub = function(y) {
            return n(this.red, "redSub works only with red numbers"),
            this.red.sub(this, y)
        }
        ,
        s.prototype.redISub = function(y) {
            return n(this.red, "redISub works only with red numbers"),
            this.red.isub(this, y)
        }
        ,
        s.prototype.redShl = function(y) {
            return n(this.red, "redShl works only with red numbers"),
            this.red.shl(this, y)
        }
        ,
        s.prototype.redMul = function(y) {
            return n(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, y),
            this.red.mul(this, y)
        }
        ,
        s.prototype.redIMul = function(y) {
            return n(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, y),
            this.red.imul(this, y)
        }
        ,
        s.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"),
            this.red._verify1(this),
            this.red.sqr(this)
        }
        ,
        s.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"),
            this.red._verify1(this),
            this.red.isqr(this)
        }
        ,
        s.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"),
            this.red._verify1(this),
            this.red.sqrt(this)
        }
        ,
        s.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"),
            this.red._verify1(this),
            this.red.invm(this)
        }
        ,
        s.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"),
            this.red._verify1(this),
            this.red.neg(this)
        }
        ,
        s.prototype.redPow = function(y) {
            return n(this.red && !y.red, "redPow(normalNum)"),
            this.red._verify1(this),
            this.red.pow(this, y)
        }
        ;
        var L = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function O(B, y) {
            this.name = B,
            this.p = new s(y,16),
            this.n = this.p.bitLength(),
            this.k = new s(1).iushln(this.n).isub(this.p),
            this.tmp = this._tmp()
        }
        O.prototype._tmp = function() {
            var y = new s(null);
            return y.words = new Array(Math.ceil(this.n / 13)),
            y
        }
        ,
        O.prototype.ireduce = function(y) {
            var b = y, _;
            do
                this.split(b, this.tmp),
                b = this.imulK(b),
                b = b.iadd(this.tmp),
                _ = b.bitLength();
            while (_ > this.n);
            var T = _ < this.n ? -1 : b.ucmp(this.p);
            return T === 0 ? (b.words[0] = 0,
            b.length = 1) : T > 0 ? b.isub(this.p) : b.strip !== void 0 ? b.strip() : b._strip(),
            b
        }
        ,
        O.prototype.split = function(y, b) {
            y.iushrn(this.n, 0, b)
        }
        ,
        O.prototype.imulK = function(y) {
            return y.imul(this.k)
        }
        ;
        function $() {
            O.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i($, O),
        $.prototype.split = function(y, b) {
            for (var _ = 4194303, T = Math.min(y.length, 9), C = 0; C < T; C++)
                b.words[C] = y.words[C];
            if (b.length = T,
            y.length <= 9) {
                y.words[0] = 0,
                y.length = 1;
                return
            }
            var P = y.words[9];
            for (b.words[b.length++] = P & _,
            C = 10; C < y.length; C++) {
                var W = y.words[C] | 0;
                y.words[C - 10] = (W & _) << 4 | P >>> 22,
                P = W
            }
            P >>>= 22,
            y.words[C - 10] = P,
            P === 0 && y.length > 10 ? y.length -= 10 : y.length -= 9
        }
        ,
        $.prototype.imulK = function(y) {
            y.words[y.length] = 0,
            y.words[y.length + 1] = 0,
            y.length += 2;
            for (var b = 0, _ = 0; _ < y.length; _++) {
                var T = y.words[_] | 0;
                b += T * 977,
                y.words[_] = b & 67108863,
                b = T * 64 + (b / 67108864 | 0)
            }
            return y.words[y.length - 1] === 0 && (y.length--,
            y.words[y.length - 1] === 0 && y.length--),
            y
        }
        ;
        function D() {
            O.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(D, O);
        function K() {
            O.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(K, O);
        function G() {
            O.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(G, O),
        G.prototype.imulK = function(y) {
            for (var b = 0, _ = 0; _ < y.length; _++) {
                var T = (y.words[_] | 0) * 19 + b
                  , C = T & 67108863;
                T >>>= 26,
                y.words[_] = C,
                b = T
            }
            return b !== 0 && (y.words[y.length++] = b),
            y
        }
        ,
        s._prime = function(y) {
            if (L[y])
                return L[y];
            var b;
            if (y === "k256")
                b = new $;
            else if (y === "p224")
                b = new D;
            else if (y === "p192")
                b = new K;
            else if (y === "p25519")
                b = new G;
            else
                throw new Error("Unknown prime " + y);
            return L[y] = b,
            b
        }
        ;
        function F(B) {
            if (typeof B == "string") {
                var y = s._prime(B);
                this.m = y.p,
                this.prime = y
            } else
                n(B.gtn(1), "modulus must be greater than 1"),
                this.m = B,
                this.prime = null
        }
        F.prototype._verify1 = function(y) {
            n(y.negative === 0, "red works only with positives"),
            n(y.red, "red works only with red numbers")
        }
        ,
        F.prototype._verify2 = function(y, b) {
            n((y.negative | b.negative) === 0, "red works only with positives"),
            n(y.red && y.red === b.red, "red works only with red numbers")
        }
        ,
        F.prototype.imod = function(y) {
            return this.prime ? this.prime.ireduce(y)._forceRed(this) : (l(y, y.umod(this.m)._forceRed(this)),
            y)
        }
        ,
        F.prototype.neg = function(y) {
            return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this)
        }
        ,
        F.prototype.add = function(y, b) {
            this._verify2(y, b);
            var _ = y.add(b);
            return _.cmp(this.m) >= 0 && _.isub(this.m),
            _._forceRed(this)
        }
        ,
        F.prototype.iadd = function(y, b) {
            this._verify2(y, b);
            var _ = y.iadd(b);
            return _.cmp(this.m) >= 0 && _.isub(this.m),
            _
        }
        ,
        F.prototype.sub = function(y, b) {
            this._verify2(y, b);
            var _ = y.sub(b);
            return _.cmpn(0) < 0 && _.iadd(this.m),
            _._forceRed(this)
        }
        ,
        F.prototype.isub = function(y, b) {
            this._verify2(y, b);
            var _ = y.isub(b);
            return _.cmpn(0) < 0 && _.iadd(this.m),
            _
        }
        ,
        F.prototype.shl = function(y, b) {
            return this._verify1(y),
            this.imod(y.ushln(b))
        }
        ,
        F.prototype.imul = function(y, b) {
            return this._verify2(y, b),
            this.imod(y.imul(b))
        }
        ,
        F.prototype.mul = function(y, b) {
            return this._verify2(y, b),
            this.imod(y.mul(b))
        }
        ,
        F.prototype.isqr = function(y) {
            return this.imul(y, y.clone())
        }
        ,
        F.prototype.sqr = function(y) {
            return this.mul(y, y)
        }
        ,
        F.prototype.sqrt = function(y) {
            if (y.isZero())
                return y.clone();
            var b = this.m.andln(3);
            if (n(b % 2 === 1),
            b === 3) {
                var _ = this.m.add(new s(1)).iushrn(2);
                return this.pow(y, _)
            }
            for (var T = this.m.subn(1), C = 0; !T.isZero() && T.andln(1) === 0; )
                C++,
                T.iushrn(1);
            n(!T.isZero());
            var P = new s(1).toRed(this)
              , W = P.redNeg()
              , N = this.m.subn(1).iushrn(1)
              , w = this.m.bitLength();
            for (w = new s(2 * w * w).toRed(this); this.pow(w, N).cmp(W) !== 0; )
                w.redIAdd(W);
            for (var U = this.pow(w, T), re = this.pow(y, T.addn(1).iushrn(1)), ie = this.pow(y, T), ue = C; ie.cmp(P) !== 0; ) {
                for (var Q = ie, ee = 0; Q.cmp(P) !== 0; ee++)
                    Q = Q.redSqr();
                n(ee < ue);
                var te = this.pow(U, new s(1).iushln(ue - ee - 1));
                re = re.redMul(te),
                U = te.redSqr(),
                ie = ie.redMul(U),
                ue = ee
            }
            return re
        }
        ,
        F.prototype.invm = function(y) {
            var b = y._invmp(this.m);
            return b.negative !== 0 ? (b.negative = 0,
            this.imod(b).redNeg()) : this.imod(b)
        }
        ,
        F.prototype.pow = function(y, b) {
            if (b.isZero())
                return new s(1).toRed(this);
            if (b.cmpn(1) === 0)
                return y.clone();
            var _ = 4
              , T = new Array(1 << _);
            T[0] = new s(1).toRed(this),
            T[1] = y;
            for (var C = 2; C < T.length; C++)
                T[C] = this.mul(T[C - 1], y);
            var P = T[0]
              , W = 0
              , N = 0
              , w = b.bitLength() % 26;
            for (w === 0 && (w = 26),
            C = b.length - 1; C >= 0; C--) {
                for (var U = b.words[C], re = w - 1; re >= 0; re--) {
                    var ie = U >> re & 1;
                    if (P !== T[0] && (P = this.sqr(P)),
                    ie === 0 && W === 0) {
                        N = 0;
                        continue
                    }
                    W <<= 1,
                    W |= ie,
                    N++,
                    !(N !== _ && (C !== 0 || re !== 0)) && (P = this.mul(P, T[W]),
                    N = 0,
                    W = 0)
                }
                w = 26
            }
            return P
        }
        ,
        F.prototype.convertTo = function(y) {
            var b = y.umod(this.m);
            return b === y ? b.clone() : b
        }
        ,
        F.prototype.convertFrom = function(y) {
            var b = y.clone();
            return b.red = null,
            b
        }
        ,
        s.mont = function(y) {
            return new q(y)
        }
        ;
        function q(B) {
            F.call(this, B),
            this.shift = this.m.bitLength(),
            this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
            this.r = new s(1).iushln(this.shift),
            this.r2 = this.imod(this.r.sqr()),
            this.rinv = this.r._invmp(this.m),
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
            this.minv = this.minv.umod(this.r),
            this.minv = this.r.sub(this.minv)
        }
        i(q, F),
        q.prototype.convertTo = function(y) {
            return this.imod(y.ushln(this.shift))
        }
        ,
        q.prototype.convertFrom = function(y) {
            var b = this.imod(y.mul(this.rinv));
            return b.red = null,
            b
        }
        ,
        q.prototype.imul = function(y, b) {
            if (y.isZero() || b.isZero())
                return y.words[0] = 0,
                y.length = 1,
                y;
            var _ = y.imul(b)
              , T = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , C = _.isub(T).iushrn(this.shift)
              , P = C;
            return C.cmp(this.m) >= 0 ? P = C.isub(this.m) : C.cmpn(0) < 0 && (P = C.iadd(this.m)),
            P._forceRed(this)
        }
        ,
        q.prototype.mul = function(y, b) {
            if (y.isZero() || b.isZero())
                return new s(0)._forceRed(this);
            var _ = y.mul(b)
              , T = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , C = _.isub(T).iushrn(this.shift)
              , P = C;
            return C.cmp(this.m) >= 0 ? P = C.isub(this.m) : C.cmpn(0) < 0 && (P = C.iadd(this.m)),
            P._forceRed(this)
        }
        ,
        q.prototype.invm = function(y) {
            var b = this.imod(y._invmp(this.m).mul(this.r2));
            return b._forceRed(this)
        }
    }
    )(e, ke)
}
)(am);
var $3 = am.exports;
const pb = ic($3);
var ap = {
    exports: {}
};
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
    var r = $e
      , n = r.Buffer;
    function i(o, a) {
        for (var u in o)
            a[u] = o[u]
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i(r, t),
    t.Buffer = s);
    function s(o, a, u) {
        return n(o, a, u)
    }
    s.prototype = Object.create(n.prototype),
    i(n, s),
    s.from = function(o, a, u) {
        if (typeof o == "number")
            throw new TypeError("Argument must not be a number");
        return n(o, a, u)
    }
    ,
    s.alloc = function(o, a, u) {
        if (typeof o != "number")
            throw new TypeError("Argument must be a number");
        var c = n(o);
        return a !== void 0 ? typeof u == "string" ? c.fill(a, u) : c.fill(a) : c.fill(0),
        c
    }
    ,
    s.allocUnsafe = function(o) {
        if (typeof o != "number")
            throw new TypeError("Argument must be a number");
        return n(o)
    }
    ,
    s.allocUnsafeSlow = function(o) {
        if (typeof o != "number")
            throw new TypeError("Argument must be a number");
        return r.SlowBuffer(o)
    }
}
)(ap, ap.exports);
var rR = ap.exports
  , Qc = rR.Buffer;
function nR(e) {
    if (e.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
        t[r] = 255;
    for (var n = 0; n < e.length; n++) {
        var i = e.charAt(n)
          , s = i.charCodeAt(0);
        if (t[s] !== 255)
            throw new TypeError(i + " is ambiguous");
        t[s] = n
    }
    var o = e.length
      , a = e.charAt(0)
      , u = Math.log(o) / Math.log(256)
      , c = Math.log(256) / Math.log(o);
    function l(g) {
        if ((Array.isArray(g) || g instanceof Uint8Array) && (g = Qc.from(g)),
        !Qc.isBuffer(g))
            throw new TypeError("Expected Buffer");
        if (g.length === 0)
            return "";
        for (var S = 0, x = 0, v = 0, I = g.length; v !== I && g[v] === 0; )
            v++,
            S++;
        for (var M = (I - v) * c + 1 >>> 0, A = new Uint8Array(M); v !== I; ) {
            for (var k = g[v], L = 0, O = M - 1; (k !== 0 || L < x) && O !== -1; O--,
            L++)
                k += 256 * A[O] >>> 0,
                A[O] = k % o >>> 0,
                k = k / o >>> 0;
            if (k !== 0)
                throw new Error("Non-zero carry");
            x = L,
            v++
        }
        for (var $ = M - x; $ !== M && A[$] === 0; )
            $++;
        for (var D = a.repeat(S); $ < M; ++$)
            D += e.charAt(A[$]);
        return D
    }
    function p(g) {
        if (typeof g != "string")
            throw new TypeError("Expected String");
        if (g.length === 0)
            return Qc.alloc(0);
        for (var S = 0, x = 0, v = 0; g[S] === a; )
            x++,
            S++;
        for (var I = (g.length - S) * u + 1 >>> 0, M = new Uint8Array(I); g[S]; ) {
            var A = t[g.charCodeAt(S)];
            if (A === 255)
                return;
            for (var k = 0, L = I - 1; (A !== 0 || k < v) && L !== -1; L--,
            k++)
                A += o * M[L] >>> 0,
                M[L] = A % 256 >>> 0,
                A = A / 256 >>> 0;
            if (A !== 0)
                throw new Error("Non-zero carry");
            v = k,
            S++
        }
        for (var O = I - v; O !== I && M[O] === 0; )
            O++;
        var $ = Qc.allocUnsafe(x + (I - O));
        $.fill(0, 0, x);
        for (var D = x; O !== I; )
            $[D++] = M[O++];
        return $
    }
    function h(g) {
        var S = p(g);
        if (S)
            return S;
        throw new Error("Non-base" + o + " character")
    }
    return {
        encode: l,
        decodeUnsafe: p,
        decode: h
    }
}
var iR = nR
  , sR = iR
  , oR = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  , F3 = sR(oR);
const Ar = ic(F3)
  , aR = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
  , Li = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
  , Oi = new Uint32Array(64);
class uR extends C3 {
    constructor() {
        super(64, 32, 8, !1),
        this.A = Li[0] | 0,
        this.B = Li[1] | 0,
        this.C = Li[2] | 0,
        this.D = Li[3] | 0,
        this.E = Li[4] | 0,
        this.F = Li[5] | 0,
        this.G = Li[6] | 0,
        this.H = Li[7] | 0
    }
    get() {
        const {A: t, B: r, C: n, D: i, E: s, F: o, G: a, H: u} = this;
        return [t, r, n, i, s, o, a, u]
    }
    set(t, r, n, i, s, o, a, u) {
        this.A = t | 0,
        this.B = r | 0,
        this.C = n | 0,
        this.D = i | 0,
        this.E = s | 0,
        this.F = o | 0,
        this.G = a | 0,
        this.H = u | 0
    }
    process(t, r) {
        for (let p = 0; p < 16; p++,
        r += 4)
            Oi[p] = t.getUint32(r, !1);
        for (let p = 16; p < 64; p++) {
            const h = Oi[p - 15]
              , g = Oi[p - 2]
              , S = kn(h, 7) ^ kn(h, 18) ^ h >>> 3
              , x = kn(g, 17) ^ kn(g, 19) ^ g >>> 10;
            Oi[p] = x + Oi[p - 7] + S + Oi[p - 16] | 0
        }
        let {A: n, B: i, C: s, D: o, E: a, F: u, G: c, H: l} = this;
        for (let p = 0; p < 64; p++) {
            const h = kn(a, 6) ^ kn(a, 11) ^ kn(a, 25)
              , g = l + h + Z9(a, u, c) + aR[p] + Oi[p] | 0
              , x = (kn(n, 2) ^ kn(n, 13) ^ kn(n, 22)) + J9(n, i, s) | 0;
            l = c,
            c = u,
            u = a,
            a = o + g | 0,
            o = s,
            s = i,
            i = n,
            n = g + x | 0
        }
        n = n + this.A | 0,
        i = i + this.B | 0,
        s = s + this.C | 0,
        o = o + this.D | 0,
        a = a + this.E | 0,
        u = u + this.F | 0,
        c = c + this.G | 0,
        l = l + this.H | 0,
        this.set(n, i, s, o, a, u, c, l)
    }
    roundClean() {
        Oi.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0),
        this.buffer.fill(0)
    }
}
const up = I3( () => new uR);
var ur = {};
function ai(e, t, r) {
    return t <= e && e <= r
}
function ud(e) {
    if (e === void 0)
        return {};
    if (e === Object(e))
        return e;
    throw TypeError("Could not convert argument to dictionary")
}
function cR(e) {
    for (var t = String(e), r = t.length, n = 0, i = []; n < r; ) {
        var s = t.charCodeAt(n);
        if (s < 55296 || s > 57343)
            i.push(s);
        else if (56320 <= s && s <= 57343)
            i.push(65533);
        else if (55296 <= s && s <= 56319)
            if (n === r - 1)
                i.push(65533);
            else {
                var o = e.charCodeAt(n + 1);
                if (56320 <= o && o <= 57343) {
                    var a = s & 1023
                      , u = o & 1023;
                    i.push(65536 + (a << 10) + u),
                    n += 1
                } else
                    i.push(65533)
            }
        n += 1
    }
    return i
}
function lR(e) {
    for (var t = "", r = 0; r < e.length; ++r) {
        var n = e[r];
        n <= 65535 ? t += String.fromCharCode(n) : (n -= 65536,
        t += String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320))
    }
    return t
}
var af = -1;
function um(e) {
    this.tokens = [].slice.call(e)
}
um.prototype = {
    endOfStream: function() {
        return !this.tokens.length
    },
    read: function() {
        return this.tokens.length ? this.tokens.shift() : af
    },
    prepend: function(e) {
        if (Array.isArray(e))
            for (var t = e; t.length; )
                this.tokens.unshift(t.pop());
        else
            this.tokens.unshift(e)
    },
    push: function(e) {
        if (Array.isArray(e))
            for (var t = e; t.length; )
                this.tokens.push(t.shift());
        else
            this.tokens.push(e)
    }
};
var Jo = -1;
function M0(e, t) {
    if (e)
        throw TypeError("Decoder error");
    return t || 65533
}
var uf = "utf-8";
function cf(e, t) {
    if (!(this instanceof cf))
        return new cf(e,t);
    if (e = e !== void 0 ? String(e).toLowerCase() : uf,
    e !== uf)
        throw new Error("Encoding not supported. Only utf-8 is supported");
    t = ud(t),
    this._streaming = !1,
    this._BOMseen = !1,
    this._decoder = null,
    this._fatal = !!t.fatal,
    this._ignoreBOM = !!t.ignoreBOM,
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    }),
    Object.defineProperty(this, "fatal", {
        value: this._fatal
    }),
    Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    })
}
cf.prototype = {
    decode: function(t, r) {
        var n;
        typeof t == "object" && t instanceof ArrayBuffer ? n = new Uint8Array(t) : typeof t == "object" && "buffer"in t && t.buffer instanceof ArrayBuffer ? n = new Uint8Array(t.buffer,t.byteOffset,t.byteLength) : n = new Uint8Array(0),
        r = ud(r),
        this._streaming || (this._decoder = new fR({
            fatal: this._fatal
        }),
        this._BOMseen = !1),
        this._streaming = !!r.stream;
        for (var i = new um(n), s = [], o; !i.endOfStream() && (o = this._decoder.handler(i, i.read()),
        o !== Jo); )
            o !== null && (Array.isArray(o) ? s.push.apply(s, o) : s.push(o));
        if (!this._streaming) {
            do {
                if (o = this._decoder.handler(i, i.read()),
                o === Jo)
                    break;
                o !== null && (Array.isArray(o) ? s.push.apply(s, o) : s.push(o))
            } while (!i.endOfStream());
            this._decoder = null
        }
        return s.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (s[0] === 65279 ? (this._BOMseen = !0,
        s.shift()) : this._BOMseen = !0),
        lR(s)
    }
};
function lf(e, t) {
    if (!(this instanceof lf))
        return new lf(e,t);
    if (e = e !== void 0 ? String(e).toLowerCase() : uf,
    e !== uf)
        throw new Error("Encoding not supported. Only utf-8 is supported");
    t = ud(t),
    this._streaming = !1,
    this._encoder = null,
    this._options = {
        fatal: !!t.fatal
    },
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    })
}
lf.prototype = {
    encode: function(t, r) {
        t = t ? String(t) : "",
        r = ud(r),
        this._streaming || (this._encoder = new dR(this._options)),
        this._streaming = !!r.stream;
        for (var n = [], i = new um(cR(t)), s; !i.endOfStream() && (s = this._encoder.handler(i, i.read()),
        s !== Jo); )
            Array.isArray(s) ? n.push.apply(n, s) : n.push(s);
        if (!this._streaming) {
            for (; s = this._encoder.handler(i, i.read()),
            s !== Jo; )
                Array.isArray(s) ? n.push.apply(n, s) : n.push(s);
            this._encoder = null
        }
        return new Uint8Array(n)
    }
};
function fR(e) {
    var t = e.fatal
      , r = 0
      , n = 0
      , i = 0
      , s = 128
      , o = 191;
    this.handler = function(a, u) {
        if (u === af && i !== 0)
            return i = 0,
            M0(t);
        if (u === af)
            return Jo;
        if (i === 0) {
            if (ai(u, 0, 127))
                return u;
            if (ai(u, 194, 223))
                i = 1,
                r = u - 192;
            else if (ai(u, 224, 239))
                u === 224 && (s = 160),
                u === 237 && (o = 159),
                i = 2,
                r = u - 224;
            else if (ai(u, 240, 244))
                u === 240 && (s = 144),
                u === 244 && (o = 143),
                i = 3,
                r = u - 240;
            else
                return M0(t);
            return r = r << 6 * i,
            null
        }
        if (!ai(u, s, o))
            return r = i = n = 0,
            s = 128,
            o = 191,
            a.prepend(u),
            M0(t);
        if (s = 128,
        o = 191,
        n += 1,
        r += u - 128 << 6 * (i - n),
        n !== i)
            return null;
        var c = r;
        return r = i = n = 0,
        c
    }
}
function dR(e) {
    e.fatal,
    this.handler = function(t, r) {
        if (r === af)
            return Jo;
        if (ai(r, 0, 127))
            return r;
        var n, i;
        ai(r, 128, 2047) ? (n = 1,
        i = 192) : ai(r, 2048, 65535) ? (n = 2,
        i = 224) : ai(r, 65536, 1114111) && (n = 3,
        i = 240);
        for (var s = [(r >> 6 * n) + i]; n > 0; ) {
            var o = r >> 6 * (n - 1);
            s.push(128 | o & 63),
            n -= 1
        }
        return s
    }
}
const hR = Object.freeze(Object.defineProperty({
    __proto__: null,
    TextDecoder: cf,
    TextEncoder: lf
}, Symbol.toStringTag, {
    value: "Module"
}))
  , pR = kg(hR);
var gR = ke && ke.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r),
    Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
            return t[r]
        }
    })
}
: function(e, t, r, n) {
    n === void 0 && (n = r),
    e[n] = t[r]
}
)
  , mR = ke && ke.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    })
}
: function(e, t) {
    e.default = t
}
)
  , Qn = ke && ke.__decorate || function(e, t, r, n) {
    var i = arguments.length, s = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        s = Reflect.decorate(e, t, r, n);
    else
        for (var a = e.length - 1; a >= 0; a--)
            (o = e[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, r, s) : o(t, r)) || s);
    return i > 3 && s && Object.defineProperty(t, r, s),
    s
}
  , yR = ke && ke.__importStar || function(e) {
    if (e && e.__esModule)
        return e;
    var t = {};
    if (e != null)
        for (var r in e)
            r !== "default" && Object.hasOwnProperty.call(e, r) && gR(t, e, r);
    return mR(t, e),
    t
}
  , H3 = ke && ke.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
;
Object.defineProperty(ur, "__esModule", {
    value: !0
});
var q3 = ur.deserializeUnchecked = Y3 = ur.deserialize = Q3 = ur.serialize = ur.BinaryReader = ur.BinaryWriter = ur.BorshError = ur.baseDecode = ur.baseEncode = void 0;
const Ki = H3($3)
  , W3 = H3(F3)
  , bR = yR(pR)
  , wR = typeof TextDecoder != "function" ? bR.TextDecoder : TextDecoder
  , vR = new wR("utf-8",{
    fatal: !0
});
function xR(e) {
    return typeof e == "string" && (e = Buffer.from(e, "utf8")),
    W3.default.encode(Buffer.from(e))
}
ur.baseEncode = xR;
function ER(e) {
    return Buffer.from(W3.default.decode(e))
}
ur.baseDecode = ER;
const I0 = 1024;
class Ir extends Error {
    constructor(t) {
        super(t),
        this.fieldPath = [],
        this.originalMessage = t
    }
    addToFieldPath(t) {
        this.fieldPath.splice(0, 0, t),
        this.message = this.originalMessage + ": " + this.fieldPath.join(".")
    }
}
ur.BorshError = Ir;
class V3 {
    constructor() {
        this.buf = Buffer.alloc(I0),
        this.length = 0
    }
    maybeResize() {
        this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(I0)]))
    }
    writeU8(t) {
        this.maybeResize(),
        this.buf.writeUInt8(t, this.length),
        this.length += 1
    }
    writeU16(t) {
        this.maybeResize(),
        this.buf.writeUInt16LE(t, this.length),
        this.length += 2
    }
    writeU32(t) {
        this.maybeResize(),
        this.buf.writeUInt32LE(t, this.length),
        this.length += 4
    }
    writeU64(t) {
        this.maybeResize(),
        this.writeBuffer(Buffer.from(new Ki.default(t).toArray("le", 8)))
    }
    writeU128(t) {
        this.maybeResize(),
        this.writeBuffer(Buffer.from(new Ki.default(t).toArray("le", 16)))
    }
    writeU256(t) {
        this.maybeResize(),
        this.writeBuffer(Buffer.from(new Ki.default(t).toArray("le", 32)))
    }
    writeU512(t) {
        this.maybeResize(),
        this.writeBuffer(Buffer.from(new Ki.default(t).toArray("le", 64)))
    }
    writeBuffer(t) {
        this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), t, Buffer.alloc(I0)]),
        this.length += t.length
    }
    writeString(t) {
        this.maybeResize();
        const r = Buffer.from(t, "utf8");
        this.writeU32(r.length),
        this.writeBuffer(r)
    }
    writeFixedArray(t) {
        this.writeBuffer(Buffer.from(t))
    }
    writeArray(t, r) {
        this.maybeResize(),
        this.writeU32(t.length);
        for (const n of t)
            this.maybeResize(),
            r(n)
    }
    toArray() {
        return this.buf.subarray(0, this.length)
    }
}
ur.BinaryWriter = V3;
function Yn(e, t, r) {
    const n = r.value;
    r.value = function(...i) {
        try {
            return n.apply(this, i)
        } catch (s) {
            if (s instanceof RangeError) {
                const o = s.code;
                if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(o) >= 0)
                    throw new Ir("Reached the end of buffer when deserializing")
            }
            throw s
        }
    }
}
class Xr {
    constructor(t) {
        this.buf = t,
        this.offset = 0
    }
    readU8() {
        const t = this.buf.readUInt8(this.offset);
        return this.offset += 1,
        t
    }
    readU16() {
        const t = this.buf.readUInt16LE(this.offset);
        return this.offset += 2,
        t
    }
    readU32() {
        const t = this.buf.readUInt32LE(this.offset);
        return this.offset += 4,
        t
    }
    readU64() {
        const t = this.readBuffer(8);
        return new Ki.default(t,"le")
    }
    readU128() {
        const t = this.readBuffer(16);
        return new Ki.default(t,"le")
    }
    readU256() {
        const t = this.readBuffer(32);
        return new Ki.default(t,"le")
    }
    readU512() {
        const t = this.readBuffer(64);
        return new Ki.default(t,"le")
    }
    readBuffer(t) {
        if (this.offset + t > this.buf.length)
            throw new Ir(`Expected buffer length ${t} isn't within bounds`);
        const r = this.buf.slice(this.offset, this.offset + t);
        return this.offset += t,
        r
    }
    readString() {
        const t = this.readU32()
          , r = this.readBuffer(t);
        try {
            return vR.decode(r)
        } catch (n) {
            throw new Ir(`Error decoding UTF-8 string: ${n}`)
        }
    }
    readFixedArray(t) {
        return new Uint8Array(this.readBuffer(t))
    }
    readArray(t) {
        const r = this.readU32()
          , n = Array();
        for (let i = 0; i < r; ++i)
            n.push(t());
        return n
    }
}
Qn([Yn], Xr.prototype, "readU8", null);
Qn([Yn], Xr.prototype, "readU16", null);
Qn([Yn], Xr.prototype, "readU32", null);
Qn([Yn], Xr.prototype, "readU64", null);
Qn([Yn], Xr.prototype, "readU128", null);
Qn([Yn], Xr.prototype, "readU256", null);
Qn([Yn], Xr.prototype, "readU512", null);
Qn([Yn], Xr.prototype, "readString", null);
Qn([Yn], Xr.prototype, "readFixedArray", null);
Qn([Yn], Xr.prototype, "readArray", null);
ur.BinaryReader = Xr;
function K3(e) {
    return e.charAt(0).toUpperCase() + e.slice(1)
}
function vs(e, t, r, n, i) {
    try {
        if (typeof n == "string")
            i[`write${K3(n)}`](r);
        else if (n instanceof Array)
            if (typeof n[0] == "number") {
                if (r.length !== n[0])
                    throw new Ir(`Expecting byte array of length ${n[0]}, but got ${r.length} bytes`);
                i.writeFixedArray(r)
            } else if (n.length === 2 && typeof n[1] == "number") {
                if (r.length !== n[1])
                    throw new Ir(`Expecting byte array of length ${n[1]}, but got ${r.length} bytes`);
                for (let s = 0; s < n[1]; s++)
                    vs(e, null, r[s], n[0], i)
            } else
                i.writeArray(r, s => {
                    vs(e, t, s, n[0], i)
                }
                );
        else if (n.kind !== void 0)
            switch (n.kind) {
            case "option":
                {
                    r == null ? i.writeU8(0) : (i.writeU8(1),
                    vs(e, t, r, n.type, i));
                    break
                }
            case "map":
                {
                    i.writeU32(r.size),
                    r.forEach( (s, o) => {
                        vs(e, t, o, n.key, i),
                        vs(e, t, s, n.value, i)
                    }
                    );
                    break
                }
            default:
                throw new Ir(`FieldType ${n} unrecognized`)
            }
        else
            G3(e, r, i)
    } catch (s) {
        throw s instanceof Ir && s.addToFieldPath(t),
        s
    }
}
function G3(e, t, r) {
    if (typeof t.borshSerialize == "function") {
        t.borshSerialize(r);
        return
    }
    const n = e.get(t.constructor);
    if (!n)
        throw new Ir(`Class ${t.constructor.name} is missing in schema`);
    if (n.kind === "struct")
        n.fields.map( ([i,s]) => {
            vs(e, i, t[i], s, r)
        }
        );
    else if (n.kind === "enum") {
        const i = t[n.field];
        for (let s = 0; s < n.values.length; ++s) {
            const [o,a] = n.values[s];
            if (o === i) {
                r.writeU8(s),
                vs(e, o, t[o], a, r);
                break
            }
        }
    } else
        throw new Ir(`Unexpected schema kind: ${n.kind} for ${t.constructor.name}`)
}
function SR(e, t, r=V3) {
    const n = new r;
    return G3(e, t, n),
    n.toArray()
}
var Q3 = ur.serialize = SR;
function xs(e, t, r, n) {
    try {
        if (typeof r == "string")
            return n[`read${K3(r)}`]();
        if (r instanceof Array) {
            if (typeof r[0] == "number")
                return n.readFixedArray(r[0]);
            if (typeof r[1] == "number") {
                const i = [];
                for (let s = 0; s < r[1]; s++)
                    i.push(xs(e, null, r[0], n));
                return i
            } else
                return n.readArray( () => xs(e, t, r[0], n))
        }
        if (r.kind === "option")
            return n.readU8() ? xs(e, t, r.type, n) : void 0;
        if (r.kind === "map") {
            let i = new Map;
            const s = n.readU32();
            for (let o = 0; o < s; o++) {
                const a = xs(e, t, r.key, n)
                  , u = xs(e, t, r.value, n);
                i.set(a, u)
            }
            return i
        }
        return cm(e, r, n)
    } catch (i) {
        throw i instanceof Ir && i.addToFieldPath(t),
        i
    }
}
function cm(e, t, r) {
    if (typeof t.borshDeserialize == "function")
        return t.borshDeserialize(r);
    const n = e.get(t);
    if (!n)
        throw new Ir(`Class ${t.name} is missing in schema`);
    if (n.kind === "struct") {
        const i = {};
        for (const [s,o] of e.get(t).fields)
            i[s] = xs(e, s, o, r);
        return new t(i)
    }
    if (n.kind === "enum") {
        const i = r.readU8();
        if (i >= n.values.length)
            throw new Ir(`Enum index: ${i} is out of range`);
        const [s,o] = n.values[i]
          , a = xs(e, s, o, r);
        return new t({
            [s]: a
        })
    }
    throw new Ir(`Unexpected schema kind: ${n.kind} for ${t.constructor.name}`)
}
function _R(e, t, r, n=Xr) {
    const i = new n(r)
      , s = cm(e, t, i);
    if (i.offset < r.length)
        throw new Ir(`Unexpected ${r.length - i.offset} bytes after deserialized data`);
    return s
}
var Y3 = ur.deserialize = _R;
function AR(e, t, r, n=Xr) {
    const i = new n(r);
    return cm(e, t, i)
}
q3 = ur.deserializeUnchecked = AR;
var J = {};
Object.defineProperty(J, "__esModule", {
    value: !0
});
J.s16 = J.s8 = J.nu64be = J.u48be = J.u40be = J.u32be = J.u24be = J.u16be = sr = J.nu64 = J.u48 = J.u40 = Le = J.u32 = J.u24 = on = J.u16 = Je = J.u8 = Us = J.offset = J.greedy = J.Constant = J.UTF8 = J.CString = J.Blob = J.Boolean = J.BitField = J.BitStructure = J.VariantLayout = J.Union = J.UnionLayoutDiscriminator = J.UnionDiscriminator = J.Structure = J.Sequence = J.DoubleBE = J.Double = J.FloatBE = J.Float = J.NearInt64BE = J.NearInt64 = J.NearUInt64BE = J.NearUInt64 = J.IntBE = J.Int = J.UIntBE = J.UInt = J.OffsetLayout = J.GreedyCount = J.ExternalLayout = J.bindConstructorLayout = J.nameWithProperty = J.Layout = J.uint8ArrayToBuffer = J.checkUint8Array = void 0;
J.constant = J.utf8 = J.cstr = gt = J.blob = J.unionLayoutDiscriminator = J.union = Tr = J.seq = J.bits = Te = J.struct = J.f64be = J.f64 = J.f32be = J.f32 = J.ns64be = J.s48be = J.s40be = J.s32be = J.s24be = J.s16be = Vr = J.ns64 = J.s48 = J.s40 = J.s32 = J.s24 = void 0;
const lm = $e;
function ma(e) {
    if (!(e instanceof Uint8Array))
        throw new TypeError("b must be a Uint8Array")
}
J.checkUint8Array = ma;
function Ze(e) {
    return ma(e),
    lm.Buffer.from(e.buffer, e.byteOffset, e.length)
}
J.uint8ArrayToBuffer = Ze;
class it {
    constructor(t, r) {
        if (!Number.isInteger(t))
            throw new TypeError("span must be an integer");
        this.span = t,
        this.property = r
    }
    makeDestinationObject() {
        return {}
    }
    getSpan(t, r) {
        if (0 > this.span)
            throw new RangeError("indeterminate span");
        return this.span
    }
    replicate(t) {
        const r = Object.create(this.constructor.prototype);
        return Object.assign(r, this),
        r.property = t,
        r
    }
    fromArray(t) {}
}
J.Layout = it;
function fm(e, t) {
    return t.property ? e + "[" + t.property + "]" : e
}
J.nameWithProperty = fm;
function MR(e, t) {
    if (typeof e != "function")
        throw new TypeError("Class must be constructor");
    if (Object.prototype.hasOwnProperty.call(e, "layout_"))
        throw new Error("Class is already bound to a layout");
    if (!(t && t instanceof it))
        throw new TypeError("layout must be a Layout");
    if (Object.prototype.hasOwnProperty.call(t, "boundConstructor_"))
        throw new Error("layout is already bound to a constructor");
    e.layout_ = t,
    t.boundConstructor_ = e,
    t.makeDestinationObject = () => new e,
    Object.defineProperty(e.prototype, "encode", {
        value(r, n) {
            return t.encode(this, r, n)
        },
        writable: !0
    }),
    Object.defineProperty(e, "decode", {
        value(r, n) {
            return t.decode(r, n)
        },
        writable: !0
    })
}
J.bindConstructorLayout = MR;
class Nr extends it {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
}
J.ExternalLayout = Nr;
class Z3 extends Nr {
    constructor(t=1, r) {
        if (!Number.isInteger(t) || 0 >= t)
            throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, r),
        this.elementSpan = t
    }
    isCount() {
        return !0
    }
    decode(t, r=0) {
        ma(t);
        const n = t.length - r;
        return Math.floor(n / this.elementSpan)
    }
    encode(t, r, n) {
        return 0
    }
}
J.GreedyCount = Z3;
class dm extends Nr {
    constructor(t, r=0, n) {
        if (!(t instanceof it))
            throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(r))
            throw new TypeError("offset must be integer or undefined");
        super(t.span, n || t.property),
        this.layout = t,
        this.offset = r
    }
    isCount() {
        return this.layout instanceof hn || this.layout instanceof An
    }
    decode(t, r=0) {
        return this.layout.decode(t, r + this.offset)
    }
    encode(t, r, n=0) {
        return this.layout.encode(t, r, n + this.offset)
    }
}
J.OffsetLayout = dm;
class hn extends it {
    constructor(t, r) {
        if (super(t, r),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(t, r=0) {
        return Ze(t).readUIntLE(r, this.span)
    }
    encode(t, r, n=0) {
        return Ze(r).writeUIntLE(t, n, this.span),
        this.span
    }
}
J.UInt = hn;
class An extends it {
    constructor(t, r) {
        if (super(t, r),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(t, r=0) {
        return Ze(t).readUIntBE(r, this.span)
    }
    encode(t, r, n=0) {
        return Ze(r).writeUIntBE(t, n, this.span),
        this.span
    }
}
J.UIntBE = An;
class to extends it {
    constructor(t, r) {
        if (super(t, r),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(t, r=0) {
        return Ze(t).readIntLE(r, this.span)
    }
    encode(t, r, n=0) {
        return Ze(r).writeIntLE(t, n, this.span),
        this.span
    }
}
J.Int = to;
class ya extends it {
    constructor(t, r) {
        if (super(t, r),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(t, r=0) {
        return Ze(t).readIntBE(r, this.span)
    }
    encode(t, r, n=0) {
        return Ze(r).writeIntBE(t, n, this.span),
        this.span
    }
}
J.IntBE = ya;
const cp = Math.pow(2, 32);
function cd(e) {
    const t = Math.floor(e / cp)
      , r = e - t * cp;
    return {
        hi32: t,
        lo32: r
    }
}
function ld(e, t) {
    return e * cp + t
}
class J3 extends it {
    constructor(t) {
        super(8, t)
    }
    decode(t, r=0) {
        const n = Ze(t)
          , i = n.readUInt32LE(r)
          , s = n.readUInt32LE(r + 4);
        return ld(s, i)
    }
    encode(t, r, n=0) {
        const i = cd(t)
          , s = Ze(r);
        return s.writeUInt32LE(i.lo32, n),
        s.writeUInt32LE(i.hi32, n + 4),
        8
    }
}
J.NearUInt64 = J3;
class X3 extends it {
    constructor(t) {
        super(8, t)
    }
    decode(t, r=0) {
        const n = Ze(t)
          , i = n.readUInt32BE(r)
          , s = n.readUInt32BE(r + 4);
        return ld(i, s)
    }
    encode(t, r, n=0) {
        const i = cd(t)
          , s = Ze(r);
        return s.writeUInt32BE(i.hi32, n),
        s.writeUInt32BE(i.lo32, n + 4),
        8
    }
}
J.NearUInt64BE = X3;
class e4 extends it {
    constructor(t) {
        super(8, t)
    }
    decode(t, r=0) {
        const n = Ze(t)
          , i = n.readUInt32LE(r)
          , s = n.readInt32LE(r + 4);
        return ld(s, i)
    }
    encode(t, r, n=0) {
        const i = cd(t)
          , s = Ze(r);
        return s.writeUInt32LE(i.lo32, n),
        s.writeInt32LE(i.hi32, n + 4),
        8
    }
}
J.NearInt64 = e4;
class t4 extends it {
    constructor(t) {
        super(8, t)
    }
    decode(t, r=0) {
        const n = Ze(t)
          , i = n.readInt32BE(r)
          , s = n.readUInt32BE(r + 4);
        return ld(i, s)
    }
    encode(t, r, n=0) {
        const i = cd(t)
          , s = Ze(r);
        return s.writeInt32BE(i.hi32, n),
        s.writeUInt32BE(i.lo32, n + 4),
        8
    }
}
J.NearInt64BE = t4;
class r4 extends it {
    constructor(t) {
        super(4, t)
    }
    decode(t, r=0) {
        return Ze(t).readFloatLE(r)
    }
    encode(t, r, n=0) {
        return Ze(r).writeFloatLE(t, n),
        4
    }
}
J.Float = r4;
class n4 extends it {
    constructor(t) {
        super(4, t)
    }
    decode(t, r=0) {
        return Ze(t).readFloatBE(r)
    }
    encode(t, r, n=0) {
        return Ze(r).writeFloatBE(t, n),
        4
    }
}
J.FloatBE = n4;
class i4 extends it {
    constructor(t) {
        super(8, t)
    }
    decode(t, r=0) {
        return Ze(t).readDoubleLE(r)
    }
    encode(t, r, n=0) {
        return Ze(r).writeDoubleLE(t, n),
        8
    }
}
J.Double = i4;
class s4 extends it {
    constructor(t) {
        super(8, t)
    }
    decode(t, r=0) {
        return Ze(t).readDoubleBE(r)
    }
    encode(t, r, n=0) {
        return Ze(r).writeDoubleBE(t, n),
        8
    }
}
J.DoubleBE = s4;
class o4 extends it {
    constructor(t, r, n) {
        if (!(t instanceof it))
            throw new TypeError("elementLayout must be a Layout");
        if (!(r instanceof Nr && r.isCount() || Number.isInteger(r) && 0 <= r))
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let i = -1;
        !(r instanceof Nr) && 0 < t.span && (i = r * t.span),
        super(i, n),
        this.elementLayout = t,
        this.count = r
    }
    getSpan(t, r=0) {
        if (0 <= this.span)
            return this.span;
        let n = 0
          , i = this.count;
        if (i instanceof Nr && (i = i.decode(t, r)),
        0 < this.elementLayout.span)
            n = i * this.elementLayout.span;
        else {
            let s = 0;
            for (; s < i; )
                n += this.elementLayout.getSpan(t, r + n),
                ++s
        }
        return n
    }
    decode(t, r=0) {
        const n = [];
        let i = 0
          , s = this.count;
        for (s instanceof Nr && (s = s.decode(t, r)); i < s; )
            n.push(this.elementLayout.decode(t, r)),
            r += this.elementLayout.getSpan(t, r),
            i += 1;
        return n
    }
    encode(t, r, n=0) {
        const i = this.elementLayout
          , s = t.reduce( (o, a) => o + i.encode(a, r, n + o), 0);
        return this.count instanceof Nr && this.count.encode(t.length, r, n),
        s
    }
}
J.Sequence = o4;
class a4 extends it {
    constructor(t, r, n) {
        if (!(Array.isArray(t) && t.reduce( (s, o) => s && o instanceof it, !0)))
            throw new TypeError("fields must be array of Layout instances");
        typeof r == "boolean" && n === void 0 && (n = r,
        r = void 0);
        for (const s of t)
            if (0 > s.span && s.property === void 0)
                throw new Error("fields cannot contain unnamed variable-length layout");
        let i = -1;
        try {
            i = t.reduce( (s, o) => s + o.getSpan(), 0)
        } catch {}
        super(i, r),
        this.fields = t,
        this.decodePrefixes = !!n
    }
    getSpan(t, r=0) {
        if (0 <= this.span)
            return this.span;
        let n = 0;
        try {
            n = this.fields.reduce( (i, s) => {
                const o = s.getSpan(t, r);
                return r += o,
                i + o
            }
            , 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return n
    }
    decode(t, r=0) {
        ma(t);
        const n = this.makeDestinationObject();
        for (const i of this.fields)
            if (i.property !== void 0 && (n[i.property] = i.decode(t, r)),
            r += i.getSpan(t, r),
            this.decodePrefixes && t.length === r)
                break;
        return n
    }
    encode(t, r, n=0) {
        const i = n;
        let s = 0
          , o = 0;
        for (const a of this.fields) {
            let u = a.span;
            if (o = 0 < u ? u : 0,
            a.property !== void 0) {
                const c = t[a.property];
                c !== void 0 && (o = a.encode(c, r, n),
                0 > u && (u = a.getSpan(r, n)))
            }
            s = n,
            n += u
        }
        return s + o - i
    }
    fromArray(t) {
        const r = this.makeDestinationObject();
        for (const n of this.fields)
            n.property !== void 0 && 0 < t.length && (r[n.property] = t.shift());
        return r
    }
    layoutFor(t) {
        if (typeof t != "string")
            throw new TypeError("property must be string");
        for (const r of this.fields)
            if (r.property === t)
                return r
    }
    offsetOf(t) {
        if (typeof t != "string")
            throw new TypeError("property must be string");
        let r = 0;
        for (const n of this.fields) {
            if (n.property === t)
                return r;
            0 > n.span ? r = -1 : 0 <= r && (r += n.span)
        }
    }
}
J.Structure = a4;
class hm {
    constructor(t) {
        this.property = t
    }
    decode(t, r) {
        throw new Error("UnionDiscriminator is abstract")
    }
    encode(t, r, n) {
        throw new Error("UnionDiscriminator is abstract")
    }
}
J.UnionDiscriminator = hm;
class ff extends hm {
    constructor(t, r) {
        if (!(t instanceof Nr && t.isCount()))
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(r || t.property || "variant"),
        this.layout = t
    }
    decode(t, r) {
        return this.layout.decode(t, r)
    }
    encode(t, r, n) {
        return this.layout.encode(t, r, n)
    }
}
J.UnionLayoutDiscriminator = ff;
class pm extends it {
    constructor(t, r, n) {
        let i;
        if (t instanceof hn || t instanceof An)
            i = new ff(new dm(t));
        else if (t instanceof Nr && t.isCount())
            i = new ff(t);
        else if (t instanceof hm)
            i = t;
        else
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (r === void 0 && (r = null),
        !(r === null || r instanceof it))
            throw new TypeError("defaultLayout must be null or a Layout");
        if (r !== null) {
            if (0 > r.span)
                throw new Error("defaultLayout must have constant span");
            r.property === void 0 && (r = r.replicate("content"))
        }
        let s = -1;
        r && (s = r.span,
        0 <= s && (t instanceof hn || t instanceof An) && (s += i.layout.span)),
        super(s, n),
        this.discriminator = i,
        this.usesPrefixDiscriminator = t instanceof hn || t instanceof An,
        this.defaultLayout = r,
        this.registry = {};
        let o = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(a) {
            return o(a)
        }
        ,
        this.configGetSourceVariant = function(a) {
            o = a.bind(this)
        }
    }
    getSpan(t, r=0) {
        if (0 <= this.span)
            return this.span;
        const n = this.getVariant(t, r);
        if (!n)
            throw new Error("unable to determine span for unrecognized variant");
        return n.getSpan(t, r)
    }
    defaultGetSourceVariant(t) {
        if (Object.prototype.hasOwnProperty.call(t, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(t, this.defaultLayout.property))
                return;
            const r = this.registry[t[this.discriminator.property]];
            if (r && (!r.layout || r.property && Object.prototype.hasOwnProperty.call(t, r.property)))
                return r
        } else
            for (const r in this.registry) {
                const n = this.registry[r];
                if (n.property && Object.prototype.hasOwnProperty.call(t, n.property))
                    return n
            }
        throw new Error("unable to infer src variant")
    }
    decode(t, r=0) {
        let n;
        const i = this.discriminator
          , s = i.decode(t, r)
          , o = this.registry[s];
        if (o === void 0) {
            const a = this.defaultLayout;
            let u = 0;
            this.usesPrefixDiscriminator && (u = i.layout.span),
            n = this.makeDestinationObject(),
            n[i.property] = s,
            n[a.property] = a.decode(t, r + u)
        } else
            n = o.decode(t, r);
        return n
    }
    encode(t, r, n=0) {
        const i = this.getSourceVariant(t);
        if (i === void 0) {
            const s = this.discriminator
              , o = this.defaultLayout;
            let a = 0;
            return this.usesPrefixDiscriminator && (a = s.layout.span),
            s.encode(t[s.property], r, n),
            a + o.encode(t[o.property], r, n + a)
        }
        return i.encode(t, r, n)
    }
    addVariant(t, r, n) {
        const i = new u4(this,t,r,n);
        return this.registry[t] = i,
        i
    }
    getVariant(t, r=0) {
        let n;
        return t instanceof Uint8Array ? n = this.discriminator.decode(t, r) : n = t,
        this.registry[n]
    }
}
J.Union = pm;
class u4 extends it {
    constructor(t, r, n, i) {
        if (!(t instanceof pm))
            throw new TypeError("union must be a Union");
        if (!Number.isInteger(r) || 0 > r)
            throw new TypeError("variant must be a (non-negative) integer");
        if (typeof n == "string" && i === void 0 && (i = n,
        n = null),
        n) {
            if (!(n instanceof it))
                throw new TypeError("layout must be a Layout");
            if (t.defaultLayout !== null && 0 <= n.span && n.span > t.defaultLayout.span)
                throw new Error("variant span exceeds span of containing union");
            if (typeof i != "string")
                throw new TypeError("variant must have a String property")
        }
        let s = t.span;
        0 > t.span && (s = n ? n.span : 0,
        0 <= s && t.usesPrefixDiscriminator && (s += t.discriminator.layout.span)),
        super(s, i),
        this.union = t,
        this.variant = r,
        this.layout = n || null
    }
    getSpan(t, r=0) {
        if (0 <= this.span)
            return this.span;
        let n = 0;
        this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span);
        let i = 0;
        return this.layout && (i = this.layout.getSpan(t, r + n)),
        n + i
    }
    decode(t, r=0) {
        const n = this.makeDestinationObject();
        if (this !== this.union.getVariant(t, r))
            throw new Error("variant mismatch");
        let i = 0;
        return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span),
        this.layout ? n[this.property] = this.layout.decode(t, r + i) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant),
        n
    }
    encode(t, r, n=0) {
        let i = 0;
        if (this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span),
        this.layout && !Object.prototype.hasOwnProperty.call(t, this.property))
            throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, r, n);
        let s = i;
        if (this.layout && (this.layout.encode(t[this.property], r, n + i),
        s += this.layout.getSpan(r, n + i),
        0 <= this.union.span && s > this.union.span))
            throw new Error("encoded variant overruns containing union");
        return s
    }
    fromArray(t) {
        if (this.layout)
            return this.layout.fromArray(t)
    }
}
J.VariantLayout = u4;
function lo(e) {
    return 0 > e && (e += 4294967296),
    e
}
class gm extends it {
    constructor(t, r, n) {
        if (!(t instanceof hn || t instanceof An))
            throw new TypeError("word must be a UInt or UIntBE layout");
        if (typeof r == "string" && n === void 0 && (n = r,
        r = !1),
        4 < t.span)
            throw new RangeError("word cannot exceed 32 bits");
        super(t.span, n),
        this.word = t,
        this.msb = !!r,
        this.fields = [];
        let i = 0;
        this._packedSetValue = function(s) {
            return i = lo(s),
            this
        }
        ,
        this._packedGetValue = function() {
            return i
        }
    }
    decode(t, r=0) {
        const n = this.makeDestinationObject()
          , i = this.word.decode(t, r);
        this._packedSetValue(i);
        for (const s of this.fields)
            s.property !== void 0 && (n[s.property] = s.decode(t));
        return n
    }
    encode(t, r, n=0) {
        const i = this.word.decode(r, n);
        this._packedSetValue(i);
        for (const s of this.fields)
            if (s.property !== void 0) {
                const o = t[s.property];
                o !== void 0 && s.encode(o)
            }
        return this.word.encode(this._packedGetValue(), r, n)
    }
    addField(t, r) {
        const n = new mm(this,t,r);
        return this.fields.push(n),
        n
    }
    addBoolean(t) {
        const r = new c4(this,t);
        return this.fields.push(r),
        r
    }
    fieldFor(t) {
        if (typeof t != "string")
            throw new TypeError("property must be string");
        for (const r of this.fields)
            if (r.property === t)
                return r
    }
}
J.BitStructure = gm;
class mm {
    constructor(t, r, n) {
        if (!(t instanceof gm))
            throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(r) || 0 >= r)
            throw new TypeError("bits must be positive integer");
        const i = 8 * t.span
          , s = t.fields.reduce( (o, a) => o + a.bits, 0);
        if (r + s > i)
            throw new Error("bits too long for span remainder (" + (i - s) + " of " + i + " remain)");
        this.container = t,
        this.bits = r,
        this.valueMask = (1 << r) - 1,
        r === 32 && (this.valueMask = 4294967295),
        this.start = s,
        this.container.msb && (this.start = i - s - r),
        this.wordMask = lo(this.valueMask << this.start),
        this.property = n
    }
    decode(t, r) {
        const n = this.container._packedGetValue();
        return lo(n & this.wordMask) >>> this.start
    }
    encode(t) {
        if (typeof t != "number" || !Number.isInteger(t) || t !== lo(t & this.valueMask))
            throw new TypeError(fm("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        const r = this.container._packedGetValue()
          , n = lo(t << this.start);
        this.container._packedSetValue(lo(r & ~this.wordMask) | n)
    }
}
J.BitField = mm;
let c4 = class extends mm {
    constructor(t, r) {
        super(t, 1, r)
    }
    decode(t, r) {
        return !!super.decode(t, r)
    }
    encode(t) {
        typeof t == "boolean" && (t = +t),
        super.encode(t)
    }
}
;
J.Boolean = c4;
let l4 = class extends it {
    constructor(t, r) {
        if (!(t instanceof Nr && t.isCount() || Number.isInteger(t) && 0 <= t))
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let n = -1;
        t instanceof Nr || (n = t),
        super(n, r),
        this.length = t
    }
    getSpan(t, r) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, r)),
        n
    }
    decode(t, r=0) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(t, r)),
        Ze(t).slice(r, r + n)
    }
    encode(t, r, n) {
        let i = this.length;
        if (this.length instanceof Nr && (i = t.length),
        !(t instanceof Uint8Array && i === t.length))
            throw new TypeError(fm("Blob.encode", this) + " requires (length " + i + ") Uint8Array as src");
        if (n + i > r.length)
            throw new RangeError("encoding overruns Uint8Array");
        const s = Ze(t);
        return Ze(r).write(s.toString("hex"), n, i, "hex"),
        this.length instanceof Nr && this.length.encode(i, r, n),
        i
    }
}
;
J.Blob = l4;
class f4 extends it {
    constructor(t) {
        super(-1, t)
    }
    getSpan(t, r=0) {
        ma(t);
        let n = r;
        for (; n < t.length && t[n] !== 0; )
            n += 1;
        return 1 + n - r
    }
    decode(t, r=0) {
        const n = this.getSpan(t, r);
        return Ze(t).slice(r, r + n - 1).toString("utf-8")
    }
    encode(t, r, n=0) {
        typeof t != "string" && (t = String(t));
        const i = lm.Buffer.from(t, "utf8")
          , s = i.length;
        if (n + s > r.length)
            throw new RangeError("encoding overruns Buffer");
        const o = Ze(r);
        return i.copy(o, n),
        o[n + s] = 0,
        s + 1
    }
}
J.CString = f4;
class d4 extends it {
    constructor(t, r) {
        if (typeof t == "string" && r === void 0 && (r = t,
        t = void 0),
        t === void 0)
            t = -1;
        else if (!Number.isInteger(t))
            throw new TypeError("maxSpan must be an integer");
        super(-1, r),
        this.maxSpan = t
    }
    getSpan(t, r=0) {
        return ma(t),
        t.length - r
    }
    decode(t, r=0) {
        const n = this.getSpan(t, r);
        if (0 <= this.maxSpan && this.maxSpan < n)
            throw new RangeError("text length exceeds maxSpan");
        return Ze(t).slice(r, r + n).toString("utf-8")
    }
    encode(t, r, n=0) {
        typeof t != "string" && (t = String(t));
        const i = lm.Buffer.from(t, "utf8")
          , s = i.length;
        if (0 <= this.maxSpan && this.maxSpan < s)
            throw new RangeError("text length exceeds maxSpan");
        if (n + s > r.length)
            throw new RangeError("encoding overruns Buffer");
        return i.copy(Ze(r), n),
        s
    }
}
J.UTF8 = d4;
class h4 extends it {
    constructor(t, r) {
        super(0, r),
        this.value = t
    }
    decode(t, r) {
        return this.value
    }
    encode(t, r, n) {
        return 0
    }
}
J.Constant = h4;
J.greedy = (e, t) => new Z3(e,t);
var Us = J.offset = (e, t, r) => new dm(e,t,r)
  , Je = J.u8 = e => new hn(1,e)
  , on = J.u16 = e => new hn(2,e);
J.u24 = e => new hn(3,e);
var Le = J.u32 = e => new hn(4,e);
J.u40 = e => new hn(5,e);
J.u48 = e => new hn(6,e);
var sr = J.nu64 = e => new J3(e);
J.u16be = e => new An(2,e);
J.u24be = e => new An(3,e);
J.u32be = e => new An(4,e);
J.u40be = e => new An(5,e);
J.u48be = e => new An(6,e);
J.nu64be = e => new X3(e);
J.s8 = e => new to(1,e);
J.s16 = e => new to(2,e);
J.s24 = e => new to(3,e);
J.s32 = e => new to(4,e);
J.s40 = e => new to(5,e);
J.s48 = e => new to(6,e);
var Vr = J.ns64 = e => new e4(e);
J.s16be = e => new ya(2,e);
J.s24be = e => new ya(3,e);
J.s32be = e => new ya(4,e);
J.s40be = e => new ya(5,e);
J.s48be = e => new ya(6,e);
J.ns64be = e => new t4(e);
J.f32 = e => new r4(e);
J.f32be = e => new n4(e);
J.f64 = e => new i4(e);
J.f64be = e => new s4(e);
var Te = J.struct = (e, t, r) => new a4(e,t,r);
J.bits = (e, t, r) => new gm(e,t,r);
var Tr = J.seq = (e, t, r) => new o4(e,t,r);
J.union = (e, t, r) => new pm(e,t,r);
J.unionLayoutDiscriminator = (e, t) => new ff(e,t);
var gt = J.blob = (e, t) => new l4(e,t);
J.cstr = e => new f4(e);
J.utf8 = (e, t) => new d4(e,t);
J.constant = (e, t) => new h4(e,t);
var fc = {};
Object.defineProperty(fc, "__esModule", {
    value: !0
});
function IR(e) {
    {
        const t = Buffer.from(e);
        t.reverse();
        const r = t.toString("hex");
        return r.length === 0 ? BigInt(0) : BigInt(`0x${r}`)
    }
}
var TR = fc.toBigIntLE = IR;
function CR(e) {
    {
        const t = e.toString("hex");
        return t.length === 0 ? BigInt(0) : BigInt(`0x${t}`)
    }
}
fc.toBigIntBE = CR;
function kR(e, t) {
    {
        const r = e.toString(16)
          , n = Buffer.from(r.padStart(t * 2, "0").slice(0, t * 2), "hex");
        return n.reverse(),
        n
    }
}
var LR = fc.toBufferLE = kR;
function OR(e, t) {
    {
        const r = e.toString(16);
        return Buffer.from(r.padStart(t * 2, "0").slice(0, t * 2), "hex")
    }
}
fc.toBufferBE = OR;
class NR extends TypeError {
    constructor(t, r) {
        let n;
        const {message: i, ...s} = t
          , {path: o} = t
          , a = o.length === 0 ? i : "At path: " + o.join(".") + " -- " + i;
        super(a),
        Object.assign(this, s),
        this.name = this.constructor.name,
        this.failures = () => {
            var u;
            return (u = n) != null ? u : n = [t, ...r()]
        }
    }
}
function RR(e) {
    return Xi(e) && typeof e[Symbol.iterator] == "function"
}
function Xi(e) {
    return typeof e == "object" && e != null
}
function Tn(e) {
    return typeof e == "string" ? JSON.stringify(e) : "" + e
}
function BR(e) {
    const {done: t, value: r} = e.next();
    return t ? void 0 : r
}
function PR(e, t, r, n) {
    if (e === !0)
        return;
    e === !1 ? e = {} : typeof e == "string" && (e = {
        message: e
    });
    const {path: i, branch: s} = t
      , {type: o} = r
      , {refinement: a, message: u="Expected a value of type `" + o + "`" + (a ? " with refinement `" + a + "`" : "") + ", but received: `" + Tn(n) + "`"} = e;
    return {
        value: n,
        type: o,
        refinement: a,
        key: i[i.length - 1],
        path: i,
        branch: s,
        ...e,
        message: u
    }
}
function *gb(e, t, r, n) {
    RR(e) || (e = [e]);
    for (const i of e) {
        const s = PR(i, t, r, n);
        s && (yield s)
    }
}
function *ym(e, t, r={}) {
    const {path: n=[], branch: i=[e], coerce: s=!1, mask: o=!1} = r
      , a = {
        path: n,
        branch: i
    };
    if (s && (e = t.coercer(e, a),
    o && t.type !== "type" && Xi(t.schema) && Xi(e) && !Array.isArray(e)))
        for (const c in e)
            t.schema[c] === void 0 && delete e[c];
    let u = !0;
    for (const c of t.validator(e, a))
        u = !1,
        yield[c, void 0];
    for (let[c,l,p] of t.entries(e, a)) {
        const h = ym(l, p, {
            path: c === void 0 ? n : [...n, c],
            branch: c === void 0 ? i : [...i, l],
            coerce: s,
            mask: o
        });
        for (const g of h)
            g[0] ? (u = !1,
            yield[g[0], void 0]) : s && (l = g[1],
            c === void 0 ? e = l : e instanceof Map ? e.set(c, l) : e instanceof Set ? e.add(l) : Xi(e) && (e[c] = l))
    }
    if (u)
        for (const c of t.refiner(e, a))
            u = !1,
            yield[c, void 0];
    u && (yield[void 0, e])
}
let Zn = class {
    constructor(t) {
        const {type: r, schema: n, validator: i, refiner: s, coercer: o=u => u, entries: a=function*() {}
        } = t;
        this.type = r,
        this.schema = n,
        this.entries = a,
        this.coercer = o,
        i ? this.validator = (u, c) => {
            const l = i(u, c);
            return gb(l, c, this, u)
        }
        : this.validator = () => [],
        s ? this.refiner = (u, c) => {
            const l = s(u, c);
            return gb(l, c, this, u)
        }
        : this.refiner = () => []
    }
    assert(t) {
        return jR(t, this)
    }
    create(t) {
        return _u(t, this)
    }
    is(t) {
        return p4(t, this)
    }
    mask(t) {
        return DR(t, this)
    }
    validate(t, r={}) {
        return dc(t, this, r)
    }
}
;
function jR(e, t) {
    const r = dc(e, t);
    if (r[0])
        throw r[0]
}
function _u(e, t) {
    const r = dc(e, t, {
        coerce: !0
    });
    if (r[0])
        throw r[0];
    return r[1]
}
function DR(e, t) {
    const r = dc(e, t, {
        coerce: !0,
        mask: !0
    });
    if (r[0])
        throw r[0];
    return r[1]
}
function p4(e, t) {
    return !dc(e, t)[0]
}
function dc(e, t, r={}) {
    const n = ym(e, t, r)
      , i = BR(n);
    return i[0] ? [new NR(i[0],function*() {
        for (const o of n)
            o[0] && (yield o[0])
    }
    ), void 0] : [void 0, i[1]]
}
function ro(e, t) {
    return new Zn({
        type: e,
        schema: null,
        validator: t
    })
}
function UR() {
    return ro("any", () => !0)
}
function Ie(e) {
    return new Zn({
        type: "array",
        schema: e,
        *entries(t) {
            if (e && Array.isArray(t))
                for (const [r,n] of t.entries())
                    yield[r, n, e]
        },
        coercer(t) {
            return Array.isArray(t) ? t.slice() : t
        },
        validator(t) {
            return Array.isArray(t) || "Expected an array value, but received: " + Tn(t)
        }
    })
}
function Wn() {
    return ro("boolean", e => typeof e == "boolean")
}
function bm(e) {
    return ro("instance", t => t instanceof e || "Expected a `" + e.name + "` instance, but received: " + Tn(t))
}
function Et(e) {
    const t = Tn(e)
      , r = typeof e;
    return new Zn({
        type: "literal",
        schema: r === "string" || r === "number" || r === "boolean" ? e : null,
        validator(n) {
            return n === e || "Expected the literal `" + t + "`, but received: " + Tn(n)
        }
    })
}
function zR() {
    return ro("never", () => !1)
}
function Me(e) {
    return new Zn({
        ...e,
        validator: (t, r) => t === null || e.validator(t, r),
        refiner: (t, r) => t === null || e.refiner(t, r)
    })
}
function Z() {
    return ro("number", e => typeof e == "number" && !isNaN(e) || "Expected a number, but received: " + Tn(e))
}
function Re(e) {
    return new Zn({
        ...e,
        validator: (t, r) => t === void 0 || e.validator(t, r),
        refiner: (t, r) => t === void 0 || e.refiner(t, r)
    })
}
function g4(e, t) {
    return new Zn({
        type: "record",
        schema: null,
        *entries(r) {
            if (Xi(r))
                for (const n in r) {
                    const i = r[n];
                    yield[n, n, e],
                    yield[n, i, t]
                }
        },
        validator(r) {
            return Xi(r) || "Expected an object, but received: " + Tn(r)
        }
    })
}
function be() {
    return ro("string", e => typeof e == "string" || "Expected a string, but received: " + Tn(e))
}
function wm(e) {
    const t = zR();
    return new Zn({
        type: "tuple",
        schema: null,
        *entries(r) {
            if (Array.isArray(r)) {
                const n = Math.max(e.length, r.length);
                for (let i = 0; i < n; i++)
                    yield[i, r[i], e[i] || t]
            }
        },
        validator(r) {
            return Array.isArray(r) || "Expected an array, but received: " + Tn(r)
        }
    })
}
function fe(e) {
    const t = Object.keys(e);
    return new Zn({
        type: "type",
        schema: e,
        *entries(r) {
            if (Xi(r))
                for (const n of t)
                    yield[n, r[n], e[n]]
        },
        validator(r) {
            return Xi(r) || "Expected an object, but received: " + Tn(r)
        }
    })
}
function jr(e) {
    const t = e.map(r => r.type).join(" | ");
    return new Zn({
        type: "union",
        schema: null,
        validator(r, n) {
            const i = [];
            for (const s of e) {
                const [...o] = ym(r, s, n)
                  , [a] = o;
                if (a[0])
                    for (const [u] of o)
                        u && i.push(u);
                else
                    return []
            }
            return ["Expected the value to satisfy a union of `" + t + "`, but received: " + Tn(r), ...i]
        }
    })
}
function hc() {
    return ro("unknown", () => !0)
}
function pc(e, t, r) {
    return new Zn({
        ...e,
        coercer: (n, i) => p4(n, t) ? e.coercer(r(n, i), i) : e.coercer(n, i)
    })
}
var Yc, $R = new Uint8Array(16);
function m4() {
    if (!Yc && (Yc = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto),
    !Yc))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return Yc($R)
}
const FR = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function fd(e) {
    return typeof e == "string" && FR.test(e)
}
var ir = [];
for (var T0 = 0; T0 < 256; ++T0)
    ir.push((T0 + 256).toString(16).substr(1));
function dd(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
      , r = (ir[e[t + 0]] + ir[e[t + 1]] + ir[e[t + 2]] + ir[e[t + 3]] + "-" + ir[e[t + 4]] + ir[e[t + 5]] + "-" + ir[e[t + 6]] + ir[e[t + 7]] + "-" + ir[e[t + 8]] + ir[e[t + 9]] + "-" + ir[e[t + 10]] + ir[e[t + 11]] + ir[e[t + 12]] + ir[e[t + 13]] + ir[e[t + 14]] + ir[e[t + 15]]).toLowerCase();
    if (!fd(r))
        throw TypeError("Stringified UUID is invalid");
    return r
}
var mb, C0, k0 = 0, L0 = 0;
function HR(e, t, r) {
    var n = t && r || 0
      , i = t || new Array(16);
    e = e || {};
    var s = e.node || mb
      , o = e.clockseq !== void 0 ? e.clockseq : C0;
    if (s == null || o == null) {
        var a = e.random || (e.rng || m4)();
        s == null && (s = mb = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]),
        o == null && (o = C0 = (a[6] << 8 | a[7]) & 16383)
    }
    var u = e.msecs !== void 0 ? e.msecs : Date.now()
      , c = e.nsecs !== void 0 ? e.nsecs : L0 + 1
      , l = u - k0 + (c - L0) / 1e4;
    if (l < 0 && e.clockseq === void 0 && (o = o + 1 & 16383),
    (l < 0 || u > k0) && e.nsecs === void 0 && (c = 0),
    c >= 1e4)
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    k0 = u,
    L0 = c,
    C0 = o,
    u += 122192928e5;
    var p = ((u & 268435455) * 1e4 + c) % 4294967296;
    i[n++] = p >>> 24 & 255,
    i[n++] = p >>> 16 & 255,
    i[n++] = p >>> 8 & 255,
    i[n++] = p & 255;
    var h = u / 4294967296 * 1e4 & 268435455;
    i[n++] = h >>> 8 & 255,
    i[n++] = h & 255,
    i[n++] = h >>> 24 & 15 | 16,
    i[n++] = h >>> 16 & 255,
    i[n++] = o >>> 8 | 128,
    i[n++] = o & 255;
    for (var g = 0; g < 6; ++g)
        i[n + g] = s[g];
    return t || dd(i)
}
function y4(e) {
    if (!fd(e))
        throw TypeError("Invalid UUID");
    var t, r = new Uint8Array(16);
    return r[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24,
    r[1] = t >>> 16 & 255,
    r[2] = t >>> 8 & 255,
    r[3] = t & 255,
    r[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8,
    r[5] = t & 255,
    r[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8,
    r[7] = t & 255,
    r[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8,
    r[9] = t & 255,
    r[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255,
    r[11] = t / 4294967296 & 255,
    r[12] = t >>> 24 & 255,
    r[13] = t >>> 16 & 255,
    r[14] = t >>> 8 & 255,
    r[15] = t & 255,
    r
}
function qR(e) {
    e = unescape(encodeURIComponent(e));
    for (var t = [], r = 0; r < e.length; ++r)
        t.push(e.charCodeAt(r));
    return t
}
var WR = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
  , VR = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function b4(e, t, r) {
    function n(i, s, o, a) {
        if (typeof i == "string" && (i = qR(i)),
        typeof s == "string" && (s = y4(s)),
        s.length !== 16)
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var u = new Uint8Array(16 + i.length);
        if (u.set(s),
        u.set(i, s.length),
        u = r(u),
        u[6] = u[6] & 15 | t,
        u[8] = u[8] & 63 | 128,
        o) {
            a = a || 0;
            for (var c = 0; c < 16; ++c)
                o[a + c] = u[c];
            return o
        }
        return dd(u)
    }
    try {
        n.name = e
    } catch {}
    return n.DNS = WR,
    n.URL = VR,
    n
}
function KR(e) {
    if (typeof e == "string") {
        var t = unescape(encodeURIComponent(e));
        e = new Uint8Array(t.length);
        for (var r = 0; r < t.length; ++r)
            e[r] = t.charCodeAt(r)
    }
    return GR(QR(YR(e), e.length * 8))
}
function GR(e) {
    for (var t = [], r = e.length * 32, n = "0123456789abcdef", i = 0; i < r; i += 8) {
        var s = e[i >> 5] >>> i % 32 & 255
          , o = parseInt(n.charAt(s >>> 4 & 15) + n.charAt(s & 15), 16);
        t.push(o)
    }
    return t
}
function w4(e) {
    return (e + 64 >>> 9 << 4) + 14 + 1
}
function QR(e, t) {
    e[t >> 5] |= 128 << t % 32,
    e[w4(t) - 1] = t;
    for (var r = 1732584193, n = -271733879, i = -1732584194, s = 271733878, o = 0; o < e.length; o += 16) {
        var a = r
          , u = n
          , c = i
          , l = s;
        r = dr(r, n, i, s, e[o], 7, -680876936),
        s = dr(s, r, n, i, e[o + 1], 12, -389564586),
        i = dr(i, s, r, n, e[o + 2], 17, 606105819),
        n = dr(n, i, s, r, e[o + 3], 22, -1044525330),
        r = dr(r, n, i, s, e[o + 4], 7, -176418897),
        s = dr(s, r, n, i, e[o + 5], 12, 1200080426),
        i = dr(i, s, r, n, e[o + 6], 17, -1473231341),
        n = dr(n, i, s, r, e[o + 7], 22, -45705983),
        r = dr(r, n, i, s, e[o + 8], 7, 1770035416),
        s = dr(s, r, n, i, e[o + 9], 12, -1958414417),
        i = dr(i, s, r, n, e[o + 10], 17, -42063),
        n = dr(n, i, s, r, e[o + 11], 22, -1990404162),
        r = dr(r, n, i, s, e[o + 12], 7, 1804603682),
        s = dr(s, r, n, i, e[o + 13], 12, -40341101),
        i = dr(i, s, r, n, e[o + 14], 17, -1502002290),
        n = dr(n, i, s, r, e[o + 15], 22, 1236535329),
        r = hr(r, n, i, s, e[o + 1], 5, -165796510),
        s = hr(s, r, n, i, e[o + 6], 9, -1069501632),
        i = hr(i, s, r, n, e[o + 11], 14, 643717713),
        n = hr(n, i, s, r, e[o], 20, -373897302),
        r = hr(r, n, i, s, e[o + 5], 5, -701558691),
        s = hr(s, r, n, i, e[o + 10], 9, 38016083),
        i = hr(i, s, r, n, e[o + 15], 14, -660478335),
        n = hr(n, i, s, r, e[o + 4], 20, -405537848),
        r = hr(r, n, i, s, e[o + 9], 5, 568446438),
        s = hr(s, r, n, i, e[o + 14], 9, -1019803690),
        i = hr(i, s, r, n, e[o + 3], 14, -187363961),
        n = hr(n, i, s, r, e[o + 8], 20, 1163531501),
        r = hr(r, n, i, s, e[o + 13], 5, -1444681467),
        s = hr(s, r, n, i, e[o + 2], 9, -51403784),
        i = hr(i, s, r, n, e[o + 7], 14, 1735328473),
        n = hr(n, i, s, r, e[o + 12], 20, -1926607734),
        r = pr(r, n, i, s, e[o + 5], 4, -378558),
        s = pr(s, r, n, i, e[o + 8], 11, -2022574463),
        i = pr(i, s, r, n, e[o + 11], 16, 1839030562),
        n = pr(n, i, s, r, e[o + 14], 23, -35309556),
        r = pr(r, n, i, s, e[o + 1], 4, -1530992060),
        s = pr(s, r, n, i, e[o + 4], 11, 1272893353),
        i = pr(i, s, r, n, e[o + 7], 16, -155497632),
        n = pr(n, i, s, r, e[o + 10], 23, -1094730640),
        r = pr(r, n, i, s, e[o + 13], 4, 681279174),
        s = pr(s, r, n, i, e[o], 11, -358537222),
        i = pr(i, s, r, n, e[o + 3], 16, -722521979),
        n = pr(n, i, s, r, e[o + 6], 23, 76029189),
        r = pr(r, n, i, s, e[o + 9], 4, -640364487),
        s = pr(s, r, n, i, e[o + 12], 11, -421815835),
        i = pr(i, s, r, n, e[o + 15], 16, 530742520),
        n = pr(n, i, s, r, e[o + 2], 23, -995338651),
        r = gr(r, n, i, s, e[o], 6, -198630844),
        s = gr(s, r, n, i, e[o + 7], 10, 1126891415),
        i = gr(i, s, r, n, e[o + 14], 15, -1416354905),
        n = gr(n, i, s, r, e[o + 5], 21, -57434055),
        r = gr(r, n, i, s, e[o + 12], 6, 1700485571),
        s = gr(s, r, n, i, e[o + 3], 10, -1894986606),
        i = gr(i, s, r, n, e[o + 10], 15, -1051523),
        n = gr(n, i, s, r, e[o + 1], 21, -2054922799),
        r = gr(r, n, i, s, e[o + 8], 6, 1873313359),
        s = gr(s, r, n, i, e[o + 15], 10, -30611744),
        i = gr(i, s, r, n, e[o + 6], 15, -1560198380),
        n = gr(n, i, s, r, e[o + 13], 21, 1309151649),
        r = gr(r, n, i, s, e[o + 4], 6, -145523070),
        s = gr(s, r, n, i, e[o + 11], 10, -1120210379),
        i = gr(i, s, r, n, e[o + 2], 15, 718787259),
        n = gr(n, i, s, r, e[o + 9], 21, -343485551),
        r = Gi(r, a),
        n = Gi(n, u),
        i = Gi(i, c),
        s = Gi(s, l)
    }
    return [r, n, i, s]
}
function YR(e) {
    if (e.length === 0)
        return [];
    for (var t = e.length * 8, r = new Uint32Array(w4(t)), n = 0; n < t; n += 8)
        r[n >> 5] |= (e[n / 8] & 255) << n % 32;
    return r
}
function Gi(e, t) {
    var r = (e & 65535) + (t & 65535)
      , n = (e >> 16) + (t >> 16) + (r >> 16);
    return n << 16 | r & 65535
}
function ZR(e, t) {
    return e << t | e >>> 32 - t
}
function hd(e, t, r, n, i, s) {
    return Gi(ZR(Gi(Gi(t, e), Gi(n, s)), i), r)
}
function dr(e, t, r, n, i, s, o) {
    return hd(t & r | ~t & n, e, t, i, s, o)
}
function hr(e, t, r, n, i, s, o) {
    return hd(t & n | r & ~n, e, t, i, s, o)
}
function pr(e, t, r, n, i, s, o) {
    return hd(t ^ r ^ n, e, t, i, s, o)
}
function gr(e, t, r, n, i, s, o) {
    return hd(r ^ (t | ~n), e, t, i, s, o)
}
var JR = b4("v3", 48, KR);
const XR = JR;
function e7(e, t, r) {
    e = e || {};
    var n = e.random || (e.rng || m4)();
    if (n[6] = n[6] & 15 | 64,
    n[8] = n[8] & 63 | 128,
    t) {
        r = r || 0;
        for (var i = 0; i < 16; ++i)
            t[r + i] = n[i];
        return t
    }
    return dd(n)
}
function t7(e, t, r, n) {
    switch (e) {
    case 0:
        return t & r ^ ~t & n;
    case 1:
        return t ^ r ^ n;
    case 2:
        return t & r ^ t & n ^ r & n;
    case 3:
        return t ^ r ^ n
    }
}
function O0(e, t) {
    return e << t | e >>> 32 - t
}
function r7(e) {
    var t = [1518500249, 1859775393, 2400959708, 3395469782]
      , r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof e == "string") {
        var n = unescape(encodeURIComponent(e));
        e = [];
        for (var i = 0; i < n.length; ++i)
            e.push(n.charCodeAt(i))
    } else
        Array.isArray(e) || (e = Array.prototype.slice.call(e));
    e.push(128);
    for (var s = e.length / 4 + 2, o = Math.ceil(s / 16), a = new Array(o), u = 0; u < o; ++u) {
        for (var c = new Uint32Array(16), l = 0; l < 16; ++l)
            c[l] = e[u * 64 + l * 4] << 24 | e[u * 64 + l * 4 + 1] << 16 | e[u * 64 + l * 4 + 2] << 8 | e[u * 64 + l * 4 + 3];
        a[u] = c
    }
    a[o - 1][14] = (e.length - 1) * 8 / Math.pow(2, 32),
    a[o - 1][14] = Math.floor(a[o - 1][14]),
    a[o - 1][15] = (e.length - 1) * 8 & 4294967295;
    for (var p = 0; p < o; ++p) {
        for (var h = new Uint32Array(80), g = 0; g < 16; ++g)
            h[g] = a[p][g];
        for (var S = 16; S < 80; ++S)
            h[S] = O0(h[S - 3] ^ h[S - 8] ^ h[S - 14] ^ h[S - 16], 1);
        for (var x = r[0], v = r[1], I = r[2], M = r[3], A = r[4], k = 0; k < 80; ++k) {
            var L = Math.floor(k / 20)
              , O = O0(x, 5) + t7(L, v, I, M) + A + t[L] + h[k] >>> 0;
            A = M,
            M = I,
            I = O0(v, 30) >>> 0,
            v = x,
            x = O
        }
        r[0] = r[0] + x >>> 0,
        r[1] = r[1] + v >>> 0,
        r[2] = r[2] + I >>> 0,
        r[3] = r[3] + M >>> 0,
        r[4] = r[4] + A >>> 0
    }
    return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, r[0] & 255, r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, r[1] & 255, r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, r[2] & 255, r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, r[3] & 255, r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, r[4] & 255]
}
var n7 = b4("v5", 80, r7);
const i7 = n7
  , s7 = "00000000-0000-0000-0000-000000000000";
function o7(e) {
    if (!fd(e))
        throw TypeError("Invalid UUID");
    return parseInt(e.substr(14, 1), 16)
}
const a7 = Object.freeze(Object.defineProperty({
    __proto__: null,
    NIL: s7,
    parse: y4,
    stringify: dd,
    v1: HR,
    v3: XR,
    v4: e7,
    v5: i7,
    validate: fd,
    version: o7
}, Symbol.toStringTag, {
    value: "Module"
}))
  , v4 = kg(a7)
  , u7 = v4.v4
  , c7 = function(e, t, r, n) {
    if (typeof e != "string")
        throw new TypeError(e + " must be a string");
    n = n || {};
    const i = typeof n.version == "number" ? n.version : 2;
    if (i !== 1 && i !== 2)
        throw new TypeError(i + " must be 1 or 2");
    const s = {
        method: e
    };
    if (i === 2 && (s.jsonrpc = "2.0"),
    t) {
        if (typeof t != "object" && !Array.isArray(t))
            throw new TypeError(t + " must be an object, array or omitted");
        s.params = t
    }
    if (typeof r > "u") {
        const o = typeof n.generator == "function" ? n.generator : function() {
            return u7()
        }
        ;
        s.id = o(s, n)
    } else
        i === 2 && r === null ? n.notificationIdNull && (s.id = null) : s.id = r;
    return s
};
var l7 = c7;
const f7 = v4.v4
  , d7 = l7
  , df = function(e, t) {
    if (!(this instanceof df))
        return new df(e,t);
    t || (t = {}),
    this.options = {
        reviver: typeof t.reviver < "u" ? t.reviver : null,
        replacer: typeof t.replacer < "u" ? t.replacer : null,
        generator: typeof t.generator < "u" ? t.generator : function() {
            return f7()
        }
        ,
        version: typeof t.version < "u" ? t.version : 2,
        notificationIdNull: typeof t.notificationIdNull == "boolean" ? t.notificationIdNull : !1
    },
    this.callServer = e
};
df.prototype.request = function(e, t, r, n) {
    const i = this;
    let s = null;
    const o = Array.isArray(e) && typeof t == "function";
    if (this.options.version === 1 && o)
        throw new TypeError("JSON-RPC 1.0 does not support batching");
    if (o || !o && e && typeof e == "object" && typeof t == "function")
        n = t,
        s = e;
    else {
        typeof r == "function" && (n = r,
        r = void 0);
        const c = typeof n == "function";
        try {
            s = d7(e, t, r, {
                generator: this.options.generator,
                version: this.options.version,
                notificationIdNull: this.options.notificationIdNull
            })
        } catch (l) {
            if (c)
                return n(l);
            throw l
        }
        if (!c)
            return s
    }
    let u;
    try {
        u = JSON.stringify(s, this.options.replacer)
    } catch (c) {
        return n(c)
    }
    return this.callServer(u, function(c, l) {
        i._parseResponse(c, l, n)
    }),
    s
}
;
df.prototype._parseResponse = function(e, t, r) {
    if (e) {
        r(e);
        return
    }
    if (!t)
        return r();
    let n;
    try {
        n = JSON.parse(t, this.options.reviver)
    } catch (i) {
        return r(i)
    }
    if (r.length === 3)
        if (Array.isArray(n)) {
            const i = function(o) {
                return typeof o.error < "u"
            }
              , s = function(o) {
                return !i(o)
            };
            return r(null, n.filter(i), n.filter(s))
        } else
            return r(null, n.error, n.result);
    r(null, n)
}
;
var x4 = {}
  , Xo = {};
Object.defineProperty(Xo, "__esModule", {
    value: !0
});
Xo.createError = Xo.DefaultDataPack = void 0;
const h7 = new Map([[-32e3, "Event not provided"], [-32600, "Invalid Request"], [-32601, "Method not found"], [-32602, "Invalid params"], [-32603, "Internal error"], [-32604, "Params not found"], [-32605, "Method forbidden"], [-32606, "Event forbidden"], [-32700, "Parse error"]]);
class p7 {
    encode(t) {
        return JSON.stringify(t)
    }
    decode(t) {
        return JSON.parse(t)
    }
}
Xo.DefaultDataPack = p7;
function g7(e, t) {
    const r = {
        code: e,
        message: h7.get(e) || "Internal Server Error"
    };
    return t && (r.data = t),
    r
}
Xo.createError = g7;
Object.defineProperty(x4, "__esModule", {
    value: !0
});
const m7 = Qg
  , y7 = Xo;
class b7 extends m7.EventEmitter {
    constructor(r, n="ws://localhost:8080", {autoconnect: i=!0, reconnect: s=!0, reconnect_interval: o=1e3, max_reconnects: a=5, ...u}={}, c, l) {
        super();
        Xt(this, "address");
        Xt(this, "rpc_id");
        Xt(this, "queue");
        Xt(this, "options");
        Xt(this, "autoconnect");
        Xt(this, "ready");
        Xt(this, "reconnect");
        Xt(this, "reconnect_timer_id");
        Xt(this, "reconnect_interval");
        Xt(this, "max_reconnects");
        Xt(this, "rest_options");
        Xt(this, "current_reconnects");
        Xt(this, "generate_request_id");
        Xt(this, "socket");
        Xt(this, "webSocketFactory");
        Xt(this, "dataPack");
        this.webSocketFactory = r,
        this.queue = {},
        this.rpc_id = 0,
        this.address = n,
        this.autoconnect = i,
        this.ready = !1,
        this.reconnect = s,
        this.reconnect_timer_id = void 0,
        this.reconnect_interval = o,
        this.max_reconnects = a,
        this.rest_options = u,
        this.current_reconnects = 0,
        this.generate_request_id = c || ( () => ++this.rpc_id),
        l ? this.dataPack = l : this.dataPack = new y7.DefaultDataPack,
        this.autoconnect && this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
        })
    }
    connect() {
        this.socket || this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
        })
    }
    call(r, n, i, s) {
        return !s && typeof i == "object" && (s = i,
        i = null),
        new Promise( (o, a) => {
            if (!this.ready)
                return a(new Error("socket not ready"));
            const u = this.generate_request_id(r, n)
              , c = {
                jsonrpc: "2.0",
                method: r,
                params: n || void 0,
                id: u
            };
            this.socket.send(this.dataPack.encode(c), s, l => {
                if (l)
                    return a(l);
                this.queue[u] = {
                    promise: [o, a]
                },
                i && (this.queue[u].timeout = setTimeout( () => {
                    delete this.queue[u],
                    a(new Error("reply timeout"))
                }
                , i))
            }
            )
        }
        )
    }
    async login(r) {
        const n = await this.call("rpc.login", r);
        if (!n)
            throw new Error("authentication failed");
        return n
    }
    async listMethods() {
        return await this.call("__listMethods")
    }
    notify(r, n) {
        return new Promise( (i, s) => {
            if (!this.ready)
                return s(new Error("socket not ready"));
            const o = {
                jsonrpc: "2.0",
                method: r,
                params: n
            };
            this.socket.send(this.dataPack.encode(o), a => {
                if (a)
                    return s(a);
                i()
            }
            )
        }
        )
    }
    async subscribe(r) {
        typeof r == "string" && (r = [r]);
        const n = await this.call("rpc.on", r);
        if (typeof r == "string" && n[r] !== "ok")
            throw new Error("Failed subscribing to an event '" + r + "' with: " + n[r]);
        return n
    }
    async unsubscribe(r) {
        typeof r == "string" && (r = [r]);
        const n = await this.call("rpc.off", r);
        if (typeof r == "string" && n[r] !== "ok")
            throw new Error("Failed unsubscribing from an event with: " + n);
        return n
    }
    close(r, n) {
        this.socket.close(r || 1e3, n)
    }
    setAutoReconnect(r) {
        this.reconnect = r
    }
    setReconnectInterval(r) {
        this.reconnect_interval = r
    }
    setMaxReconnects(r) {
        this.max_reconnects = r
    }
    _connect(r, n) {
        clearTimeout(this.reconnect_timer_id),
        this.socket = this.webSocketFactory(r, n),
        this.socket.addEventListener("open", () => {
            this.ready = !0,
            this.emit("open"),
            this.current_reconnects = 0
        }
        ),
        this.socket.addEventListener("message", ({data: i}) => {
            i instanceof ArrayBuffer && (i = Buffer.from(i).toString());
            try {
                i = this.dataPack.decode(i)
            } catch {
                return
            }
            if (i.notification && this.listeners(i.notification).length) {
                if (!Object.keys(i.params).length)
                    return this.emit(i.notification);
                const s = [i.notification];
                if (i.params.constructor === Object)
                    s.push(i.params);
                else
                    for (let o = 0; o < i.params.length; o++)
                        s.push(i.params[o]);
                return Promise.resolve().then( () => {
                    this.emit.apply(this, s)
                }
                )
            }
            if (!this.queue[i.id])
                return i.method ? Promise.resolve().then( () => {
                    this.emit(i.method, i == null ? void 0 : i.params)
                }
                ) : void 0;
            "error"in i == "result"in i && this.queue[i.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),
            this.queue[i.id].timeout && clearTimeout(this.queue[i.id].timeout),
            i.error ? this.queue[i.id].promise[1](i.error) : this.queue[i.id].promise[0](i.result),
            delete this.queue[i.id]
        }
        ),
        this.socket.addEventListener("error", i => this.emit("error", i)),
        this.socket.addEventListener("close", ({code: i, reason: s}) => {
            this.ready && setTimeout( () => this.emit("close", i, s), 0),
            this.ready = !1,
            this.socket = void 0,
            i !== 1e3 && (this.current_reconnects++,
            this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0) && (this.reconnect_timer_id = setTimeout( () => this._connect(r, n), this.reconnect_interval)))
        }
        )
    }
}
x4.default = b7;
var E4 = {};
Object.defineProperty(E4, "__esModule", {
    value: !0
});
const w7 = Qg;
class v7 extends w7.EventEmitter {
    constructor(r, n, i) {
        super();
        Xt(this, "socket");
        this.socket = new window.WebSocket(r,i),
        this.socket.onopen = () => this.emit("open"),
        this.socket.onmessage = s => this.emit("message", s.data),
        this.socket.onerror = s => this.emit("error", s),
        this.socket.onclose = s => {
            this.emit("close", s.code, s.reason)
        }
    }
    send(r, n, i) {
        const s = i || n;
        try {
            this.socket.send(r),
            s()
        } catch (o) {
            s(o)
        }
    }
    close(r, n) {
        this.socket.close(r, n)
    }
    addEventListener(r, n, i) {
        this.socket.addEventListener(r, n, i)
    }
}
function x7(e, t) {
    return new v7(e,t)
}
E4.default = x7;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function E7(e) {
    const t = rm(e);
    ga(t, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {endo: r, Fp: n, a: i} = t;
    if (r) {
        if (!n.eql(i, n.ZERO))
            throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
            throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
    }
    return Object.freeze({
        ...t
    })
}
const {bytesToNumberBE: S7, hexToBytes: _7} = ON
  , Ms = {
    Err: class extends Error {
        constructor(t="") {
            super(t)
        }
    }
    ,
    _parseInt(e) {
        const {Err: t} = Ms;
        if (e.length < 2 || e[0] !== 2)
            throw new t("Invalid signature integer tag");
        const r = e[1]
          , n = e.subarray(2, r + 2);
        if (!r || n.length !== r)
            throw new t("Invalid signature integer: wrong length");
        if (n[0] & 128)
            throw new t("Invalid signature integer: negative");
        if (n[0] === 0 && !(n[1] & 128))
            throw new t("Invalid signature integer: unnecessary leading zero");
        return {
            d: S7(n),
            l: e.subarray(r + 2)
        }
    },
    toSig(e) {
        const {Err: t} = Ms
          , r = typeof e == "string" ? _7(e) : e;
        lc(r);
        let n = r.length;
        if (n < 2 || r[0] != 48)
            throw new t("Invalid signature tag");
        if (r[1] !== n - 2)
            throw new t("Invalid signature: incorrect length");
        const {d: i, l: s} = Ms._parseInt(r.subarray(2))
          , {d: o, l: a} = Ms._parseInt(s);
        if (a.length)
            throw new t("Invalid signature: left bytes after parsing");
        return {
            r: i,
            s: o
        }
    },
    hexFromSig(e) {
        const t = c => Number.parseInt(c[0], 16) & 8 ? "00" + c : c
          , r = c => {
            const l = c.toString(16);
            return l.length & 1 ? `0${l}` : l
        }
          , n = t(r(e.s))
          , i = t(r(e.r))
          , s = n.length / 2
          , o = i.length / 2
          , a = r(s)
          , u = r(o);
        return `30${r(o + s + 4)}02${u}${i}02${a}${n}`
    }
}
  , ui = BigInt(0)
  , sn = BigInt(1);
BigInt(2);
const yb = BigInt(3);
BigInt(4);
function A7(e) {
    const t = E7(e)
      , {Fp: r} = t
      , n = t.toBytes || ( (S, x, v) => {
        const I = x.toAffine();
        return Gs(Uint8Array.from([4]), r.toBytes(I.x), r.toBytes(I.y))
    }
    )
      , i = t.fromBytes || (S => {
        const x = S.subarray(1)
          , v = r.fromBytes(x.subarray(0, r.BYTES))
          , I = r.fromBytes(x.subarray(r.BYTES, 2 * r.BYTES));
        return {
            x: v,
            y: I
        }
    }
    );
    function s(S) {
        const {a: x, b: v} = t
          , I = r.sqr(S)
          , M = r.mul(I, S);
        return r.add(r.add(M, r.mul(S, x)), v)
    }
    if (!r.eql(r.sqr(t.Gy), s(t.Gx)))
        throw new Error("bad generator point: equation left != right");
    function o(S) {
        return typeof S == "bigint" && ui < S && S < t.n
    }
    function a(S) {
        if (!o(S))
            throw new Error("Expected valid bigint: 0 < bigint < curve.n")
    }
    function u(S) {
        const {allowedPrivateKeyLengths: x, nByteLength: v, wrapPrivateKey: I, n: M} = t;
        if (x && typeof S != "bigint") {
            if (Vs(S) && (S = Ks(S)),
            typeof S != "string" || !x.includes(S.length))
                throw new Error("Invalid key");
            S = S.padStart(v * 2, "0")
        }
        let A;
        try {
            A = typeof S == "bigint" ? S : Ds(Qt("private key", S, v))
        } catch {
            throw new Error(`private key must be ${v} bytes, hex or bigint, not ${typeof S}`)
        }
        return I && (A = wt(A, M)),
        a(A),
        A
    }
    const c = new Map;
    function l(S) {
        if (!(S instanceof p))
            throw new Error("ProjectivePoint expected")
    }
    class p {
        constructor(x, v, I) {
            if (this.px = x,
            this.py = v,
            this.pz = I,
            x == null || !r.isValid(x))
                throw new Error("x required");
            if (v == null || !r.isValid(v))
                throw new Error("y required");
            if (I == null || !r.isValid(I))
                throw new Error("z required")
        }
        static fromAffine(x) {
            const {x: v, y: I} = x || {};
            if (!x || !r.isValid(v) || !r.isValid(I))
                throw new Error("invalid affine point");
            if (x instanceof p)
                throw new Error("projective point not allowed");
            const M = A => r.eql(A, r.ZERO);
            return M(v) && M(I) ? p.ZERO : new p(v,I,r.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(x) {
            const v = r.invertBatch(x.map(I => I.pz));
            return x.map( (I, M) => I.toAffine(v[M])).map(p.fromAffine)
        }
        static fromHex(x) {
            const v = p.fromAffine(i(Qt("pointHex", x)));
            return v.assertValidity(),
            v
        }
        static fromPrivateKey(x) {
            return p.BASE.multiply(u(x))
        }
        _setWindowSize(x) {
            this._WINDOW_SIZE = x,
            c.delete(this)
        }
        assertValidity() {
            if (this.is0()) {
                if (t.allowInfinityPoint && !r.is0(this.py))
                    return;
                throw new Error("bad point: ZERO")
            }
            const {x, y: v} = this.toAffine();
            if (!r.isValid(x) || !r.isValid(v))
                throw new Error("bad point: x or y not FE");
            const I = r.sqr(v)
              , M = s(x);
            if (!r.eql(I, M))
                throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree())
                throw new Error("bad point: not in prime-order subgroup")
        }
        hasEvenY() {
            const {y: x} = this.toAffine();
            if (r.isOdd)
                return !r.isOdd(x);
            throw new Error("Field doesn't support isOdd")
        }
        equals(x) {
            l(x);
            const {px: v, py: I, pz: M} = this
              , {px: A, py: k, pz: L} = x
              , O = r.eql(r.mul(v, L), r.mul(A, M))
              , $ = r.eql(r.mul(I, L), r.mul(k, M));
            return O && $
        }
        negate() {
            return new p(this.px,r.neg(this.py),this.pz)
        }
        double() {
            const {a: x, b: v} = t
              , I = r.mul(v, yb)
              , {px: M, py: A, pz: k} = this;
            let L = r.ZERO
              , O = r.ZERO
              , $ = r.ZERO
              , D = r.mul(M, M)
              , K = r.mul(A, A)
              , G = r.mul(k, k)
              , F = r.mul(M, A);
            return F = r.add(F, F),
            $ = r.mul(M, k),
            $ = r.add($, $),
            L = r.mul(x, $),
            O = r.mul(I, G),
            O = r.add(L, O),
            L = r.sub(K, O),
            O = r.add(K, O),
            O = r.mul(L, O),
            L = r.mul(F, L),
            $ = r.mul(I, $),
            G = r.mul(x, G),
            F = r.sub(D, G),
            F = r.mul(x, F),
            F = r.add(F, $),
            $ = r.add(D, D),
            D = r.add($, D),
            D = r.add(D, G),
            D = r.mul(D, F),
            O = r.add(O, D),
            G = r.mul(A, k),
            G = r.add(G, G),
            D = r.mul(G, F),
            L = r.sub(L, D),
            $ = r.mul(G, K),
            $ = r.add($, $),
            $ = r.add($, $),
            new p(L,O,$)
        }
        add(x) {
            l(x);
            const {px: v, py: I, pz: M} = this
              , {px: A, py: k, pz: L} = x;
            let O = r.ZERO
              , $ = r.ZERO
              , D = r.ZERO;
            const K = t.a
              , G = r.mul(t.b, yb);
            let F = r.mul(v, A)
              , q = r.mul(I, k)
              , B = r.mul(M, L)
              , y = r.add(v, I)
              , b = r.add(A, k);
            y = r.mul(y, b),
            b = r.add(F, q),
            y = r.sub(y, b),
            b = r.add(v, M);
            let _ = r.add(A, L);
            return b = r.mul(b, _),
            _ = r.add(F, B),
            b = r.sub(b, _),
            _ = r.add(I, M),
            O = r.add(k, L),
            _ = r.mul(_, O),
            O = r.add(q, B),
            _ = r.sub(_, O),
            D = r.mul(K, b),
            O = r.mul(G, B),
            D = r.add(O, D),
            O = r.sub(q, D),
            D = r.add(q, D),
            $ = r.mul(O, D),
            q = r.add(F, F),
            q = r.add(q, F),
            B = r.mul(K, B),
            b = r.mul(G, b),
            q = r.add(q, B),
            B = r.sub(F, B),
            B = r.mul(K, B),
            b = r.add(b, B),
            F = r.mul(q, b),
            $ = r.add($, F),
            F = r.mul(_, b),
            O = r.mul(y, O),
            O = r.sub(O, F),
            F = r.mul(y, q),
            D = r.mul(_, D),
            D = r.add(D, F),
            new p(O,$,D)
        }
        subtract(x) {
            return this.add(x.negate())
        }
        is0() {
            return this.equals(p.ZERO)
        }
        wNAF(x) {
            return g.wNAFCached(this, c, x, v => {
                const I = r.invertBatch(v.map(M => M.pz));
                return v.map( (M, A) => M.toAffine(I[A])).map(p.fromAffine)
            }
            )
        }
        multiplyUnsafe(x) {
            const v = p.ZERO;
            if (x === ui)
                return v;
            if (a(x),
            x === sn)
                return this;
            const {endo: I} = t;
            if (!I)
                return g.unsafeLadder(this, x);
            let {k1neg: M, k1: A, k2neg: k, k2: L} = I.splitScalar(x)
              , O = v
              , $ = v
              , D = this;
            for (; A > ui || L > ui; )
                A & sn && (O = O.add(D)),
                L & sn && ($ = $.add(D)),
                D = D.double(),
                A >>= sn,
                L >>= sn;
            return M && (O = O.negate()),
            k && ($ = $.negate()),
            $ = new p(r.mul($.px, I.beta),$.py,$.pz),
            O.add($)
        }
        multiply(x) {
            a(x);
            let v = x, I, M;
            const {endo: A} = t;
            if (A) {
                const {k1neg: k, k1: L, k2neg: O, k2: $} = A.splitScalar(v);
                let {p: D, f: K} = this.wNAF(L)
                  , {p: G, f: F} = this.wNAF($);
                D = g.constTimeNegate(k, D),
                G = g.constTimeNegate(O, G),
                G = new p(r.mul(G.px, A.beta),G.py,G.pz),
                I = D.add(G),
                M = K.add(F)
            } else {
                const {p: k, f: L} = this.wNAF(v);
                I = k,
                M = L
            }
            return p.normalizeZ([I, M])[0]
        }
        multiplyAndAddUnsafe(x, v, I) {
            const M = p.BASE
              , A = (L, O) => O === ui || O === sn || !L.equals(M) ? L.multiplyUnsafe(O) : L.multiply(O)
              , k = A(this, v).add(A(x, I));
            return k.is0() ? void 0 : k
        }
        toAffine(x) {
            const {px: v, py: I, pz: M} = this
              , A = this.is0();
            x == null && (x = A ? r.ONE : r.inv(M));
            const k = r.mul(v, x)
              , L = r.mul(I, x)
              , O = r.mul(M, x);
            if (A)
                return {
                    x: r.ZERO,
                    y: r.ZERO
                };
            if (!r.eql(O, r.ONE))
                throw new Error("invZ was invalid");
            return {
                x: k,
                y: L
            }
        }
        isTorsionFree() {
            const {h: x, isTorsionFree: v} = t;
            if (x === sn)
                return !0;
            if (v)
                return v(p, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {h: x, clearCofactor: v} = t;
            return x === sn ? this : v ? v(p, this) : this.multiplyUnsafe(t.h)
        }
        toRawBytes(x=!0) {
            return this.assertValidity(),
            n(p, this, x)
        }
        toHex(x=!0) {
            return Ks(this.toRawBytes(x))
        }
    }
    p.BASE = new p(t.Gx,t.Gy,r.ONE),
    p.ZERO = new p(r.ZERO,r.ONE,r.ZERO);
    const h = t.nBitLength
      , g = U3(p, t.endo ? Math.ceil(h / 2) : h);
    return {
        CURVE: t,
        ProjectivePoint: p,
        normPrivateKeyToScalar: u,
        weierstrassEquation: s,
        isWithinCurveOrder: o
    }
}
function M7(e) {
    const t = rm(e);
    return ga(t, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }),
    Object.freeze({
        lowS: !0,
        ...t
    })
}
function I7(e) {
    const t = M7(e)
      , {Fp: r, n} = t
      , i = r.BYTES + 1
      , s = 2 * r.BYTES + 1;
    function o(b) {
        return ui < b && b < r.ORDER
    }
    function a(b) {
        return wt(b, n)
    }
    function u(b) {
        return sp(b, n)
    }
    const {ProjectivePoint: c, normPrivateKeyToScalar: l, weierstrassEquation: p, isWithinCurveOrder: h} = A7({
        ...t,
        toBytes(b, _, T) {
            const C = _.toAffine()
              , P = r.toBytes(C.x)
              , W = Gs;
            return T ? W(Uint8Array.from([_.hasEvenY() ? 2 : 3]), P) : W(Uint8Array.from([4]), P, r.toBytes(C.y))
        },
        fromBytes(b) {
            const _ = b.length
              , T = b[0]
              , C = b.subarray(1);
            if (_ === i && (T === 2 || T === 3)) {
                const P = Ds(C);
                if (!o(P))
                    throw new Error("Point is not on curve");
                const W = p(P);
                let N;
                try {
                    N = r.sqrt(W)
                } catch (re) {
                    const ie = re instanceof Error ? ": " + re.message : "";
                    throw new Error("Point is not on curve" + ie)
                }
                const w = (N & sn) === sn;
                return (T & 1) === 1 !== w && (N = r.neg(N)),
                {
                    x: P,
                    y: N
                }
            } else if (_ === s && T === 4) {
                const P = r.fromBytes(C.subarray(0, r.BYTES))
                  , W = r.fromBytes(C.subarray(r.BYTES, 2 * r.BYTES));
                return {
                    x: P,
                    y: W
                }
            } else
                throw new Error(`Point of length ${_} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`)
        }
    })
      , g = b => Ks(Zo(b, t.nByteLength));
    function S(b) {
        const _ = n >> sn;
        return b > _
    }
    function x(b) {
        return S(b) ? a(-b) : b
    }
    const v = (b, _, T) => Ds(b.slice(_, T));
    class I {
        constructor(_, T, C) {
            this.r = _,
            this.s = T,
            this.recovery = C,
            this.assertValidity()
        }
        static fromCompact(_) {
            const T = t.nByteLength;
            return _ = Qt("compactSignature", _, T * 2),
            new I(v(_, 0, T),v(_, T, 2 * T))
        }
        static fromDER(_) {
            const {r: T, s: C} = Ms.toSig(Qt("DER", _));
            return new I(T,C)
        }
        assertValidity() {
            if (!h(this.r))
                throw new Error("r must be 0 < r < CURVE.n");
            if (!h(this.s))
                throw new Error("s must be 0 < s < CURVE.n")
        }
        addRecoveryBit(_) {
            return new I(this.r,this.s,_)
        }
        recoverPublicKey(_) {
            const {r: T, s: C, recovery: P} = this
              , W = $(Qt("msgHash", _));
            if (P == null || ![0, 1, 2, 3].includes(P))
                throw new Error("recovery id invalid");
            const N = P === 2 || P === 3 ? T + t.n : T;
            if (N >= r.ORDER)
                throw new Error("recovery id 2 or 3 invalid");
            const w = P & 1 ? "03" : "02"
              , U = c.fromHex(w + g(N))
              , re = u(N)
              , ie = a(-W * re)
              , ue = a(C * re)
              , Q = c.BASE.multiplyAndAddUnsafe(U, ie, ue);
            if (!Q)
                throw new Error("point at infinify");
            return Q.assertValidity(),
            Q
        }
        hasHighS() {
            return S(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new I(this.r,a(-this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return Yo(this.toDERHex())
        }
        toDERHex() {
            return Ms.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return Yo(this.toCompactHex())
        }
        toCompactHex() {
            return g(this.r) + g(this.s)
        }
    }
    const M = {
        isValidPrivateKey(b) {
            try {
                return l(b),
                !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: l,
        randomPrivateKey: () => {
            const b = D3(t.n);
            return HN(t.randomBytes(b), t.n)
        }
        ,
        precompute(b=8, _=c.BASE) {
            return _._setWindowSize(b),
            _.multiply(BigInt(3)),
            _
        }
    };
    function A(b, _=!0) {
        return c.fromPrivateKey(b).toRawBytes(_)
    }
    function k(b) {
        const _ = Vs(b)
          , T = typeof b == "string"
          , C = (_ || T) && b.length;
        return _ ? C === i || C === s : T ? C === 2 * i || C === 2 * s : b instanceof c
    }
    function L(b, _, T=!0) {
        if (k(b))
            throw new Error("first arg must be private key");
        if (!k(_))
            throw new Error("second arg must be public key");
        return c.fromHex(_).multiply(l(b)).toRawBytes(T)
    }
    const O = t.bits2int || function(b) {
        const _ = Ds(b)
          , T = b.length * 8 - t.nBitLength;
        return T > 0 ? _ >> BigInt(T) : _
    }
      , $ = t.bits2int_modN || function(b) {
        return a(O(b))
    }
      , D = tm(t.nBitLength);
    function K(b) {
        if (typeof b != "bigint")
            throw new Error("bigint expected");
        if (!(ui <= b && b < D))
            throw new Error(`bigint expected < 2^${t.nBitLength}`);
        return Zo(b, t.nByteLength)
    }
    function G(b, _, T=F) {
        if (["recovered", "canonical"].some(te => te in T))
            throw new Error("sign() legacy options not supported");
        const {hash: C, randomBytes: P} = t;
        let {lowS: W, prehash: N, extraEntropy: w} = T;
        W == null && (W = !0),
        b = Qt("msgHash", b),
        N && (b = Qt("prehashed msgHash", C(b)));
        const U = $(b)
          , re = l(_)
          , ie = [K(re), K(U)];
        if (w != null && w !== !1) {
            const te = w === !0 ? P(r.BYTES) : w;
            ie.push(Qt("extraEntropy", te))
        }
        const ue = Gs(...ie)
          , Q = U;
        function ee(te) {
            const he = O(te);
            if (!h(he))
                return;
            const xe = u(he)
              , Ae = c.BASE.multiply(he).toAffine()
              , z = a(Ae.x);
            if (z === ui)
                return;
            const H = a(xe * a(Q + z * re));
            if (H === ui)
                return;
            let Y = (Ae.x === z ? 0 : 2) | Number(Ae.y & sn)
              , se = H;
            return W && S(H) && (se = x(H),
            Y ^= 1),
            new I(z,se,Y)
        }
        return {
            seed: ue,
            k2sig: ee
        }
    }
    const F = {
        lowS: t.lowS,
        prehash: !1
    }
      , q = {
        lowS: t.lowS,
        prehash: !1
    };
    function B(b, _, T=F) {
        const {seed: C, k2sig: P} = G(b, _, T)
          , W = t;
        return R3(W.hash.outputLen, W.nByteLength, W.hmac)(C, P)
    }
    c.BASE._setWindowSize(8);
    function y(b, _, T, C=q) {
        var Ae;
        const P = b;
        if (_ = Qt("msgHash", _),
        T = Qt("publicKey", T),
        "strict"in C)
            throw new Error("options.strict was renamed to lowS");
        const {lowS: W, prehash: N} = C;
        let w, U;
        try {
            if (typeof P == "string" || Vs(P))
                try {
                    w = I.fromDER(P)
                } catch (z) {
                    if (!(z instanceof Ms.Err))
                        throw z;
                    w = I.fromCompact(P)
                }
            else if (typeof P == "object" && typeof P.r == "bigint" && typeof P.s == "bigint") {
                const {r: z, s: H} = P;
                w = new I(z,H)
            } else
                throw new Error("PARSE");
            U = c.fromHex(T)
        } catch (z) {
            if (z.message === "PARSE")
                throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1
        }
        if (W && w.hasHighS())
            return !1;
        N && (_ = t.hash(_));
        const {r: re, s: ie} = w
          , ue = $(_)
          , Q = u(ie)
          , ee = a(ue * Q)
          , te = a(re * Q)
          , he = (Ae = c.BASE.multiplyAndAddUnsafe(U, ee, te)) == null ? void 0 : Ae.toAffine();
        return he ? a(he.x) === re : !1
    }
    return {
        CURVE: t,
        getPublicKey: A,
        getSharedSecret: L,
        sign: B,
        verify: y,
        ProjectivePoint: c,
        Signature: I,
        utils: M
    }
}
class S4 extends M3 {
    constructor(t, r) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        G9(t);
        const n = Xg(r);
        if (this.iHash = t.create(),
        typeof this.iHash.update != "function")
            throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen,
        this.outputLen = this.iHash.outputLen;
        const i = this.blockLen
          , s = new Uint8Array(i);
        s.set(n.length > i ? t.create().update(n).digest() : n);
        for (let o = 0; o < s.length; o++)
            s[o] ^= 54;
        this.iHash.update(s),
        this.oHash = t.create();
        for (let o = 0; o < s.length; o++)
            s[o] ^= 106;
        this.oHash.update(s),
        s.fill(0)
    }
    update(t) {
        return of(this),
        this.iHash.update(t),
        this
    }
    digestInto(t) {
        of(this),
        od(t, this.outputLen),
        this.finished = !0,
        this.iHash.digestInto(t),
        this.oHash.update(t),
        this.oHash.digestInto(t),
        this.destroy()
    }
    digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t),
        t
    }
    _cloneInto(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const {oHash: r, iHash: n, finished: i, destroyed: s, blockLen: o, outputLen: a} = this;
        return t = t,
        t.finished = i,
        t.destroyed = s,
        t.blockLen = o,
        t.outputLen = a,
        t.oHash = r._cloneInto(t.oHash),
        t.iHash = n._cloneInto(t.iHash),
        t
    }
    destroy() {
        this.destroyed = !0,
        this.oHash.destroy(),
        this.iHash.destroy()
    }
}
const _4 = (e, t, r) => new S4(e,t).update(r).digest();
_4.create = (e, t) => new S4(e,t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function T7(e) {
    return {
        hash: e,
        hmac: (t, ...r) => _4(e, t, A3(...r)),
        randomBytes: T3
    }
}
function C7(e, t) {
    const r = n => I7({
        ...e,
        ...T7(n)
    });
    return Object.freeze({
        ...r(t),
        create: r
    })
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const A4 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
  , bb = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
  , k7 = BigInt(1)
  , lp = BigInt(2)
  , wb = (e, t) => (e + t / lp) / t;
function L7(e) {
    const t = A4
      , r = BigInt(3)
      , n = BigInt(6)
      , i = BigInt(11)
      , s = BigInt(22)
      , o = BigInt(23)
      , a = BigInt(44)
      , u = BigInt(88)
      , c = e * e * e % t
      , l = c * c * e % t
      , p = Mt(l, r, t) * l % t
      , h = Mt(p, r, t) * l % t
      , g = Mt(h, lp, t) * c % t
      , S = Mt(g, i, t) * g % t
      , x = Mt(S, s, t) * S % t
      , v = Mt(x, a, t) * x % t
      , I = Mt(v, u, t) * v % t
      , M = Mt(I, a, t) * x % t
      , A = Mt(M, r, t) * l % t
      , k = Mt(A, o, t) * S % t
      , L = Mt(k, n, t) * c % t
      , O = Mt(L, lp, t);
    if (!fp.eql(fp.sqr(O), e))
        throw new Error("Cannot find square root");
    return O
}
const fp = P3(A4, void 0, void 0, {
    sqrt: L7
})
  , vm = C7({
    a: BigInt(0),
    b: BigInt(7),
    Fp: fp,
    n: bb,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: e => {
            const t = bb
              , r = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
              , n = -k7 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
              , i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
              , s = r
              , o = BigInt("0x100000000000000000000000000000000")
              , a = wb(s * e, t)
              , u = wb(-n * e, t);
            let c = wt(e - a * r - u * i, t)
              , l = wt(-a * n - u * s, t);
            const p = c > o
              , h = l > o;
            if (p && (c = t - c),
            h && (l = t - l),
            c > o || l > o)
                throw new Error("splitScalar: Endomorphism failed, k=" + e);
            return {
                k1neg: p,
                k1: c,
                k2neg: h,
                k2: l
            }
        }
    }
}, up);
BigInt(0);
vm.ProjectivePoint;
function vb(e) {
    try {
        return om.ExtendedPoint.fromHex(e),
        !0
    } catch {
        return !1
    }
}
const M4 = (e, t) => om.sign(e, t.slice(0, 32))
  , O7 = om.verify
  , xm = e => $e.Buffer.isBuffer(e) ? e : e instanceof Uint8Array ? $e.Buffer.from(e.buffer, e.byteOffset, e.byteLength) : $e.Buffer.from(e);
class N7 {
    constructor(t) {
        Object.assign(this, t)
    }
    encode() {
        return $e.Buffer.from(Q3(yl, this))
    }
    static decode(t) {
        return Y3(yl, this, t)
    }
    static decodeUnchecked(t) {
        return q3(yl, this, t)
    }
}
const yl = new Map;
var I4;
const R7 = 32
  , es = 32;
function B7(e) {
    return e._bn !== void 0
}
let xb = 1;
class Ne extends N7 {
    constructor(t) {
        if (super({}),
        this._bn = void 0,
        B7(t))
            this._bn = t._bn;
        else {
            if (typeof t == "string") {
                const r = Ar.decode(t);
                if (r.length != es)
                    throw new Error("Invalid public key input");
                this._bn = new pb(r)
            } else
                this._bn = new pb(t);
            if (this._bn.byteLength() > es)
                throw new Error("Invalid public key input")
        }
    }
    static unique() {
        const t = new Ne(xb);
        return xb += 1,
        new Ne(t.toBuffer())
    }
    equals(t) {
        return this._bn.eq(t._bn)
    }
    toBase58() {
        return Ar.encode(this.toBytes())
    }
    toJSON() {
        return this.toBase58()
    }
    toBytes() {
        const t = this.toBuffer();
        return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)
    }
    toBuffer() {
        const t = this._bn.toArrayLike($e.Buffer);
        if (t.length === es)
            return t;
        const r = $e.Buffer.alloc(32);
        return t.copy(r, 32 - t.length),
        r
    }
    get[Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`
    }
    toString() {
        return this.toBase58()
    }
    static async createWithSeed(t, r, n) {
        const i = $e.Buffer.concat([t.toBuffer(), $e.Buffer.from(r), n.toBuffer()])
          , s = up(i);
        return new Ne(s)
    }
    static createProgramAddressSync(t, r) {
        let n = $e.Buffer.alloc(0);
        t.forEach(function(s) {
            if (s.length > R7)
                throw new TypeError("Max seed length exceeded");
            n = $e.Buffer.concat([n, xm(s)])
        }),
        n = $e.Buffer.concat([n, r.toBuffer(), $e.Buffer.from("ProgramDerivedAddress")]);
        const i = up(n);
        if (vb(i))
            throw new Error("Invalid seeds, address must fall off the curve");
        return new Ne(i)
    }
    static async createProgramAddress(t, r) {
        return this.createProgramAddressSync(t, r)
    }
    static findProgramAddressSync(t, r) {
        let n = 255, i;
        for (; n != 0; ) {
            try {
                const s = t.concat($e.Buffer.from([n]));
                i = this.createProgramAddressSync(s, r)
            } catch (s) {
                if (s instanceof TypeError)
                    throw s;
                n--;
                continue
            }
            return [i, n]
        }
        throw new Error("Unable to find a viable program address nonce")
    }
    static async findProgramAddress(t, r) {
        return this.findProgramAddressSync(t, r)
    }
    static isOnCurve(t) {
        const r = new Ne(t);
        return vb(r.toBytes())
    }
}
I4 = Ne;
Ne.default = new I4("11111111111111111111111111111111");
yl.set(Ne, {
    kind: "struct",
    fields: [["_bn", "u256"]]
});
new Ne("BPFLoader1111111111111111111111111111111111");
const Io = 1232
  , Em = 127
  , Au = 64;
class hf {
    constructor(t, r) {
        this.staticAccountKeys = void 0,
        this.accountKeysFromLookups = void 0,
        this.staticAccountKeys = t,
        this.accountKeysFromLookups = r
    }
    keySegments() {
        const t = [this.staticAccountKeys];
        return this.accountKeysFromLookups && (t.push(this.accountKeysFromLookups.writable),
        t.push(this.accountKeysFromLookups.readonly)),
        t
    }
    get(t) {
        for (const r of this.keySegments()) {
            if (t < r.length)
                return r[t];
            t -= r.length
        }
    }
    get length() {
        return this.keySegments().flat().length
    }
    compileInstructions(t) {
        if (this.length > 256)
            throw new Error("Account index overflow encountered during compilation");
        const n = new Map;
        this.keySegments().flat().forEach( (s, o) => {
            n.set(s.toBase58(), o)
        }
        );
        const i = s => {
            const o = n.get(s.toBase58());
            if (o === void 0)
                throw new Error("Encountered an unknown instruction account key during compilation");
            return o
        }
        ;
        return t.map(s => ({
            programIdIndex: i(s.programId),
            accountKeyIndexes: s.keys.map(o => i(o.pubkey)),
            data: s.data
        }))
    }
}
const Ve = (e="publicKey") => gt(32, e)
  , P7 = (e="signature") => gt(64, e)
  , go = (e="string") => {
    const t = Te([Le("length"), Le("lengthPadding"), gt(Us(Le(), -8), "chars")], e)
      , r = t.decode.bind(t)
      , n = t.encode.bind(t)
      , i = t;
    return i.decode = (s, o) => r(s, o).chars.toString(),
    i.encode = (s, o, a) => {
        const u = {
            chars: $e.Buffer.from(s, "utf8")
        };
        return n(u, o, a)
    }
    ,
    i.alloc = s => Le().span + Le().span + $e.Buffer.from(s, "utf8").length,
    i
}
  , j7 = (e="authorized") => Te([Ve("staker"), Ve("withdrawer")], e)
  , D7 = (e="lockup") => Te([Vr("unixTimestamp"), Vr("epoch"), Ve("custodian")], e)
  , U7 = (e="voteInit") => Te([Ve("nodePubkey"), Ve("authorizedVoter"), Ve("authorizedWithdrawer"), Je("commission")], e)
  , z7 = (e="voteAuthorizeWithSeedArgs") => Te([Le("voteAuthorizationType"), Ve("currentAuthorityDerivedKeyOwnerPubkey"), go("currentAuthorityDerivedKeySeed"), Ve("newAuthorized")], e);
function Kr(e) {
    let t = 0
      , r = 0;
    for (; ; ) {
        let n = e.shift();
        if (t |= (n & 127) << r * 7,
        r += 1,
        !(n & 128))
            break
    }
    return t
}
function Gr(e, t) {
    let r = t;
    for (; ; ) {
        let n = r & 127;
        if (r >>= 7,
        r == 0) {
            e.push(n);
            break
        } else
            n |= 128,
            e.push(n)
    }
}
function Gt(e, t) {
    if (!e)
        throw new Error(t || "Assertion failed")
}
class pd {
    constructor(t, r) {
        this.payer = void 0,
        this.keyMetaMap = void 0,
        this.payer = t,
        this.keyMetaMap = r
    }
    static compile(t, r) {
        const n = new Map
          , i = o => {
            const a = o.toBase58();
            let u = n.get(a);
            return u === void 0 && (u = {
                isSigner: !1,
                isWritable: !1,
                isInvoked: !1
            },
            n.set(a, u)),
            u
        }
          , s = i(r);
        s.isSigner = !0,
        s.isWritable = !0;
        for (const o of t) {
            i(o.programId).isInvoked = !0;
            for (const a of o.keys) {
                const u = i(a.pubkey);
                u.isSigner || (u.isSigner = a.isSigner),
                u.isWritable || (u.isWritable = a.isWritable)
            }
        }
        return new pd(r,n)
    }
    getMessageComponents() {
        const t = [...this.keyMetaMap.entries()];
        Gt(t.length <= 256, "Max static account keys length exceeded");
        const r = t.filter( ([,u]) => u.isSigner && u.isWritable)
          , n = t.filter( ([,u]) => u.isSigner && !u.isWritable)
          , i = t.filter( ([,u]) => !u.isSigner && u.isWritable)
          , s = t.filter( ([,u]) => !u.isSigner && !u.isWritable)
          , o = {
            numRequiredSignatures: r.length + n.length,
            numReadonlySignedAccounts: n.length,
            numReadonlyUnsignedAccounts: s.length
        };
        {
            Gt(r.length > 0, "Expected at least one writable signer key");
            const [u] = r[0];
            Gt(u === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
        }
        const a = [...r.map( ([u]) => new Ne(u)), ...n.map( ([u]) => new Ne(u)), ...i.map( ([u]) => new Ne(u)), ...s.map( ([u]) => new Ne(u))];
        return [o, a]
    }
    extractTableLookup(t) {
        const [r,n] = this.drainKeysFoundInLookupTable(t.state.addresses, o => !o.isSigner && !o.isInvoked && o.isWritable)
          , [i,s] = this.drainKeysFoundInLookupTable(t.state.addresses, o => !o.isSigner && !o.isInvoked && !o.isWritable);
        if (!(r.length === 0 && i.length === 0))
            return [{
                accountKey: t.key,
                writableIndexes: r,
                readonlyIndexes: i
            }, {
                writable: n,
                readonly: s
            }]
    }
    drainKeysFoundInLookupTable(t, r) {
        const n = new Array
          , i = new Array;
        for (const [s,o] of this.keyMetaMap.entries())
            if (r(o)) {
                const a = new Ne(s)
                  , u = t.findIndex(c => c.equals(a));
                u >= 0 && (Gt(u < 256, "Max lookup table index exceeded"),
                n.push(u),
                i.push(a),
                this.keyMetaMap.delete(s))
            }
        return [n, i]
    }
}
const T4 = "Reached end of buffer unexpectedly";
function ci(e) {
    if (e.length === 0)
        throw new Error(T4);
    return e.shift()
}
function Qr(e, ...t) {
    const [r] = t;
    if (t.length === 2 ? r + (t[1] ?? 0) > e.length : r >= e.length)
        throw new Error(T4);
    return e.splice(...t)
}
class ea {
    constructor(t) {
        this.header = void 0,
        this.accountKeys = void 0,
        this.recentBlockhash = void 0,
        this.instructions = void 0,
        this.indexToProgramIds = new Map,
        this.header = t.header,
        this.accountKeys = t.accountKeys.map(r => new Ne(r)),
        this.recentBlockhash = t.recentBlockhash,
        this.instructions = t.instructions,
        this.instructions.forEach(r => this.indexToProgramIds.set(r.programIdIndex, this.accountKeys[r.programIdIndex]))
    }
    get version() {
        return "legacy"
    }
    get staticAccountKeys() {
        return this.accountKeys
    }
    get compiledInstructions() {
        return this.instructions.map(t => ({
            programIdIndex: t.programIdIndex,
            accountKeyIndexes: t.accounts,
            data: Ar.decode(t.data)
        }))
    }
    get addressTableLookups() {
        return []
    }
    getAccountKeys() {
        return new hf(this.staticAccountKeys)
    }
    static compile(t) {
        const r = pd.compile(t.instructions, t.payerKey)
          , [n,i] = r.getMessageComponents()
          , o = new hf(i).compileInstructions(t.instructions).map(a => ({
            programIdIndex: a.programIdIndex,
            accounts: a.accountKeyIndexes,
            data: Ar.encode(a.data)
        }));
        return new ea({
            header: n,
            accountKeys: i,
            recentBlockhash: t.recentBlockhash,
            instructions: o
        })
    }
    isAccountSigner(t) {
        return t < this.header.numRequiredSignatures
    }
    isAccountWritable(t) {
        const r = this.header.numRequiredSignatures;
        if (t >= this.header.numRequiredSignatures) {
            const n = t - r
              , s = this.accountKeys.length - r - this.header.numReadonlyUnsignedAccounts;
            return n < s
        } else {
            const n = r - this.header.numReadonlySignedAccounts;
            return t < n
        }
    }
    isProgramId(t) {
        return this.indexToProgramIds.has(t)
    }
    programIds() {
        return [...this.indexToProgramIds.values()]
    }
    nonProgramIds() {
        return this.accountKeys.filter( (t, r) => !this.isProgramId(r))
    }
    serialize() {
        const t = this.accountKeys.length;
        let r = [];
        Gr(r, t);
        const n = this.instructions.map(p => {
            const {accounts: h, programIdIndex: g} = p
              , S = Array.from(Ar.decode(p.data));
            let x = [];
            Gr(x, h.length);
            let v = [];
            return Gr(v, S.length),
            {
                programIdIndex: g,
                keyIndicesCount: $e.Buffer.from(x),
                keyIndices: h,
                dataLength: $e.Buffer.from(v),
                data: S
            }
        }
        );
        let i = [];
        Gr(i, n.length);
        let s = $e.Buffer.alloc(Io);
        $e.Buffer.from(i).copy(s);
        let o = i.length;
        n.forEach(p => {
            const g = Te([Je("programIdIndex"), gt(p.keyIndicesCount.length, "keyIndicesCount"), Tr(Je("keyIndex"), p.keyIndices.length, "keyIndices"), gt(p.dataLength.length, "dataLength"), Tr(Je("userdatum"), p.data.length, "data")]).encode(p, s, o);
            o += g
        }
        ),
        s = s.slice(0, o);
        const a = Te([gt(1, "numRequiredSignatures"), gt(1, "numReadonlySignedAccounts"), gt(1, "numReadonlyUnsignedAccounts"), gt(r.length, "keyCount"), Tr(Ve("key"), t, "keys"), Ve("recentBlockhash")])
          , u = {
            numRequiredSignatures: $e.Buffer.from([this.header.numRequiredSignatures]),
            numReadonlySignedAccounts: $e.Buffer.from([this.header.numReadonlySignedAccounts]),
            numReadonlyUnsignedAccounts: $e.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
            keyCount: $e.Buffer.from(r),
            keys: this.accountKeys.map(p => xm(p.toBytes())),
            recentBlockhash: Ar.decode(this.recentBlockhash)
        };
        let c = $e.Buffer.alloc(2048);
        const l = a.encode(u, c);
        return s.copy(c, l),
        c.slice(0, l + s.length)
    }
    static from(t) {
        let r = [...t];
        const n = ci(r);
        if (n !== (n & Em))
            throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        const i = ci(r)
          , s = ci(r)
          , o = Kr(r);
        let a = [];
        for (let h = 0; h < o; h++) {
            const g = Qr(r, 0, es);
            a.push(new Ne($e.Buffer.from(g)))
        }
        const u = Qr(r, 0, es)
          , c = Kr(r);
        let l = [];
        for (let h = 0; h < c; h++) {
            const g = ci(r)
              , S = Kr(r)
              , x = Qr(r, 0, S)
              , v = Kr(r)
              , I = Qr(r, 0, v)
              , M = Ar.encode($e.Buffer.from(I));
            l.push({
                programIdIndex: g,
                accounts: x,
                data: M
            })
        }
        const p = {
            header: {
                numRequiredSignatures: n,
                numReadonlySignedAccounts: i,
                numReadonlyUnsignedAccounts: s
            },
            recentBlockhash: Ar.encode($e.Buffer.from(u)),
            accountKeys: a,
            instructions: l
        };
        return new ea(p)
    }
}
class pf {
    constructor(t) {
        this.header = void 0,
        this.staticAccountKeys = void 0,
        this.recentBlockhash = void 0,
        this.compiledInstructions = void 0,
        this.addressTableLookups = void 0,
        this.header = t.header,
        this.staticAccountKeys = t.staticAccountKeys,
        this.recentBlockhash = t.recentBlockhash,
        this.compiledInstructions = t.compiledInstructions,
        this.addressTableLookups = t.addressTableLookups
    }
    get version() {
        return 0
    }
    get numAccountKeysFromLookups() {
        let t = 0;
        for (const r of this.addressTableLookups)
            t += r.readonlyIndexes.length + r.writableIndexes.length;
        return t
    }
    getAccountKeys(t) {
        let r;
        if (t && "accountKeysFromLookups"in t && t.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != t.accountKeysFromLookups.writable.length + t.accountKeysFromLookups.readonly.length)
                throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            r = t.accountKeysFromLookups
        } else if (t && "addressLookupTableAccounts"in t && t.addressLookupTableAccounts)
            r = this.resolveAddressTableLookups(t.addressLookupTableAccounts);
        else if (this.addressTableLookups.length > 0)
            throw new Error("Failed to get account keys because address table lookups were not resolved");
        return new hf(this.staticAccountKeys,r)
    }
    isAccountSigner(t) {
        return t < this.header.numRequiredSignatures
    }
    isAccountWritable(t) {
        const r = this.header.numRequiredSignatures
          , n = this.staticAccountKeys.length;
        if (t >= n) {
            const i = t - n
              , s = this.addressTableLookups.reduce( (o, a) => o + a.writableIndexes.length, 0);
            return i < s
        } else if (t >= this.header.numRequiredSignatures) {
            const i = t - r
              , o = n - r - this.header.numReadonlyUnsignedAccounts;
            return i < o
        } else {
            const i = r - this.header.numReadonlySignedAccounts;
            return t < i
        }
    }
    resolveAddressTableLookups(t) {
        const r = {
            writable: [],
            readonly: []
        };
        for (const n of this.addressTableLookups) {
            const i = t.find(s => s.key.equals(n.accountKey));
            if (!i)
                throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);
            for (const s of n.writableIndexes)
                if (s < i.state.addresses.length)
                    r.writable.push(i.state.addresses[s]);
                else
                    throw new Error(`Failed to find address for index ${s} in address lookup table ${n.accountKey.toBase58()}`);
            for (const s of n.readonlyIndexes)
                if (s < i.state.addresses.length)
                    r.readonly.push(i.state.addresses[s]);
                else
                    throw new Error(`Failed to find address for index ${s} in address lookup table ${n.accountKey.toBase58()}`)
        }
        return r
    }
    static compile(t) {
        const r = pd.compile(t.instructions, t.payerKey)
          , n = new Array
          , i = {
            writable: new Array,
            readonly: new Array
        }
          , s = t.addressLookupTableAccounts || [];
        for (const l of s) {
            const p = r.extractTableLookup(l);
            if (p !== void 0) {
                const [h,{writable: g, readonly: S}] = p;
                n.push(h),
                i.writable.push(...g),
                i.readonly.push(...S)
            }
        }
        const [o,a] = r.getMessageComponents()
          , c = new hf(a,i).compileInstructions(t.instructions);
        return new pf({
            header: o,
            staticAccountKeys: a,
            recentBlockhash: t.recentBlockhash,
            compiledInstructions: c,
            addressTableLookups: n
        })
    }
    serialize() {
        const t = Array();
        Gr(t, this.staticAccountKeys.length);
        const r = this.serializeInstructions()
          , n = Array();
        Gr(n, this.compiledInstructions.length);
        const i = this.serializeAddressTableLookups()
          , s = Array();
        Gr(s, this.addressTableLookups.length);
        const o = Te([Je("prefix"), Te([Je("numRequiredSignatures"), Je("numReadonlySignedAccounts"), Je("numReadonlyUnsignedAccounts")], "header"), gt(t.length, "staticAccountKeysLength"), Tr(Ve(), this.staticAccountKeys.length, "staticAccountKeys"), Ve("recentBlockhash"), gt(n.length, "instructionsLength"), gt(r.length, "serializedInstructions"), gt(s.length, "addressTableLookupsLength"), gt(i.length, "serializedAddressTableLookups")])
          , a = new Uint8Array(Io)
          , c = o.encode({
            prefix: 128,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(t),
            staticAccountKeys: this.staticAccountKeys.map(l => l.toBytes()),
            recentBlockhash: Ar.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(n),
            serializedInstructions: r,
            addressTableLookupsLength: new Uint8Array(s),
            serializedAddressTableLookups: i
        }, a);
        return a.slice(0, c)
    }
    serializeInstructions() {
        let t = 0;
        const r = new Uint8Array(Io);
        for (const n of this.compiledInstructions) {
            const i = Array();
            Gr(i, n.accountKeyIndexes.length);
            const s = Array();
            Gr(s, n.data.length);
            const o = Te([Je("programIdIndex"), gt(i.length, "encodedAccountKeyIndexesLength"), Tr(Je(), n.accountKeyIndexes.length, "accountKeyIndexes"), gt(s.length, "encodedDataLength"), gt(n.data.length, "data")]);
            t += o.encode({
                programIdIndex: n.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(i),
                accountKeyIndexes: n.accountKeyIndexes,
                encodedDataLength: new Uint8Array(s),
                data: n.data
            }, r, t)
        }
        return r.slice(0, t)
    }
    serializeAddressTableLookups() {
        let t = 0;
        const r = new Uint8Array(Io);
        for (const n of this.addressTableLookups) {
            const i = Array();
            Gr(i, n.writableIndexes.length);
            const s = Array();
            Gr(s, n.readonlyIndexes.length);
            const o = Te([Ve("accountKey"), gt(i.length, "encodedWritableIndexesLength"), Tr(Je(), n.writableIndexes.length, "writableIndexes"), gt(s.length, "encodedReadonlyIndexesLength"), Tr(Je(), n.readonlyIndexes.length, "readonlyIndexes")]);
            t += o.encode({
                accountKey: n.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(i),
                writableIndexes: n.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(s),
                readonlyIndexes: n.readonlyIndexes
            }, r, t)
        }
        return r.slice(0, t)
    }
    static deserialize(t) {
        let r = [...t];
        const n = ci(r)
          , i = n & Em;
        Gt(n !== i, "Expected versioned message but received legacy message");
        const s = i;
        Gt(s === 0, `Expected versioned message with version 0 but found version ${s}`);
        const o = {
            numRequiredSignatures: ci(r),
            numReadonlySignedAccounts: ci(r),
            numReadonlyUnsignedAccounts: ci(r)
        }
          , a = []
          , u = Kr(r);
        for (let S = 0; S < u; S++)
            a.push(new Ne(Qr(r, 0, es)));
        const c = Ar.encode(Qr(r, 0, es))
          , l = Kr(r)
          , p = [];
        for (let S = 0; S < l; S++) {
            const x = ci(r)
              , v = Kr(r)
              , I = Qr(r, 0, v)
              , M = Kr(r)
              , A = new Uint8Array(Qr(r, 0, M));
            p.push({
                programIdIndex: x,
                accountKeyIndexes: I,
                data: A
            })
        }
        const h = Kr(r)
          , g = [];
        for (let S = 0; S < h; S++) {
            const x = new Ne(Qr(r, 0, es))
              , v = Kr(r)
              , I = Qr(r, 0, v)
              , M = Kr(r)
              , A = Qr(r, 0, M);
            g.push({
                accountKey: x,
                writableIndexes: I,
                readonlyIndexes: A
            })
        }
        return new pf({
            header: o,
            staticAccountKeys: a,
            recentBlockhash: c,
            compiledInstructions: p,
            addressTableLookups: g
        })
    }
}
const Sm = {
    deserializeMessageVersion(e) {
        const t = e[0]
          , r = t & Em;
        return r === t ? "legacy" : r
    },
    deserialize: e => {
        const t = Sm.deserializeMessageVersion(e);
        if (t === "legacy")
            return ea.from(e);
        if (t === 0)
            return pf.deserialize(e);
        throw new Error(`Transaction message version ${t} deserialization is not supported`)
    }
}
  , $7 = $e.Buffer.alloc(Au).fill(0);
class Eb {
    constructor(t) {
        this.keys = void 0,
        this.programId = void 0,
        this.data = $e.Buffer.alloc(0),
        this.programId = t.programId,
        this.keys = t.keys,
        t.data && (this.data = t.data)
    }
    toJSON() {
        return {
            keys: this.keys.map( ({pubkey: t, isSigner: r, isWritable: n}) => ({
                pubkey: t.toJSON(),
                isSigner: r,
                isWritable: n
            })),
            programId: this.programId.toJSON(),
            data: [...this.data]
        }
    }
}
class ta {
    get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null
    }
    constructor(t) {
        if (this.signatures = [],
        this.feePayer = void 0,
        this.instructions = [],
        this.recentBlockhash = void 0,
        this.lastValidBlockHeight = void 0,
        this.nonceInfo = void 0,
        this.minNonceContextSlot = void 0,
        this._message = void 0,
        this._json = void 0,
        !!t)
            if (t.feePayer && (this.feePayer = t.feePayer),
            t.signatures && (this.signatures = t.signatures),
            Object.prototype.hasOwnProperty.call(t, "nonceInfo")) {
                const {minContextSlot: r, nonceInfo: n} = t;
                this.minNonceContextSlot = r,
                this.nonceInfo = n
            } else if (Object.prototype.hasOwnProperty.call(t, "lastValidBlockHeight")) {
                const {blockhash: r, lastValidBlockHeight: n} = t;
                this.recentBlockhash = r,
                this.lastValidBlockHeight = n
            } else {
                const {recentBlockhash: r, nonceInfo: n} = t;
                n && (this.nonceInfo = n),
                this.recentBlockhash = r
            }
    }
    toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
                nonce: this.nonceInfo.nonce,
                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map(t => t.toJSON()),
            signers: this.signatures.map( ({publicKey: t}) => t.toJSON())
        }
    }
    add(...t) {
        if (t.length === 0)
            throw new Error("No instructions");
        return t.forEach(r => {
            "instructions"in r ? this.instructions = this.instructions.concat(r.instructions) : "data"in r && "programId"in r && "keys"in r ? this.instructions.push(r) : this.instructions.push(new Eb(r))
        }
        ),
        this
    }
    compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
            return this._message;
        let t, r;
        if (this.nonceInfo ? (t = this.nonceInfo.nonce,
        this.instructions[0] != this.nonceInfo.nonceInstruction ? r = [this.nonceInfo.nonceInstruction, ...this.instructions] : r = this.instructions) : (t = this.recentBlockhash,
        r = this.instructions),
        !t)
            throw new Error("Transaction recentBlockhash required");
        r.length < 1 && console.warn("No instructions provided");
        let n;
        if (this.feePayer)
            n = this.feePayer;
        else if (this.signatures.length > 0 && this.signatures[0].publicKey)
            n = this.signatures[0].publicKey;
        else
            throw new Error("Transaction fee payer required");
        for (let x = 0; x < r.length; x++)
            if (r[x].programId === void 0)
                throw new Error(`Transaction instruction index ${x} has undefined program id`);
        const i = []
          , s = [];
        r.forEach(x => {
            x.keys.forEach(I => {
                s.push({
                    ...I
                })
            }
            );
            const v = x.programId.toString();
            i.includes(v) || i.push(v)
        }
        ),
        i.forEach(x => {
            s.push({
                pubkey: new Ne(x),
                isSigner: !1,
                isWritable: !1
            })
        }
        );
        const o = [];
        s.forEach(x => {
            const v = x.pubkey.toString()
              , I = o.findIndex(M => M.pubkey.toString() === v);
            I > -1 ? (o[I].isWritable = o[I].isWritable || x.isWritable,
            o[I].isSigner = o[I].isSigner || x.isSigner) : o.push(x)
        }
        ),
        o.sort(function(x, v) {
            if (x.isSigner !== v.isSigner)
                return x.isSigner ? -1 : 1;
            if (x.isWritable !== v.isWritable)
                return x.isWritable ? -1 : 1;
            const I = {
                localeMatcher: "best fit",
                usage: "sort",
                sensitivity: "variant",
                ignorePunctuation: !1,
                numeric: !1,
                caseFirst: "lower"
            };
            return x.pubkey.toBase58().localeCompare(v.pubkey.toBase58(), "en", I)
        });
        const a = o.findIndex(x => x.pubkey.equals(n));
        if (a > -1) {
            const [x] = o.splice(a, 1);
            x.isSigner = !0,
            x.isWritable = !0,
            o.unshift(x)
        } else
            o.unshift({
                pubkey: n,
                isSigner: !0,
                isWritable: !0
            });
        for (const x of this.signatures) {
            const v = o.findIndex(I => I.pubkey.equals(x.publicKey));
            if (v > -1)
                o[v].isSigner || (o[v].isSigner = !0,
                console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
            else
                throw new Error(`unknown signer: ${x.publicKey.toString()}`)
        }
        let u = 0
          , c = 0
          , l = 0;
        const p = []
          , h = [];
        o.forEach( ({pubkey: x, isSigner: v, isWritable: I}) => {
            v ? (p.push(x.toString()),
            u += 1,
            I || (c += 1)) : (h.push(x.toString()),
            I || (l += 1))
        }
        );
        const g = p.concat(h)
          , S = r.map(x => {
            const {data: v, programId: I} = x;
            return {
                programIdIndex: g.indexOf(I.toString()),
                accounts: x.keys.map(M => g.indexOf(M.pubkey.toString())),
                data: Ar.encode(v)
            }
        }
        );
        return S.forEach(x => {
            Gt(x.programIdIndex >= 0),
            x.accounts.forEach(v => Gt(v >= 0))
        }
        ),
        new ea({
            header: {
                numRequiredSignatures: u,
                numReadonlySignedAccounts: c,
                numReadonlyUnsignedAccounts: l
            },
            accountKeys: g,
            recentBlockhash: t,
            instructions: S
        })
    }
    _compile() {
        const t = this.compileMessage()
          , r = t.accountKeys.slice(0, t.header.numRequiredSignatures);
        return this.signatures.length === r.length && this.signatures.every( (i, s) => r[s].equals(i.publicKey)) || (this.signatures = r.map(n => ({
            signature: null,
            publicKey: n
        }))),
        t
    }
    serializeMessage() {
        return this._compile().serialize()
    }
    async getEstimatedFee(t) {
        return (await t.getFeeForMessage(this.compileMessage())).value
    }
    setSigners(...t) {
        if (t.length === 0)
            throw new Error("No signers");
        const r = new Set;
        this.signatures = t.filter(n => {
            const i = n.toString();
            return r.has(i) ? !1 : (r.add(i),
            !0)
        }
        ).map(n => ({
            signature: null,
            publicKey: n
        }))
    }
    sign(...t) {
        if (t.length === 0)
            throw new Error("No signers");
        const r = new Set
          , n = [];
        for (const s of t) {
            const o = s.publicKey.toString();
            r.has(o) || (r.add(o),
            n.push(s))
        }
        this.signatures = n.map(s => ({
            signature: null,
            publicKey: s.publicKey
        }));
        const i = this._compile();
        this._partialSign(i, ...n)
    }
    partialSign(...t) {
        if (t.length === 0)
            throw new Error("No signers");
        const r = new Set
          , n = [];
        for (const s of t) {
            const o = s.publicKey.toString();
            r.has(o) || (r.add(o),
            n.push(s))
        }
        const i = this._compile();
        this._partialSign(i, ...n)
    }
    _partialSign(t, ...r) {
        const n = t.serialize();
        r.forEach(i => {
            const s = M4(n, i.secretKey);
            this._addSignature(i.publicKey, xm(s))
        }
        )
    }
    addSignature(t, r) {
        this._compile(),
        this._addSignature(t, r)
    }
    _addSignature(t, r) {
        Gt(r.length === 64);
        const n = this.signatures.findIndex(i => t.equals(i.publicKey));
        if (n < 0)
            throw new Error(`unknown signer: ${t.toString()}`);
        this.signatures[n].signature = $e.Buffer.from(r)
    }
    verifySignatures(t=!0) {
        return !this._getMessageSignednessErrors(this.serializeMessage(), t)
    }
    _getMessageSignednessErrors(t, r) {
        const n = {};
        for (const {signature: i, publicKey: s} of this.signatures)
            i === null ? r && (n.missing || (n.missing = [])).push(s) : O7(i, t, s.toBytes()) || (n.invalid || (n.invalid = [])).push(s);
        return n.invalid || n.missing ? n : void 0
    }
    serialize(t) {
        const {requireAllSignatures: r, verifySignatures: n} = Object.assign({
            requireAllSignatures: !0,
            verifySignatures: !0
        }, t)
          , i = this.serializeMessage();
        if (n) {
            const s = this._getMessageSignednessErrors(i, r);
            if (s) {
                let o = "Signature verification failed.";
                throw s.invalid && (o += `
Invalid signature for public key${s.invalid.length === 1 ? "" : "(s)"} [\`${s.invalid.map(a => a.toBase58()).join("`, `")}\`].`),
                s.missing && (o += `
Missing signature for public key${s.missing.length === 1 ? "" : "(s)"} [\`${s.missing.map(a => a.toBase58()).join("`, `")}\`].`),
                new Error(o)
            }
        }
        return this._serialize(i)
    }
    _serialize(t) {
        const {signatures: r} = this
          , n = [];
        Gr(n, r.length);
        const i = n.length + r.length * 64 + t.length
          , s = $e.Buffer.alloc(i);
        return Gt(r.length < 256),
        $e.Buffer.from(n).copy(s, 0),
        r.forEach( ({signature: o}, a) => {
            o !== null && (Gt(o.length === 64, "signature has invalid length"),
            $e.Buffer.from(o).copy(s, n.length + a * 64))
        }
        ),
        t.copy(s, n.length + r.length * 64),
        Gt(s.length <= Io, `Transaction too large: ${s.length} > ${Io}`),
        s
    }
    get keys() {
        return Gt(this.instructions.length === 1),
        this.instructions[0].keys.map(t => t.pubkey)
    }
    get programId() {
        return Gt(this.instructions.length === 1),
        this.instructions[0].programId
    }
    get data() {
        return Gt(this.instructions.length === 1),
        this.instructions[0].data
    }
    static from(t) {
        let r = [...t];
        const n = Kr(r);
        let i = [];
        for (let s = 0; s < n; s++) {
            const o = Qr(r, 0, Au);
            i.push(Ar.encode($e.Buffer.from(o)))
        }
        return ta.populate(ea.from(r), i)
    }
    static populate(t, r=[]) {
        const n = new ta;
        return n.recentBlockhash = t.recentBlockhash,
        t.header.numRequiredSignatures > 0 && (n.feePayer = t.accountKeys[0]),
        r.forEach( (i, s) => {
            const o = {
                signature: i == Ar.encode($7) ? null : Ar.decode(i),
                publicKey: t.accountKeys[s]
            };
            n.signatures.push(o)
        }
        ),
        t.instructions.forEach(i => {
            const s = i.accounts.map(o => {
                const a = t.accountKeys[o];
                return {
                    pubkey: a,
                    isSigner: n.signatures.some(u => u.publicKey.toString() === a.toString()) || t.isAccountSigner(o),
                    isWritable: t.isAccountWritable(o)
                }
            }
            );
            n.instructions.push(new Eb({
                keys: s,
                programId: t.accountKeys[i.programIdIndex],
                data: Ar.decode(i.data)
            }))
        }
        ),
        n._message = t,
        n._json = n.toJSON(),
        n
    }
}
class Mu {
    get version() {
        return this.message.version
    }
    constructor(t, r) {
        if (this.signatures = void 0,
        this.message = void 0,
        r !== void 0)
            Gt(r.length === t.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"),
            this.signatures = r;
        else {
            const n = [];
            for (let i = 0; i < t.header.numRequiredSignatures; i++)
                n.push(new Uint8Array(Au));
            this.signatures = n
        }
        this.message = t
    }
    serialize() {
        const t = this.message.serialize()
          , r = Array();
        Gr(r, this.signatures.length);
        const n = Te([gt(r.length, "encodedSignaturesLength"), Tr(P7(), this.signatures.length, "signatures"), gt(t.length, "serializedMessage")])
          , i = new Uint8Array(2048)
          , s = n.encode({
            encodedSignaturesLength: new Uint8Array(r),
            signatures: this.signatures,
            serializedMessage: t
        }, i);
        return i.slice(0, s)
    }
    static deserialize(t) {
        let r = [...t];
        const n = []
          , i = Kr(r);
        for (let o = 0; o < i; o++)
            n.push(new Uint8Array(Qr(r, 0, Au)));
        const s = Sm.deserialize(new Uint8Array(r));
        return new Mu(s,n)
    }
    sign(t) {
        const r = this.message.serialize()
          , n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const i of t) {
            const s = n.findIndex(o => o.equals(i.publicKey));
            Gt(s >= 0, `Cannot sign with non signer key ${i.publicKey.toBase58()}`),
            this.signatures[s] = M4(r, i.secretKey)
        }
    }
    addSignature(t, r) {
        Gt(r.byteLength === 64, "Signature must be 64 bytes long");
        const i = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex(s => s.equals(t));
        Gt(i >= 0, `Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`),
        this.signatures[i] = r
    }
}
new Ne("SysvarC1ock11111111111111111111111111111111");
new Ne("SysvarEpochSchedu1e111111111111111111111111");
new Ne("Sysvar1nstructions1111111111111111111111111");
new Ne("SysvarRecentB1ockHashes11111111111111111111");
new Ne("SysvarRent111111111111111111111111111111111");
new Ne("SysvarRewards111111111111111111111111111111");
new Ne("SysvarS1otHashes111111111111111111111111111");
new Ne("SysvarS1otHistory11111111111111111111111111");
new Ne("SysvarStakeHistory1111111111111111111111111");
const F7 = sr("lamportsPerSignature")
  , H7 = Te([Le("version"), Le("state"), Ve("authorizedPubkey"), Ve("nonce"), Te([F7], "feeCalculator")]);
H7.span;
const q7 = e => {
    const t = e.decode.bind(e)
      , r = e.encode.bind(e);
    return {
        decode: t,
        encode: r
    }
}
  , W7 = e => t => {
    const r = gt(e, t)
      , {encode: n, decode: i} = q7(r)
      , s = r;
    return s.decode = (o, a) => {
        const u = i(o, a);
        return TR($e.Buffer.from(u))
    }
    ,
    s.encode = (o, a, u) => {
        const c = LR(o, e);
        return n(c, a, u)
    }
    ,
    s
}
  , ra = W7(8);
Object.freeze({
    Create: {
        index: 0,
        layout: Te([Le("instruction"), Vr("lamports"), Vr("space"), Ve("programId")])
    },
    Assign: {
        index: 1,
        layout: Te([Le("instruction"), Ve("programId")])
    },
    Transfer: {
        index: 2,
        layout: Te([Le("instruction"), ra("lamports")])
    },
    CreateWithSeed: {
        index: 3,
        layout: Te([Le("instruction"), Ve("base"), go("seed"), Vr("lamports"), Vr("space"), Ve("programId")])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: Te([Le("instruction")])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: Te([Le("instruction"), Vr("lamports")])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: Te([Le("instruction"), Ve("authorized")])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: Te([Le("instruction"), Ve("authorized")])
    },
    Allocate: {
        index: 8,
        layout: Te([Le("instruction"), Vr("space")])
    },
    AllocateWithSeed: {
        index: 9,
        layout: Te([Le("instruction"), Ve("base"), go("seed"), Vr("space"), Ve("programId")])
    },
    AssignWithSeed: {
        index: 10,
        layout: Te([Le("instruction"), Ve("base"), go("seed"), Ve("programId")])
    },
    TransferWithSeed: {
        index: 11,
        layout: Te([Le("instruction"), ra("lamports"), go("seed"), Ve("programId")])
    },
    UpgradeNonceAccount: {
        index: 12,
        layout: Te([Le("instruction")])
    }
});
new Ne("11111111111111111111111111111111");
new Ne("BPFLoader2111111111111111111111111111111111");
Te([Le("typeIndex"), ra("deactivationSlot"), sr("lastExtendedSlot"), Je("lastExtendedStartIndex"), Je(), Tr(Ve(), Us(Je(), -1), "authority")]);
const Jt = pc(bm(Ne), be(), e => new Ne(e))
  , C4 = wm([be(), Et("base64")])
  , _m = pc(bm($e.Buffer), C4, e => $e.Buffer.from(e[0], "base64"));
function k4(e) {
    return jr([fe({
        jsonrpc: Et("2.0"),
        id: be(),
        result: e
    }), fe({
        jsonrpc: Et("2.0"),
        id: be(),
        error: fe({
            code: hc(),
            message: be(),
            data: Re(UR())
        })
    })])
}
const V7 = k4(hc());
function ft(e) {
    return pc(k4(e), V7, t => "error"in t ? t : {
        ...t,
        result: _u(t.result, e)
    })
}
function yn(e) {
    return ft(fe({
        context: fe({
            slot: Z()
        }),
        value: e
    }))
}
function gd(e) {
    return fe({
        context: fe({
            slot: Z()
        }),
        value: e
    })
}
const K7 = fe({
    foundation: Z(),
    foundationTerm: Z(),
    initial: Z(),
    taper: Z(),
    terminal: Z()
});
ft(Ie(Me(fe({
    epoch: Z(),
    effectiveSlot: Z(),
    amount: Z(),
    postBalance: Z(),
    commission: Re(Me(Z()))
}))));
const G7 = Ie(fe({
    slot: Z(),
    prioritizationFee: Z()
}))
  , Q7 = fe({
    total: Z(),
    validator: Z(),
    foundation: Z(),
    epoch: Z()
})
  , Y7 = fe({
    epoch: Z(),
    slotIndex: Z(),
    slotsInEpoch: Z(),
    absoluteSlot: Z(),
    blockHeight: Re(Z()),
    transactionCount: Re(Z())
})
  , Z7 = fe({
    slotsPerEpoch: Z(),
    leaderScheduleSlotOffset: Z(),
    warmup: Wn(),
    firstNormalEpoch: Z(),
    firstNormalSlot: Z()
})
  , J7 = g4(be(), Ie(Z()))
  , no = Me(jr([fe({}), be()]))
  , X7 = fe({
    err: no
})
  , eB = Et("receivedSignature");
fe({
    "solana-core": be(),
    "feature-set": Re(Z())
});
yn(fe({
    err: Me(jr([fe({}), be()])),
    logs: Me(Ie(be())),
    accounts: Re(Me(Ie(Me(fe({
        executable: Wn(),
        owner: be(),
        lamports: Z(),
        data: Ie(be()),
        rentEpoch: Re(Z())
    }))))),
    unitsConsumed: Re(Z()),
    returnData: Re(Me(fe({
        programId: be(),
        data: wm([be(), Et("base64")])
    })))
}));
yn(fe({
    byIdentity: g4(be(), Ie(Z())),
    range: fe({
        firstSlot: Z(),
        lastSlot: Z()
    })
}));
ft(K7);
ft(Q7);
ft(G7);
ft(Y7);
ft(Z7);
ft(J7);
ft(Z());
yn(fe({
    total: Z(),
    circulating: Z(),
    nonCirculating: Z(),
    nonCirculatingAccounts: Ie(Jt)
}));
const tB = fe({
    amount: be(),
    uiAmount: Me(Z()),
    decimals: Z(),
    uiAmountString: Re(be())
});
yn(Ie(fe({
    address: Jt,
    amount: be(),
    uiAmount: Me(Z()),
    decimals: Z(),
    uiAmountString: Re(be())
})));
yn(Ie(fe({
    pubkey: Jt,
    account: fe({
        executable: Wn(),
        owner: Jt,
        lamports: Z(),
        data: _m,
        rentEpoch: Z()
    })
})));
const dp = fe({
    program: be(),
    parsed: hc(),
    space: Z()
});
yn(Ie(fe({
    pubkey: Jt,
    account: fe({
        executable: Wn(),
        owner: Jt,
        lamports: Z(),
        data: dp,
        rentEpoch: Z()
    })
})));
yn(Ie(fe({
    lamports: Z(),
    address: Jt
})));
const Am = fe({
    executable: Wn(),
    owner: Jt,
    lamports: Z(),
    data: _m,
    rentEpoch: Z()
});
fe({
    pubkey: Jt,
    account: Am
});
const rB = pc(jr([bm($e.Buffer), dp]), jr([C4, dp]), e => Array.isArray(e) ? _u(e, _m) : e)
  , nB = fe({
    executable: Wn(),
    owner: Jt,
    lamports: Z(),
    data: rB,
    rentEpoch: Z()
});
fe({
    pubkey: Jt,
    account: nB
});
fe({
    state: jr([Et("active"), Et("inactive"), Et("activating"), Et("deactivating")]),
    active: Z(),
    inactive: Z()
});
ft(Ie(fe({
    signature: be(),
    slot: Z(),
    err: no,
    memo: Me(be()),
    blockTime: Re(Me(Z()))
})));
ft(Ie(fe({
    signature: be(),
    slot: Z(),
    err: no,
    memo: Me(be()),
    blockTime: Re(Me(Z()))
})));
fe({
    subscription: Z(),
    result: gd(Am)
});
const iB = fe({
    pubkey: Jt,
    account: Am
});
fe({
    subscription: Z(),
    result: gd(iB)
});
const sB = fe({
    parent: Z(),
    slot: Z(),
    root: Z()
});
fe({
    subscription: Z(),
    result: sB
});
const oB = jr([fe({
    type: jr([Et("firstShredReceived"), Et("completed"), Et("optimisticConfirmation"), Et("root")]),
    slot: Z(),
    timestamp: Z()
}), fe({
    type: Et("createdBank"),
    parent: Z(),
    slot: Z(),
    timestamp: Z()
}), fe({
    type: Et("frozen"),
    slot: Z(),
    timestamp: Z(),
    stats: fe({
        numTransactionEntries: Z(),
        numSuccessfulTransactions: Z(),
        numFailedTransactions: Z(),
        maxTransactionsPerEntry: Z()
    })
}), fe({
    type: Et("dead"),
    slot: Z(),
    timestamp: Z(),
    err: be()
})]);
fe({
    subscription: Z(),
    result: oB
});
fe({
    subscription: Z(),
    result: gd(jr([X7, eB]))
});
fe({
    subscription: Z(),
    result: Z()
});
fe({
    pubkey: be(),
    gossip: Me(be()),
    tpu: Me(be()),
    rpc: Me(be()),
    version: Me(be())
});
const Sb = fe({
    votePubkey: be(),
    nodePubkey: be(),
    activatedStake: Z(),
    epochVoteAccount: Wn(),
    epochCredits: Ie(wm([Z(), Z(), Z()])),
    commission: Z(),
    lastVote: Z(),
    rootSlot: Me(Z())
});
ft(fe({
    current: Ie(Sb),
    delinquent: Ie(Sb)
}));
const aB = jr([Et("processed"), Et("confirmed"), Et("finalized")])
  , uB = fe({
    slot: Z(),
    confirmations: Me(Z()),
    err: no,
    confirmationStatus: Re(aB)
});
yn(Ie(Me(uB)));
ft(Z());
const L4 = fe({
    accountKey: Jt,
    writableIndexes: Ie(Z()),
    readonlyIndexes: Ie(Z())
})
  , Mm = fe({
    signatures: Ie(be()),
    message: fe({
        accountKeys: Ie(be()),
        header: fe({
            numRequiredSignatures: Z(),
            numReadonlySignedAccounts: Z(),
            numReadonlyUnsignedAccounts: Z()
        }),
        instructions: Ie(fe({
            accounts: Ie(Z()),
            data: be(),
            programIdIndex: Z()
        })),
        recentBlockhash: be(),
        addressTableLookups: Re(Ie(L4))
    })
})
  , O4 = fe({
    pubkey: Jt,
    signer: Wn(),
    writable: Wn(),
    source: Re(jr([Et("transaction"), Et("lookupTable")]))
})
  , N4 = fe({
    accountKeys: Ie(O4),
    signatures: Ie(be())
})
  , R4 = fe({
    parsed: hc(),
    program: be(),
    programId: Jt
})
  , B4 = fe({
    accounts: Ie(Jt),
    data: be(),
    programId: Jt
})
  , cB = jr([B4, R4])
  , lB = jr([fe({
    parsed: hc(),
    program: be(),
    programId: be()
}), fe({
    accounts: Ie(be()),
    data: be(),
    programId: be()
})])
  , P4 = pc(cB, lB, e => "accounts"in e ? _u(e, B4) : _u(e, R4))
  , j4 = fe({
    signatures: Ie(be()),
    message: fe({
        accountKeys: Ie(O4),
        instructions: Ie(P4),
        recentBlockhash: be(),
        addressTableLookups: Re(Me(Ie(L4)))
    })
})
  , gf = fe({
    accountIndex: Z(),
    mint: be(),
    owner: Re(be()),
    uiTokenAmount: tB
})
  , D4 = fe({
    writable: Ie(Jt),
    readonly: Ie(Jt)
})
  , md = fe({
    err: no,
    fee: Z(),
    innerInstructions: Re(Me(Ie(fe({
        index: Z(),
        instructions: Ie(fe({
            accounts: Ie(Z()),
            data: be(),
            programIdIndex: Z()
        }))
    })))),
    preBalances: Ie(Z()),
    postBalances: Ie(Z()),
    logMessages: Re(Me(Ie(be()))),
    preTokenBalances: Re(Me(Ie(gf))),
    postTokenBalances: Re(Me(Ie(gf))),
    loadedAddresses: Re(D4),
    computeUnitsConsumed: Re(Z())
})
  , Im = fe({
    err: no,
    fee: Z(),
    innerInstructions: Re(Me(Ie(fe({
        index: Z(),
        instructions: Ie(P4)
    })))),
    preBalances: Ie(Z()),
    postBalances: Ie(Z()),
    logMessages: Re(Me(Ie(be()))),
    preTokenBalances: Re(Me(Ie(gf))),
    postTokenBalances: Re(Me(Ie(gf))),
    loadedAddresses: Re(D4),
    computeUnitsConsumed: Re(Z())
})
  , ba = jr([Et(0), Et("legacy")])
  , io = fe({
    pubkey: be(),
    lamports: Z(),
    postBalance: Me(Z()),
    rewardType: Me(be()),
    commission: Re(Me(Z()))
});
ft(Me(fe({
    blockhash: be(),
    previousBlockhash: be(),
    parentSlot: Z(),
    transactions: Ie(fe({
        transaction: Mm,
        meta: Me(md),
        version: Re(ba)
    })),
    rewards: Re(Ie(io)),
    blockTime: Me(Z()),
    blockHeight: Me(Z())
})));
ft(Me(fe({
    blockhash: be(),
    previousBlockhash: be(),
    parentSlot: Z(),
    rewards: Re(Ie(io)),
    blockTime: Me(Z()),
    blockHeight: Me(Z())
})));
ft(Me(fe({
    blockhash: be(),
    previousBlockhash: be(),
    parentSlot: Z(),
    transactions: Ie(fe({
        transaction: N4,
        meta: Me(md),
        version: Re(ba)
    })),
    rewards: Re(Ie(io)),
    blockTime: Me(Z()),
    blockHeight: Me(Z())
})));
ft(Me(fe({
    blockhash: be(),
    previousBlockhash: be(),
    parentSlot: Z(),
    transactions: Ie(fe({
        transaction: j4,
        meta: Me(Im),
        version: Re(ba)
    })),
    rewards: Re(Ie(io)),
    blockTime: Me(Z()),
    blockHeight: Me(Z())
})));
ft(Me(fe({
    blockhash: be(),
    previousBlockhash: be(),
    parentSlot: Z(),
    transactions: Ie(fe({
        transaction: N4,
        meta: Me(Im),
        version: Re(ba)
    })),
    rewards: Re(Ie(io)),
    blockTime: Me(Z()),
    blockHeight: Me(Z())
})));
ft(Me(fe({
    blockhash: be(),
    previousBlockhash: be(),
    parentSlot: Z(),
    rewards: Re(Ie(io)),
    blockTime: Me(Z()),
    blockHeight: Me(Z())
})));
ft(Me(fe({
    blockhash: be(),
    previousBlockhash: be(),
    parentSlot: Z(),
    transactions: Ie(fe({
        transaction: Mm,
        meta: Me(md)
    })),
    rewards: Re(Ie(io)),
    blockTime: Me(Z())
})));
ft(Me(fe({
    blockhash: be(),
    previousBlockhash: be(),
    parentSlot: Z(),
    signatures: Ie(be()),
    blockTime: Me(Z())
})));
ft(Me(fe({
    slot: Z(),
    meta: Me(md),
    blockTime: Re(Me(Z())),
    transaction: Mm,
    version: Re(ba)
})));
ft(Me(fe({
    slot: Z(),
    transaction: j4,
    meta: Me(Im),
    blockTime: Re(Me(Z())),
    version: Re(ba)
})));
yn(fe({
    blockhash: be(),
    feeCalculator: fe({
        lamportsPerSignature: Z()
    })
}));
yn(fe({
    blockhash: be(),
    lastValidBlockHeight: Z()
}));
yn(Wn());
const fB = fe({
    slot: Z(),
    numTransactions: Z(),
    numSlots: Z(),
    samplePeriodSecs: Z()
});
ft(Ie(fB));
yn(Me(fe({
    feeCalculator: fe({
        lamportsPerSignature: Z()
    })
})));
ft(be());
ft(be());
const dB = fe({
    err: no,
    logs: Ie(be()),
    signature: be()
});
fe({
    result: gd(dB),
    subscription: Z()
});
Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: Te([Le("instruction"), ra("recentSlot"), Je("bumpSeed")])
    },
    FreezeLookupTable: {
        index: 1,
        layout: Te([Le("instruction")])
    },
    ExtendLookupTable: {
        index: 2,
        layout: Te([Le("instruction"), ra(), Tr(Ve(), Us(Le(), -8), "addresses")])
    },
    DeactivateLookupTable: {
        index: 3,
        layout: Te([Le("instruction")])
    },
    CloseLookupTable: {
        index: 4,
        layout: Te([Le("instruction")])
    }
});
new Ne("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
    RequestUnits: {
        index: 0,
        layout: Te([Je("instruction"), Le("units"), Le("additionalFee")])
    },
    RequestHeapFrame: {
        index: 1,
        layout: Te([Je("instruction"), Le("bytes")])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: Te([Je("instruction"), Le("units")])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: Te([Je("instruction"), ra("microLamports")])
    }
});
new Ne("ComputeBudget111111111111111111111111111111");
Te([Je("numSignatures"), Je("padding"), on("signatureOffset"), on("signatureInstructionIndex"), on("publicKeyOffset"), on("publicKeyInstructionIndex"), on("messageDataOffset"), on("messageDataSize"), on("messageInstructionIndex")]);
new Ne("Ed25519SigVerify111111111111111111111111111");
vm.utils.isValidPrivateKey;
vm.getPublicKey;
Te([Je("numSignatures"), on("signatureOffset"), Je("signatureInstructionIndex"), on("ethAddressOffset"), Je("ethAddressInstructionIndex"), on("messageDataOffset"), on("messageDataSize"), Je("messageInstructionIndex"), gt(20, "ethAddress"), gt(64, "signature"), Je("recoveryId")]);
new Ne("KeccakSecp256k11111111111111111111111111111");
var U4;
new Ne("StakeConfig11111111111111111111111111111111");
class z4 {
    constructor(t, r, n) {
        this.unixTimestamp = void 0,
        this.epoch = void 0,
        this.custodian = void 0,
        this.unixTimestamp = t,
        this.epoch = r,
        this.custodian = n
    }
}
U4 = z4;
z4.default = new U4(0,0,Ne.default);
Object.freeze({
    Initialize: {
        index: 0,
        layout: Te([Le("instruction"), j7(), D7()])
    },
    Authorize: {
        index: 1,
        layout: Te([Le("instruction"), Ve("newAuthorized"), Le("stakeAuthorizationType")])
    },
    Delegate: {
        index: 2,
        layout: Te([Le("instruction")])
    },
    Split: {
        index: 3,
        layout: Te([Le("instruction"), Vr("lamports")])
    },
    Withdraw: {
        index: 4,
        layout: Te([Le("instruction"), Vr("lamports")])
    },
    Deactivate: {
        index: 5,
        layout: Te([Le("instruction")])
    },
    Merge: {
        index: 7,
        layout: Te([Le("instruction")])
    },
    AuthorizeWithSeed: {
        index: 8,
        layout: Te([Le("instruction"), Ve("newAuthorized"), Le("stakeAuthorizationType"), go("authoritySeed"), Ve("authorityOwner")])
    }
});
new Ne("Stake11111111111111111111111111111111111111");
Object.freeze({
    InitializeAccount: {
        index: 0,
        layout: Te([Le("instruction"), U7()])
    },
    Authorize: {
        index: 1,
        layout: Te([Le("instruction"), Ve("newAuthorized"), Le("voteAuthorizationType")])
    },
    Withdraw: {
        index: 3,
        layout: Te([Le("instruction"), Vr("lamports")])
    },
    UpdateValidatorIdentity: {
        index: 4,
        layout: Te([Le("instruction")])
    },
    AuthorizeWithSeed: {
        index: 10,
        layout: Te([Le("instruction"), z7()])
    }
});
new Ne("Vote111111111111111111111111111111111111111");
new Ne("Va1idator1nfo111111111111111111111111111111");
fe({
    name: be(),
    website: Re(be()),
    details: Re(be()),
    keybaseUsername: Re(be())
});
new Ne("Vote111111111111111111111111111111111111111");
Te([Ve("nodePubkey"), Ve("authorizedWithdrawer"), Je("commission"), sr(), Tr(Te([sr("slot"), Le("confirmationCount")]), Us(Le(), -8), "votes"), Je("rootSlotValid"), sr("rootSlot"), sr(), Tr(Te([sr("epoch"), Ve("authorizedVoter")]), Us(Le(), -8), "authorizedVoters"), Te([Tr(Te([Ve("authorizedPubkey"), sr("epochOfLastAuthorizedSwitch"), sr("targetEpoch")]), 32, "buf"), sr("idx"), Je("isEmpty")], "priorVoters"), sr(), Tr(Te([sr("epoch"), sr("credits"), sr("prevCredits")]), Us(Le(), -8), "epochCredits"), Te([sr("slot"), sr("timestamp")], "lastTimestamp")]);
var _b;
const $4 = typeof window < "u"
  , hB = e => typeof e == "function"
  , pB = e => typeof e == "string"
  , gB = () => {}
;
$4 && ((_b = window == null ? void 0 : window.navigator) != null && _b.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Tm(e) {
    return typeof e == "function" ? e() : ct(e)
}
function mB(e, t) {
    function r(...n) {
        return new Promise( (i, s) => {
            Promise.resolve(e( () => t.apply(this, n), {
                fn: t,
                thisArg: this,
                args: n
            })).then(i).catch(s)
        }
        )
    }
    return r
}
const F4 = e => e();
function yB(e=F4) {
    const t = Ue(!0);
    function r() {
        t.value = !1
    }
    function n() {
        t.value = !0
    }
    const i = (...s) => {
        t.value && e(...s)
    }
    ;
    return {
        isActive: Yu(t),
        pause: r,
        resume: n,
        eventFilter: i
    }
}
function bB(e) {
    return e
}
function wB(e) {
    return If() ? (Kp(e),
    !0) : !1
}
var Ab = Object.getOwnPropertySymbols
  , vB = Object.prototype.hasOwnProperty
  , xB = Object.prototype.propertyIsEnumerable
  , EB = (e, t) => {
    var r = {};
    for (var n in e)
        vB.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
    if (e != null && Ab)
        for (var n of Ab(e))
            t.indexOf(n) < 0 && xB.call(e, n) && (r[n] = e[n]);
    return r
}
;
function SB(e, t, r={}) {
    const n = r
      , {eventFilter: i=F4} = n
      , s = EB(n, ["eventFilter"]);
    return vt(e, mB(i, t), s)
}
var _B = Object.defineProperty
  , AB = Object.defineProperties
  , MB = Object.getOwnPropertyDescriptors
  , mf = Object.getOwnPropertySymbols
  , H4 = Object.prototype.hasOwnProperty
  , q4 = Object.prototype.propertyIsEnumerable
  , Mb = (e, t, r) => t in e ? _B(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r
  , IB = (e, t) => {
    for (var r in t || (t = {}))
        H4.call(t, r) && Mb(e, r, t[r]);
    if (mf)
        for (var r of mf(t))
            q4.call(t, r) && Mb(e, r, t[r]);
    return e
}
  , TB = (e, t) => AB(e, MB(t))
  , CB = (e, t) => {
    var r = {};
    for (var n in e)
        H4.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
    if (e != null && mf)
        for (var n of mf(e))
            t.indexOf(n) < 0 && q4.call(e, n) && (r[n] = e[n]);
    return r
}
;
function kB(e, t, r={}) {
    const n = r
      , {eventFilter: i} = n
      , s = CB(n, ["eventFilter"])
      , {eventFilter: o, pause: a, resume: u, isActive: c} = yB(i);
    return {
        stop: SB(e, t, TB(IB({}, s), {
            eventFilter: o
        })),
        pause: a,
        resume: u,
        isActive: c
    }
}
function LB(e) {
    var t;
    const r = Tm(e);
    return (t = r == null ? void 0 : r.$el) != null ? t : r
}
const yf = $4 ? window : void 0;
function Ib(...e) {
    let t, r, n, i;
    if (pB(e[0]) || Array.isArray(e[0]) ? ([r,n,i] = e,
    t = yf) : [t,r,n,i] = e,
    !t)
        return gB;
    Array.isArray(r) || (r = [r]),
    Array.isArray(n) || (n = [n]);
    const s = []
      , o = () => {
        s.forEach(l => l()),
        s.length = 0
    }
      , a = (l, p, h, g) => (l.addEventListener(p, h, g),
    () => l.removeEventListener(p, h, g))
      , u = vt( () => [LB(t), Tm(i)], ([l,p]) => {
        o(),
        l && s.push(...r.flatMap(h => n.map(g => a(l, h, g, p))))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , c = () => {
        u(),
        o()
    }
    ;
    return wB(c),
    c
}
const hp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , pp = "__vueuse_ssr_handlers__";
hp[pp] = hp[pp] || {};
const OB = hp[pp];
function NB(e, t) {
    return OB[e] || t
}
function RB(e) {
    return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number"
}
var BB = Object.defineProperty
  , Tb = Object.getOwnPropertySymbols
  , PB = Object.prototype.hasOwnProperty
  , jB = Object.prototype.propertyIsEnumerable
  , Cb = (e, t, r) => t in e ? BB(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r
  , kb = (e, t) => {
    for (var r in t || (t = {}))
        PB.call(t, r) && Cb(e, r, t[r]);
    if (Tb)
        for (var r of Tb(t))
            jB.call(t, r) && Cb(e, r, t[r]);
    return e
}
;
const DB = {
    boolean: {
        read: e => e === "true",
        write: e => String(e)
    },
    object: {
        read: e => JSON.parse(e),
        write: e => JSON.stringify(e)
    },
    number: {
        read: e => Number.parseFloat(e),
        write: e => String(e)
    },
    any: {
        read: e => e,
        write: e => String(e)
    },
    string: {
        read: e => e,
        write: e => String(e)
    },
    map: {
        read: e => new Map(JSON.parse(e)),
        write: e => JSON.stringify(Array.from(e.entries()))
    },
    set: {
        read: e => new Set(JSON.parse(e)),
        write: e => JSON.stringify(Array.from(e))
    },
    date: {
        read: e => new Date(e),
        write: e => e.toISOString()
    }
}
  , Lb = "vueuse-storage";
function UB(e, t, r, n={}) {
    var i;
    const {flush: s="pre", deep: o=!0, listenToStorageChanges: a=!0, writeDefaults: u=!0, mergeDefaults: c=!1, shallow: l, window: p=yf, eventFilter: h, onError: g=D => {
        console.error(D)
    }
    } = n
      , S = (l ? Pr : Ue)(t);
    if (!r)
        try {
            r = NB("getDefaultStorage", () => {
                var D;
                return (D = yf) == null ? void 0 : D.localStorage
            }
            )()
        } catch (D) {
            g(D)
        }
    if (!r)
        return S;
    const x = Tm(t)
      , v = RB(x)
      , I = (i = n.serializer) != null ? i : DB[v]
      , {pause: M, resume: A} = kB(S, () => k(S.value), {
        flush: s,
        deep: o,
        eventFilter: h
    });
    return p && a && (Ib(p, "storage", $),
    Ib(p, Lb, O)),
    $(),
    S;
    function k(D) {
        try {
            if (D == null)
                r.removeItem(e);
            else {
                const K = I.write(D)
                  , G = r.getItem(e);
                G !== K && (r.setItem(e, K),
                p && p.dispatchEvent(new CustomEvent(Lb,{
                    detail: {
                        key: e,
                        oldValue: G,
                        newValue: K,
                        storageArea: r
                    }
                })))
            }
        } catch (K) {
            g(K)
        }
    }
    function L(D) {
        const K = D ? D.newValue : r.getItem(e);
        if (K == null)
            return u && x !== null && r.setItem(e, I.write(x)),
            x;
        if (!D && c) {
            const G = I.read(K);
            return hB(c) ? c(G, x) : v === "object" && !Array.isArray(G) ? kb(kb({}, x), G) : G
        } else
            return typeof K != "string" ? K : I.read(K)
    }
    function O(D) {
        $(D.detail)
    }
    function $(D) {
        if (!(D && D.storageArea !== r)) {
            if (D && D.key == null) {
                S.value = x;
                return
            }
            if (!(D && D.key !== e)) {
                M();
                try {
                    S.value = L(D)
                } catch (K) {
                    g(K)
                } finally {
                    D ? Kn(A) : A()
                }
            }
        }
    }
}
function zB(e, t, r={}) {
    const {window: n=yf} = r;
    return UB(e, t, n == null ? void 0 : n.localStorage, r)
}
var Ob;
(function(e) {
    e.UP = "UP",
    e.RIGHT = "RIGHT",
    e.DOWN = "DOWN",
    e.LEFT = "LEFT",
    e.NONE = "NONE"
}
)(Ob || (Ob = {}));
var $B = Object.defineProperty
  , Nb = Object.getOwnPropertySymbols
  , FB = Object.prototype.hasOwnProperty
  , HB = Object.prototype.propertyIsEnumerable
  , Rb = (e, t, r) => t in e ? $B(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r
  , qB = (e, t) => {
    for (var r in t || (t = {}))
        FB.call(t, r) && Rb(e, r, t[r]);
    if (Nb)
        for (var r of Nb(t))
            HB.call(t, r) && Rb(e, r, t[r]);
    return e
}
;
const WB = {
    easeInSine: [.12, 0, .39, 0],
    easeOutSine: [.61, 1, .88, 1],
    easeInOutSine: [.37, 0, .63, 1],
    easeInQuad: [.11, 0, .5, 0],
    easeOutQuad: [.5, 1, .89, 1],
    easeInOutQuad: [.45, 0, .55, 1],
    easeInCubic: [.32, 0, .67, 0],
    easeOutCubic: [.33, 1, .68, 1],
    easeInOutCubic: [.65, 0, .35, 1],
    easeInQuart: [.5, 0, .75, 0],
    easeOutQuart: [.25, 1, .5, 1],
    easeInOutQuart: [.76, 0, .24, 1],
    easeInQuint: [.64, 0, .78, 0],
    easeOutQuint: [.22, 1, .36, 1],
    easeInOutQuint: [.83, 0, .17, 1],
    easeInExpo: [.7, 0, .84, 0],
    easeOutExpo: [.16, 1, .3, 1],
    easeInOutExpo: [.87, 0, .13, 1],
    easeInCirc: [.55, 0, 1, .45],
    easeOutCirc: [0, .55, .45, 1],
    easeInOutCirc: [.85, 0, .15, 1],
    easeInBack: [.36, 0, .66, -.56],
    easeOutBack: [.34, 1.56, .64, 1],
    easeInOutBack: [.68, -.6, .32, 1.6]
};
qB({
    linear: bB
}, WB);
var VB = Object.defineProperty
  , KB = (e, t, r) => t in e ? VB(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r
  , W4 = (e, t, r) => (KB(e, typeof t != "symbol" ? t + "" : t, r),
r);
class V4 extends nr {
    constructor() {
        super(...arguments),
        W4(this, "name", "WalletNotSelectedError")
    }
}
class GB extends nr {
    constructor() {
        super(...arguments),
        W4(this, "name", "WalletNotSelectedError")
    }
}
const is = {
    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
    ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
    ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
    ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
    ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
    ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND"
};
class ss extends Error {
    constructor(...t) {
        const [r,n,i] = t;
        super(n),
        this.code = r,
        this.data = i,
        this.name = "SolanaMobileWalletAdapterError"
    }
}
class K4 extends Error {
    constructor(...t) {
        const [r,n,i,s] = t;
        super(i),
        this.code = n,
        this.data = s,
        this.jsonRpcMessageId = r,
        this.name = "SolanaMobileWalletAdapterProtocolError"
    }
}
function Jr(e, t, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        }
        )
    }
    return new (r || (r = Promise))(function(s, o) {
        function a(l) {
            try {
                c(n.next(l))
            } catch (p) {
                o(p)
            }
        }
        function u(l) {
            try {
                c(n.throw(l))
            } catch (p) {
                o(p)
            }
        }
        function c(l) {
            l.done ? s(l.value) : i(l.value).then(a, u)
        }
        c((n = n.apply(e, t || [])).next())
    }
    )
}
function QB(e, t) {
    return Jr(this, void 0, void 0, function*() {
        const r = yield crypto.subtle.exportKey("raw", e)
          , n = yield crypto.subtle.sign({
            hash: "SHA-256",
            name: "ECDSA"
        }, t, r)
          , i = new Uint8Array(r.byteLength + n.byteLength);
        return i.set(new Uint8Array(r), 0),
        i.set(new Uint8Array(n), r.byteLength),
        i
    })
}
const mo = 4;
function YB(e) {
    if (e >= 4294967296)
        throw new Error("Outbound sequence number overflow. The maximum sequence number is 32-bytes.");
    const t = new ArrayBuffer(mo);
    return new DataView(t).setUint32(0, e, !1),
    new Uint8Array(t)
}
function ZB() {
    return Jr(this, void 0, void 0, function*() {
        return yield crypto.subtle.generateKey({
            name: "ECDSA",
            namedCurve: "P-256"
        }, !1, ["sign"])
    })
}
function JB() {
    return Jr(this, void 0, void 0, function*() {
        return yield crypto.subtle.generateKey({
            name: "ECDH",
            namedCurve: "P-256"
        }, !1, ["deriveKey", "deriveBits"])
    })
}
const gp = 12;
function XB(e, t) {
    return Jr(this, void 0, void 0, function*() {
        const r = JSON.stringify(e)
          , n = YB(e.id)
          , i = new Uint8Array(gp);
        crypto.getRandomValues(i);
        const s = yield crypto.subtle.encrypt(G4(n, i), t, new TextEncoder().encode(r))
          , o = new Uint8Array(n.byteLength + i.byteLength + s.byteLength);
        return o.set(new Uint8Array(n), 0),
        o.set(new Uint8Array(i), n.byteLength),
        o.set(new Uint8Array(s), n.byteLength + i.byteLength),
        o
    })
}
function eP(e, t) {
    return Jr(this, void 0, void 0, function*() {
        const r = e.slice(0, mo)
          , n = e.slice(mo, mo + gp)
          , i = e.slice(mo + gp)
          , s = yield crypto.subtle.decrypt(G4(r, n), t, i)
          , o = tP().decode(s)
          , a = JSON.parse(o);
        if (Object.hasOwnProperty.call(a, "error"))
            throw new K4(a.id,a.error.code,a.error.message);
        return a
    })
}
function G4(e, t) {
    return {
        additionalData: e,
        iv: t,
        name: "AES-GCM",
        tagLength: 128
    }
}
let N0;
function tP() {
    return N0 === void 0 && (N0 = new TextDecoder("utf-8")),
    N0
}
function rP(e, t, r) {
    return Jr(this, void 0, void 0, function*() {
        const [n,i] = yield Promise.all([crypto.subtle.exportKey("raw", t), crypto.subtle.importKey("raw", e, {
            name: "ECDH",
            namedCurve: "P-256"
        }, !1, [])])
          , s = yield crypto.subtle.deriveBits({
            name: "ECDH",
            public: i
        }, r, 256)
          , o = yield crypto.subtle.importKey("raw", s, "HKDF", !1, ["deriveKey"]);
        return yield crypto.subtle.deriveKey({
            name: "HKDF",
            hash: "SHA-256",
            salt: new Uint8Array(n),
            info: new Uint8Array
        }, o, {
            name: "AES-GCM",
            length: 128
        }, !1, ["encrypt", "decrypt"])
    })
}
function nP() {
    return Q4(49152 + Math.floor(Math.random() * 16384))
}
function Q4(e) {
    if (e < 49152 || e > 65535)
        throw new ss(is.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE,`Association port number must be between 49152 and 65535. ${e} given.`,{
            port: e
        });
    return e
}
function iP(e) {
    let t = "";
    const r = new Uint8Array(e)
      , n = r.byteLength;
    for (let i = 0; i < n; i++)
        t += String.fromCharCode(r[i]);
    return window.btoa(t)
}
function sP(e) {
    return e.replace(/[/+=]/g, t => ({
        "/": "_",
        "+": "-",
        "=": "."
    })[t])
}
const oP = "solana-wallet";
function Bb(e) {
    return e.replace(/(^\/+|\/+$)/g, "").split("/")
}
function aP(e, t) {
    let r = null;
    if (t) {
        try {
            r = new URL(t)
        } catch {}
        if ((r == null ? void 0 : r.protocol) !== "https:")
            throw new ss(is.ERROR_FORBIDDEN_WALLET_BASE_URL,"Base URLs supplied by wallets must be valid `https` URLs")
    }
    r || (r = new URL(`${oP}:/`));
    const n = e.startsWith("/") ? e : [...Bb(r.pathname), ...Bb(e)].join("/");
    return new URL(n,r)
}
function uP(e, t, r) {
    return Jr(this, void 0, void 0, function*() {
        const n = Q4(t)
          , i = yield crypto.subtle.exportKey("raw", e)
          , s = iP(i)
          , o = aP("v1/associate/local", r);
        return o.searchParams.set("association", sP(s)),
        o.searchParams.set("port", `${n}`),
        o
    })
}
const bf = {
    Firefox: 0,
    Other: 1
};
function cP() {
    return navigator.userAgent.indexOf("Firefox/") !== -1 ? bf.Firefox : bf.Other
}
function lP() {
    return new Promise( (e, t) => {
        function r() {
            clearTimeout(i),
            window.removeEventListener("blur", n)
        }
        function n() {
            r(),
            e()
        }
        window.addEventListener("blur", n);
        const i = setTimeout( () => {
            r(),
            t()
        }
        , 2e3)
    }
    )
}
let ka = null;
function fP(e) {
    ka == null && (ka = document.createElement("iframe"),
    ka.style.display = "none",
    document.body.appendChild(ka)),
    ka.contentWindow.location.href = e.toString()
}
function dP(e, t) {
    return Jr(this, void 0, void 0, function*() {
        const r = nP()
          , n = yield uP(e, r, t);
        if (n.protocol === "https:")
            window.location.assign(n);
        else
            try {
                const i = cP();
                switch (i) {
                case bf.Firefox:
                    fP(n);
                    break;
                case bf.Other:
                    {
                        const s = lP();
                        window.location.assign(n),
                        yield s;
                        break
                    }
                default:
                }
            } catch {
                throw new ss(is.ERROR_WALLET_NOT_FOUND,"Found no installed wallet that supports the mobile wallet protocol.")
            }
        return r
    })
}
const Pb = {
    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3],
    timeoutMs: 3e4
}
  , hP = "com.solana.mobilewalletadapter.v1";
function pP() {
    if (typeof window > "u" || window.isSecureContext !== !0)
        throw new ss(is.ERROR_SECURE_CONTEXT_REQUIRED,"The mobile wallet adapter protocol must be used in a secure context (`https`).")
}
function gP(e) {
    let t;
    try {
        t = new URL(e)
    } catch {
        throw new ss(is.ERROR_FORBIDDEN_WALLET_BASE_URL,"Invalid base URL supplied by wallet")
    }
    if (t.protocol !== "https:")
        throw new ss(is.ERROR_FORBIDDEN_WALLET_BASE_URL,"Base URLs supplied by wallets must be valid `https` URLs")
}
function mP(e) {
    return new DataView(e).getUint32(0, !1)
}
function yP(e, t) {
    return Jr(this, void 0, void 0, function*() {
        pP();
        const r = yield ZB()
          , n = yield dP(r.publicKey, t == null ? void 0 : t.baseUri)
          , i = `ws://localhost:${n}/solana-wallet`;
        let s;
        const o = ( () => {
            const l = [...Pb.retryDelayScheduleMs];
            return () => l.length > 1 ? l.shift() : l[0]
        }
        )();
        let a = 1
          , u = 0
          , c = {
            __type: "disconnected"
        };
        return new Promise( (l, p) => {
            let h;
            const g = {}
              , S = () => Jr(this, void 0, void 0, function*() {
                if (c.__type !== "connecting") {
                    console.warn(`Expected adapter state to be \`connecting\` at the moment the websocket opens. Got \`${c.__type}\`.`);
                    return
                }
                const {associationKeypair: L} = c;
                h.removeEventListener("open", S);
                const O = yield JB();
                h.send(yield QB(O.publicKey, L.privateKey)),
                c = {
                    __type: "hello_req_sent",
                    associationPublicKey: L.publicKey,
                    ecdhPrivateKey: O.privateKey
                }
            })
              , x = L => {
                L.wasClean ? c = {
                    __type: "disconnected"
                } : p(new ss(is.ERROR_SESSION_CLOSED,`The wallet session dropped unexpectedly (${L.code}: ${L.reason}).`,{
                    closeEvent: L
                })),
                M()
            }
              , v = L => Jr(this, void 0, void 0, function*() {
                M(),
                Date.now() - s >= Pb.timeoutMs ? p(new ss(is.ERROR_SESSION_TIMEOUT,`Failed to connect to the wallet websocket on port ${n}.`)) : (yield new Promise(O => {
                    const $ = o();
                    A = window.setTimeout(O, $)
                }
                ),
                k())
            })
              , I = L => Jr(this, void 0, void 0, function*() {
                const O = yield L.data.arrayBuffer();
                switch (c.__type) {
                case "connected":
                    try {
                        const $ = O.slice(0, mo)
                          , D = mP($);
                        if (D !== u + 1)
                            throw new Error("Encrypted message has invalid sequence number");
                        u = D;
                        const K = yield eP(O, c.sharedSecret)
                          , G = g[K.id];
                        delete g[K.id],
                        G.resolve(K.result)
                    } catch ($) {
                        if ($ instanceof K4) {
                            const D = g[$.jsonRpcMessageId];
                            delete g[$.jsonRpcMessageId],
                            D.reject($)
                        } else
                            throw $
                    }
                    break;
                case "hello_req_sent":
                    {
                        const $ = yield rP(O, c.associationPublicKey, c.ecdhPrivateKey);
                        c = {
                            __type: "connected",
                            sharedSecret: $
                        };
                        const D = new Proxy({},{
                            get(K, G) {
                                if (K[G] == null) {
                                    const F = G.toString().replace(/[A-Z]/g, q => `_${q.toLowerCase()}`).toLowerCase();
                                    K[G] = function(q) {
                                        return Jr(this, void 0, void 0, function*() {
                                            const B = a++;
                                            return h.send(yield XB({
                                                id: B,
                                                jsonrpc: "2.0",
                                                method: F,
                                                params: q ?? {}
                                            }, $)),
                                            new Promise( (y, b) => {
                                                g[B] = {
                                                    resolve(_) {
                                                        switch (G) {
                                                        case "authorize":
                                                        case "reauthorize":
                                                            {
                                                                const {wallet_uri_base: T} = _;
                                                                if (T != null)
                                                                    try {
                                                                        gP(T)
                                                                    } catch (C) {
                                                                        b(C);
                                                                        return
                                                                    }
                                                                break
                                                            }
                                                        }
                                                        y(_)
                                                    },
                                                    reject: b
                                                }
                                            }
                                            )
                                        })
                                    }
                                }
                                return K[G]
                            },
                            defineProperty() {
                                return !1
                            },
                            deleteProperty() {
                                return !1
                            }
                        });
                        try {
                            l(yield e(D))
                        } catch (K) {
                            p(K)
                        } finally {
                            M(),
                            h.close()
                        }
                        break
                    }
                }
            });
            let M, A;
            const k = () => {
                M && M(),
                c = {
                    __type: "connecting",
                    associationKeypair: r
                },
                s === void 0 && (s = Date.now()),
                h = new WebSocket(i,[hP]),
                h.addEventListener("open", S),
                h.addEventListener("close", x),
                h.addEventListener("error", v),
                h.addEventListener("message", I),
                M = () => {
                    window.clearTimeout(A),
                    h.removeEventListener("open", S),
                    h.removeEventListener("close", x),
                    h.removeEventListener("error", v),
                    h.removeEventListener("message", I)
                }
            }
            ;
            k()
        }
        )
    })
}
function bP(e) {
    if (e.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
        t[r] = 255;
    for (var n = 0; n < e.length; n++) {
        var i = e.charAt(n)
          , s = i.charCodeAt(0);
        if (t[s] !== 255)
            throw new TypeError(i + " is ambiguous");
        t[s] = n
    }
    var o = e.length
      , a = e.charAt(0)
      , u = Math.log(o) / Math.log(256)
      , c = Math.log(256) / Math.log(o);
    function l(g) {
        if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer,g.byteOffset,g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))),
        !(g instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (g.length === 0)
            return "";
        for (var S = 0, x = 0, v = 0, I = g.length; v !== I && g[v] === 0; )
            v++,
            S++;
        for (var M = (I - v) * c + 1 >>> 0, A = new Uint8Array(M); v !== I; ) {
            for (var k = g[v], L = 0, O = M - 1; (k !== 0 || L < x) && O !== -1; O--,
            L++)
                k += 256 * A[O] >>> 0,
                A[O] = k % o >>> 0,
                k = k / o >>> 0;
            if (k !== 0)
                throw new Error("Non-zero carry");
            x = L,
            v++
        }
        for (var $ = M - x; $ !== M && A[$] === 0; )
            $++;
        for (var D = a.repeat(S); $ < M; ++$)
            D += e.charAt(A[$]);
        return D
    }
    function p(g) {
        if (typeof g != "string")
            throw new TypeError("Expected String");
        if (g.length === 0)
            return new Uint8Array;
        for (var S = 0, x = 0, v = 0; g[S] === a; )
            x++,
            S++;
        for (var I = (g.length - S) * u + 1 >>> 0, M = new Uint8Array(I); g[S]; ) {
            var A = t[g.charCodeAt(S)];
            if (A === 255)
                return;
            for (var k = 0, L = I - 1; (A !== 0 || k < v) && L !== -1; L--,
            k++)
                A += o * M[L] >>> 0,
                M[L] = A % 256 >>> 0,
                A = A / 256 >>> 0;
            if (A !== 0)
                throw new Error("Non-zero carry");
            v = k,
            S++
        }
        for (var O = I - v; O !== I && M[O] === 0; )
            O++;
        for (var $ = new Uint8Array(x + (I - O)), D = x; O !== I; )
            $[D++] = M[O++];
        return $
    }
    function h(g) {
        var S = p(g);
        if (S)
            return S;
        throw new Error("Non-base" + o + " character")
    }
    return {
        encode: l,
        decodeUnsafe: p,
        decode: h
    }
}
var wP = bP;
const vP = wP
  , xP = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var EP = vP(xP);
function R0(e, t) {
    var r = {};
    for (var n in e)
        Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
            t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
    return r
}
function Zc(e, t, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        }
        )
    }
    return new (r || (r = Promise))(function(s, o) {
        function a(l) {
            try {
                c(n.next(l))
            } catch (p) {
                o(p)
            }
        }
        function u(l) {
            try {
                c(n.throw(l))
            } catch (p) {
                o(p)
            }
        }
        function c(l) {
            l.done ? s(l.value) : i(l.value).then(a, u)
        }
        c((n = n.apply(e, t || [])).next())
    }
    )
}
function Y4(e) {
    return window.btoa(String.fromCharCode.call(null, ...e))
}
function B0(e) {
    return new Uint8Array(window.atob(e).split("").map(t => t.charCodeAt(0)))
}
function jb(e) {
    const t = "version"in e ? e.serialize() : e.serialize({
        requireAllSignatures: !1,
        verifySignatures: !1
    });
    return Y4(t)
}
function SP(e) {
    const r = e[0] * Au + 1;
    return Sm.deserializeMessageVersion(e.slice(r, e.length)) === "legacy" ? ta.from(e) : Mu.deserialize(e)
}
function _P(e, t) {
    return Zc(this, void 0, void 0, function*() {
        return yield yP(n => {
            const i = new Proxy({},{
                get(s, o) {
                    if (s[o] == null)
                        switch (o) {
                        case "signAndSendTransactions":
                            s[o] = function(a) {
                                var {minContextSlot: u, transactions: c} = a
                                  , l = R0(a, ["minContextSlot", "transactions"]);
                                return Zc(this, void 0, void 0, function*() {
                                    const p = c.map(jb)
                                      , {signatures: h} = yield n.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, l), u != null ? {
                                        options: {
                                            min_context_slot: u
                                        }
                                    } : null), {
                                        payloads: p
                                    }));
                                    return h.map(B0).map(EP.encode)
                                })
                            }
                            ;
                            break;
                        case "signMessages":
                            s[o] = function(a) {
                                var {payloads: u} = a
                                  , c = R0(a, ["payloads"]);
                                return Zc(this, void 0, void 0, function*() {
                                    const l = u.map(Y4)
                                      , {signed_payloads: p} = yield n.signMessages(Object.assign(Object.assign({}, c), {
                                        payloads: l
                                    }));
                                    return p.map(B0)
                                })
                            }
                            ;
                            break;
                        case "signTransactions":
                            s[o] = function(a) {
                                var {transactions: u} = a
                                  , c = R0(a, ["transactions"]);
                                return Zc(this, void 0, void 0, function*() {
                                    const l = u.map(jb)
                                      , {signed_payloads: p} = yield n.signTransactions(Object.assign(Object.assign({}, c), {
                                        payloads: l
                                    }));
                                    return p.map(B0).map(SP)
                                })
                            }
                            ;
                            break;
                        default:
                            {
                                s[o] = n[o];
                                break
                            }
                        }
                    return s[o]
                },
                defineProperty() {
                    return !1
                },
                deleteProperty() {
                    return !1
                }
            });
            return e(i)
        }
        , t)
    })
}
function tt(e, t, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        }
        )
    }
    return new (r || (r = Promise))(function(s, o) {
        function a(l) {
            try {
                c(n.next(l))
            } catch (p) {
                o(p)
            }
        }
        function u(l) {
            try {
                c(n.throw(l))
            } catch (p) {
                o(p)
            }
        }
        function c(l) {
            l.done ? s(l.value) : i(l.value).then(a, u)
        }
        c((n = n.apply(e, t || [])).next())
    }
    )
}
function AP(e) {
    return new Uint8Array(window.atob(e).split("").map(t => t.charCodeAt(0)))
}
function MP() {
    return typeof window < "u" && window.isSecureContext && typeof document < "u" && /android/i.test(navigator.userAgent)
}
const na = "Mobile Wallet Adapter"
  , IP = 64;
function TP(e) {
    const t = AP(e);
    return new Ne(t)
}
function Db(e) {
    return "version"in e
}
class CP extends Zg {
    constructor(t) {
        super(),
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this.name = na,
        this.url = "https://solanamobile.com/wallets",
        this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==",
        this._connecting = !1,
        this._connectionGeneration = 0,
        this._readyState = MP() ? Qe.Loadable : Qe.Unsupported,
        this._authorizationResultCache = t.authorizationResultCache,
        this._addressSelector = t.addressSelector,
        this._appIdentity = t.appIdentity,
        this._cluster = t.cluster,
        this._onWalletNotFound = t.onWalletNotFound,
        this._readyState !== Qe.Unsupported && this._authorizationResultCache.get().then(r => {
            r && this.declareWalletAsInstalled()
        }
        )
    }
    get publicKey() {
        if (this._publicKey == null && this._selectedAddress != null)
            try {
                this._publicKey = TP(this._selectedAddress)
            } catch (t) {
                throw new Ws(t instanceof Error && (t == null ? void 0 : t.message) || "Unknown error",t)
            }
        return this._publicKey ? this._publicKey : null
    }
    get connected() {
        return !!this._authorizationResult
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    declareWalletAsInstalled() {
        this._readyState !== Qe.Installed && this.emit("readyStateChange", this._readyState = Qe.Installed)
    }
    runWithGuard(t) {
        return tt(this, void 0, void 0, function*() {
            try {
                return yield t()
            } catch (r) {
                throw this.emit("error", r),
                r
            }
        })
    }
    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
        return tt(this, void 0, void 0, function*() {
            return yield this.autoConnect()
        })
    }
    autoConnect() {
        return tt(this, void 0, void 0, function*() {
            if (!(this.connecting || this.connected))
                return yield this.runWithGuard( () => tt(this, void 0, void 0, function*() {
                    if (this._readyState !== Qe.Installed && this._readyState !== Qe.Loadable)
                        throw new qs;
                    this._connecting = !0;
                    try {
                        const t = yield this._authorizationResultCache.get();
                        t && this.handleAuthorizationResult(t)
                    } catch (t) {
                        throw new Qo(t instanceof Error && t.message || "Unknown error",t)
                    } finally {
                        this._connecting = !1
                    }
                }))
        })
    }
    connect() {
        return tt(this, void 0, void 0, function*() {
            if (!(this.connecting || this.connected))
                return yield this.runWithGuard( () => tt(this, void 0, void 0, function*() {
                    if (this._readyState !== Qe.Installed && this._readyState !== Qe.Loadable)
                        throw new qs;
                    this._connecting = !0;
                    try {
                        const t = yield this._authorizationResultCache.get();
                        if (t) {
                            this.handleAuthorizationResult(t);
                            return
                        }
                        yield this.transact(r => tt(this, void 0, void 0, function*() {
                            const n = yield r.authorize({
                                cluster: this._cluster,
                                identity: this._appIdentity
                            });
                            Promise.all([this._authorizationResultCache.set(n), this.handleAuthorizationResult(n)])
                        }))
                    } catch (t) {
                        throw new Qo(t instanceof Error && t.message || "Unknown error",t)
                    } finally {
                        this._connecting = !1
                    }
                }))
        })
    }
    handleAuthorizationResult(t) {
        var r;
        return tt(this, void 0, void 0, function*() {
            const n = this._authorizationResult == null || ((r = this._authorizationResult) === null || r === void 0 ? void 0 : r.accounts.length) !== t.accounts.length || this._authorizationResult.accounts.some( (i, s) => i.address !== t.accounts[s].address);
            if (this._authorizationResult = t,
            this.declareWalletAsInstalled(),
            n) {
                const i = yield this._addressSelector.select(t.accounts.map( ({address: s}) => s));
                i !== this._selectedAddress && (this._selectedAddress = i,
                delete this._publicKey,
                this.emit("connect", this.publicKey))
            }
        })
    }
    performReauthorization(t, r) {
        return tt(this, void 0, void 0, function*() {
            try {
                const n = yield t.reauthorize({
                    auth_token: r
                });
                Promise.all([this._authorizationResultCache.set(n), this.handleAuthorizationResult(n)])
            } catch (n) {
                throw this.disconnect(),
                new id(n instanceof Error && (n == null ? void 0 : n.message) || "Unknown error",n)
            }
        })
    }
    disconnect() {
        return tt(this, void 0, void 0, function*() {
            this._authorizationResultCache.clear(),
            this._connecting = !1,
            this._connectionGeneration++,
            delete this._authorizationResult,
            delete this._publicKey,
            delete this._selectedAddress,
            this.emit("disconnect")
        })
    }
    transact(t) {
        var r;
        return tt(this, void 0, void 0, function*() {
            const n = (r = this._authorizationResult) === null || r === void 0 ? void 0 : r.wallet_uri_base
              , i = n ? {
                baseUri: n
            } : void 0
              , s = this._connectionGeneration;
            try {
                return yield _P(t, i)
            } catch (o) {
                throw this._connectionGeneration !== s && (yield new Promise( () => {}
                )),
                o instanceof Error && o.name === "SolanaMobileWalletAdapterError" && o.code === "ERROR_WALLET_NOT_FOUND" && (yield this._onWalletNotFound(this)),
                o
            }
        })
    }
    assertIsAuthorized() {
        if (!this._authorizationResult || !this._selectedAddress)
            throw new It;
        return {
            authToken: this._authorizationResult.auth_token,
            selectedAddress: this._selectedAddress
        }
    }
    performSignTransactions(t) {
        return tt(this, void 0, void 0, function*() {
            const {authToken: r} = this.assertIsAuthorized();
            try {
                return yield this.transact(n => tt(this, void 0, void 0, function*() {
                    return yield this.performReauthorization(n, r),
                    yield n.signTransactions({
                        transactions: t
                    })
                }))
            } catch (n) {
                throw new fn(n == null ? void 0 : n.message,n)
            }
        })
    }
    sendTransaction(t, r, n) {
        return tt(this, void 0, void 0, function*() {
            return yield this.runWithGuard( () => tt(this, void 0, void 0, function*() {
                const {authToken: i} = this.assertIsAuthorized()
                  , s = n == null ? void 0 : n.minContextSlot;
                try {
                    return yield this.transact(o => tt(this, void 0, void 0, function*() {
                        function a() {
                            let p;
                            switch (r.commitment) {
                            case "confirmed":
                            case "finalized":
                            case "processed":
                                p = r.commitment;
                                break;
                            default:
                                p = "finalized"
                            }
                            let h;
                            switch (n == null ? void 0 : n.preflightCommitment) {
                            case "confirmed":
                            case "finalized":
                            case "processed":
                                h = n.preflightCommitment;
                                break;
                            case void 0:
                                h = p;
                            default:
                                h = "finalized"
                            }
                            return (h === "finalized" ? 2 : h === "confirmed" ? 1 : 0) < (p === "finalized" ? 2 : p === "confirmed" ? 1 : 0) ? h : p
                        }
                        const [u,c,l] = yield Promise.all([o.getCapabilities(), this.performReauthorization(o, i), Db(t) ? null : tt(this, void 0, void 0, function*() {
                            var p;
                            if (t.feePayer || (t.feePayer = (p = this.publicKey) !== null && p !== void 0 ? p : void 0),
                            t.recentBlockhash == null) {
                                const {blockhash: h} = yield r.getLatestBlockhash({
                                    commitment: a()
                                });
                                t.recentBlockhash = h
                            }
                        })]);
                        if (u.supports_sign_and_send_transactions)
                            return (yield o.signAndSendTransactions({
                                minContextSlot: s,
                                transactions: [t]
                            }))[0];
                        {
                            const [p] = yield o.signTransactions({
                                transactions: [t]
                            });
                            if (Db(p))
                                return yield r.sendTransaction(p);
                            {
                                const h = p.serialize();
                                return yield r.sendRawTransaction(h, Object.assign(Object.assign({}, n), {
                                    preflightCommitment: a()
                                }))
                            }
                        }
                    }))
                } catch (o) {
                    throw new fi(o == null ? void 0 : o.message,o)
                }
            }))
        })
    }
    signTransaction(t) {
        return tt(this, void 0, void 0, function*() {
            return yield this.runWithGuard( () => tt(this, void 0, void 0, function*() {
                const [r] = yield this.performSignTransactions([t]);
                return r
            }))
        })
    }
    signAllTransactions(t) {
        return tt(this, void 0, void 0, function*() {
            return yield this.runWithGuard( () => tt(this, void 0, void 0, function*() {
                return yield this.performSignTransactions(t)
            }))
        })
    }
    signMessage(t) {
        return tt(this, void 0, void 0, function*() {
            return yield this.runWithGuard( () => tt(this, void 0, void 0, function*() {
                const {authToken: r, selectedAddress: n} = this.assertIsAuthorized();
                try {
                    return yield this.transact(i => tt(this, void 0, void 0, function*() {
                        yield this.performReauthorization(i, r);
                        const [s] = yield i.signMessages({
                            addresses: [n],
                            payloads: [t]
                        });
                        return s.slice(-IP)
                    }))
                } catch (i) {
                    throw new Eu(i == null ? void 0 : i.message,i)
                }
            }))
        })
    }
}
function kP() {
    return {
        select(e) {
            return tt(this, void 0, void 0, function*() {
                return e[0]
            })
        }
    }
}
const P0 = "SolanaMobileWalletAdapterDefaultAuthorizationCache";
function LP() {
    let e;
    try {
        e = window.localStorage
    } catch {}
    return {
        clear() {
            return tt(this, void 0, void 0, function*() {
                if (e)
                    try {
                        e.removeItem(P0)
                    } catch {}
            })
        },
        get() {
            return tt(this, void 0, void 0, function*() {
                if (e)
                    try {
                        return JSON.parse(e.getItem(P0)) || void 0
                    } catch {}
            })
        },
        set(t) {
            return tt(this, void 0, void 0, function*() {
                if (e)
                    try {
                        e.setItem(P0, JSON.stringify(t))
                    } catch {}
            })
        }
    }
}
function OP(e) {
    return tt(this, void 0, void 0, function*() {
        typeof window < "u" && window.location.assign(e.url)
    })
}
function NP() {
    return OP
}
function RP(e, t, r, n, i, s) {
    vt(e, (o, a) => {
        const u = o == null ? void 0 : o.adapter
          , c = a == null ? void 0 : a.adapter;
        !u || !c || u.name !== c.name && c.name !== na && c.disconnect()
    }
    ),
    Cn(o => {
        var a;
        const u = (a = e.value) == null ? void 0 : a.adapter;
        if (!u)
            return;
        const c = () => {
            i()
        }
          , l = () => {
            t.value || r.value || n(!0)
        }
          , p = h => s(h, u);
        u.on("connect", c),
        u.on("disconnect", l),
        u.on("error", p),
        o( () => {
            u.off("connect", c),
            u.off("disconnect", l),
            u.off("error", p)
        }
        )
    }
    )
}
function BP(e, t, r, n, i, s, o) {
    const a = Ue(e)
      , u = Ue(!1);
    return vt(t, () => {
        u.value = !1
    }
    ),
    Cn( () => {
        u.value || !a.value || !t.value || !s.value || i.value || n.value || (async () => {
            if (t.value) {
                n.value = !0,
                u.value = !0;
                try {
                    r.value ? await t.value.adapter.autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() : await t.value.adapter.connect()
                } catch {
                    o()
                } finally {
                    n.value = !1
                }
            }
        }
        )()
    }
    ),
    a
}
function PP(e) {
    const t = jP()
      , r = DP()
      , n = Se( () => UP(e.value, t))
      , i = Se( () => n.value === 1);
    return {
        userAgent: t,
        uriForAppIdentity: r,
        environment: n,
        isMobile: i
    }
}
let j0;
function jP() {
    var e, t;
    return j0 === void 0 && (j0 = (t = (e = globalThis.navigator) == null ? void 0 : e.userAgent) != null ? t : null),
    j0
}
function DP() {
    const e = globalThis.location;
    return e == null ? null : `${e.protocol}//${e.host}`
}
function UP(e, t) {
    return e.some(i => i.name !== na && i.readyState === Qe.Installed) ? 0 : t && zP(t) && !$P(t) ? 1 : 0
}
function zP(e) {
    return /android/i.test(e)
}
function $P(e) {
    return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(e)
}
function FP(e, t) {
    return (r, n) => e.value ? r : t ? (t(r, n),
    r) : (console.error(r, n),
    r instanceof qs && typeof window < "u" && n && window.open(n.url, "_blank"),
    r)
}
function HP(e, t, r, n) {
    const i = Se( () => {
        if (!t.value)
            return null;
        const s = e.value.find(o => o.name === na);
        return s || new CP({
            addressSelector: kP(),
            appIdentity: {
                uri: r || void 0
            },
            authorizationResultCache: LP(),
            cluster: n.value,
            onWalletNotFound: NP()
        })
    }
    );
    return Se( () => i.value == null || e.value.indexOf(i.value) !== -1 ? e.value : [i.value, ...e.value])
}
function qP(e) {
    Cn(t => {
        function r(n) {
            const i = e.value
              , s = i.findIndex( ({adapter: o}) => o === this);
            s !== -1 && (e.value = [...i.slice(0, s), {
                adapter: this,
                readyState: n
            }, ...i.slice(s + 1)])
        }
        e.value.forEach( ({adapter: n}) => n.on("readyStateChange", r, n)),
        t( () => e.value.forEach( ({adapter: n}) => n.off("readyStateChange", r, n)))
    }
    )
}
function WP(e, t) {
    const r = zB(e, t.value ? na : null)
      , n = Se( () => r.value === na)
      , i = Se( () => n.value && t.value);
    return {
        name: r,
        isUsingMwaAdapter: n,
        isUsingMwaAdapterOnMobile: i,
        select: a => {
            r.value !== a && (r.value = a)
        }
        ,
        deselect: (a=!0) => {
            (a || n.value) && (r.value = null)
        }
    }
}
function D0(e) {
    switch (e) {
    case "processed":
    case "confirmed":
    case "finalized":
    case void 0:
        return e;
    case "recent":
        return "processed";
    case "single":
    case "singleGossip":
        return "confirmed";
    case "max":
    case "root":
        return "finalized";
    default:
        return
    }
}
const Ub = "solana:mainnet"
  , VP = "solana:devnet"
  , KP = "solana:testnet"
  , GP = "solana:localnet"
  , QP = "https://api.mainnet-beta.solana.com";
function YP(e) {
    return e.includes(QP) ? Ub : /\bdevnet\b/i.test(e) ? VP : /\btestnet\b/i.test(e) ? KP : /\blocalhost\b/i.test(e) || /\b127\.0\.0\.1\b/.test(e) ? GP : Ub
}
function ZP(e, t) {
    if (e === t)
        return !0;
    const r = e.length;
    if (r !== t.length)
        return !1;
    for (let n = 0; n < r; n++)
        if (e[n] !== t[n])
            return !1;
    return !0
}
var mp = {
    exports: {}
}
  , Z4 = {}
  , yd = {};
yd.byteLength = ej;
yd.toByteArray = rj;
yd.fromByteArray = sj;
var Dn = []
  , rn = []
  , JP = typeof Uint8Array < "u" ? Uint8Array : Array
  , U0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var uo = 0, XP = U0.length; uo < XP; ++uo)
    Dn[uo] = U0[uo],
    rn[U0.charCodeAt(uo)] = uo;
rn[45] = 62;
rn[95] = 63;
function J4(e) {
    var t = e.length;
    if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var r = e.indexOf("=");
    r === -1 && (r = t);
    var n = r === t ? 0 : 4 - r % 4;
    return [r, n]
}
function ej(e) {
    var t = J4(e)
      , r = t[0]
      , n = t[1];
    return (r + n) * 3 / 4 - n
}
function tj(e, t, r) {
    return (t + r) * 3 / 4 - r
}
function rj(e) {
    var t, r = J4(e), n = r[0], i = r[1], s = new JP(tj(e, n, i)), o = 0, a = i > 0 ? n - 4 : n, u;
    for (u = 0; u < a; u += 4)
        t = rn[e.charCodeAt(u)] << 18 | rn[e.charCodeAt(u + 1)] << 12 | rn[e.charCodeAt(u + 2)] << 6 | rn[e.charCodeAt(u + 3)],
        s[o++] = t >> 16 & 255,
        s[o++] = t >> 8 & 255,
        s[o++] = t & 255;
    return i === 2 && (t = rn[e.charCodeAt(u)] << 2 | rn[e.charCodeAt(u + 1)] >> 4,
    s[o++] = t & 255),
    i === 1 && (t = rn[e.charCodeAt(u)] << 10 | rn[e.charCodeAt(u + 1)] << 4 | rn[e.charCodeAt(u + 2)] >> 2,
    s[o++] = t >> 8 & 255,
    s[o++] = t & 255),
    s
}
function nj(e) {
    return Dn[e >> 18 & 63] + Dn[e >> 12 & 63] + Dn[e >> 6 & 63] + Dn[e & 63]
}
function ij(e, t, r) {
    for (var n, i = [], s = t; s < r; s += 3)
        n = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255),
        i.push(nj(n));
    return i.join("")
}
function sj(e) {
    for (var t, r = e.length, n = r % 3, i = [], s = 16383, o = 0, a = r - n; o < a; o += s)
        i.push(ij(e, o, o + s > a ? a : o + s));
    return n === 1 ? (t = e[r - 1],
    i.push(Dn[t >> 2] + Dn[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1],
    i.push(Dn[t >> 10] + Dn[t >> 4 & 63] + Dn[t << 2 & 63] + "=")),
    i.join("")
}
var Cm = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Cm.read = function(e, t, r, n, i) {
    var s, o, a = i * 8 - n - 1, u = (1 << a) - 1, c = u >> 1, l = -7, p = r ? i - 1 : 0, h = r ? -1 : 1, g = e[t + p];
    for (p += h,
    s = g & (1 << -l) - 1,
    g >>= -l,
    l += a; l > 0; s = s * 256 + e[t + p],
    p += h,
    l -= 8)
        ;
    for (o = s & (1 << -l) - 1,
    s >>= -l,
    l += n; l > 0; o = o * 256 + e[t + p],
    p += h,
    l -= 8)
        ;
    if (s === 0)
        s = 1 - c;
    else {
        if (s === u)
            return o ? NaN : (g ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, n),
        s = s - c
    }
    return (g ? -1 : 1) * o * Math.pow(2, s - n)
}
;
Cm.write = function(e, t, r, n, i, s) {
    var o, a, u, c = s * 8 - i - 1, l = (1 << c) - 1, p = l >> 1, h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = n ? 0 : s - 1, S = n ? 1 : -1, x = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for (t = Math.abs(t),
    isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0,
    o = l) : (o = Math.floor(Math.log(t) / Math.LN2),
    t * (u = Math.pow(2, -o)) < 1 && (o--,
    u *= 2),
    o + p >= 1 ? t += h / u : t += h * Math.pow(2, 1 - p),
    t * u >= 2 && (o++,
    u /= 2),
    o + p >= l ? (a = 0,
    o = l) : o + p >= 1 ? (a = (t * u - 1) * Math.pow(2, i),
    o = o + p) : (a = t * Math.pow(2, p - 1) * Math.pow(2, i),
    o = 0)); i >= 8; e[r + g] = a & 255,
    g += S,
    a /= 256,
    i -= 8)
        ;
    for (o = o << i | a,
    c += i; c > 0; e[r + g] = o & 255,
    g += S,
    o /= 256,
    c -= 8)
        ;
    e[r + g - S] |= x * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
    const t = yd
      , r = Cm
      , n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = a,
    e.SlowBuffer = M,
    e.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    e.kMaxLength = i,
    a.TYPED_ARRAY_SUPPORT = s(),
    !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function s() {
        try {
            const m = new Uint8Array(1)
              , f = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(f, Uint8Array.prototype),
            Object.setPrototypeOf(m, f),
            m.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this))
                return this.byteOffset
        }
    });
    function o(m) {
        if (m > i)
            throw new RangeError('The value "' + m + '" is invalid for option "size"');
        const f = new Uint8Array(m);
        return Object.setPrototypeOf(f, a.prototype),
        f
    }
    function a(m, f, d) {
        if (typeof m == "number") {
            if (typeof f == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return p(m)
        }
        return u(m, f, d)
    }
    a.poolSize = 8192;
    function u(m, f, d) {
        if (typeof m == "string")
            return h(m, f);
        if (ArrayBuffer.isView(m))
            return S(m);
        if (m == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m);
        if (ne(m, ArrayBuffer) || m && ne(m.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ne(m, SharedArrayBuffer) || m && ne(m.buffer, SharedArrayBuffer)))
            return x(m, f, d);
        if (typeof m == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const E = m.valueOf && m.valueOf();
        if (E != null && E !== m)
            return a.from(E, f, d);
        const R = v(m);
        if (R)
            return R;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof m[Symbol.toPrimitive] == "function")
            return a.from(m[Symbol.toPrimitive]("string"), f, d);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m)
    }
    a.from = function(m, f, d) {
        return u(m, f, d)
    }
    ,
    Object.setPrototypeOf(a.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(a, Uint8Array);
    function c(m) {
        if (typeof m != "number")
            throw new TypeError('"size" argument must be of type number');
        if (m < 0)
            throw new RangeError('The value "' + m + '" is invalid for option "size"')
    }
    function l(m, f, d) {
        return c(m),
        m <= 0 ? o(m) : f !== void 0 ? typeof d == "string" ? o(m).fill(f, d) : o(m).fill(f) : o(m)
    }
    a.alloc = function(m, f, d) {
        return l(m, f, d)
    }
    ;
    function p(m) {
        return c(m),
        o(m < 0 ? 0 : I(m) | 0)
    }
    a.allocUnsafe = function(m) {
        return p(m)
    }
    ,
    a.allocUnsafeSlow = function(m) {
        return p(m)
    }
    ;
    function h(m, f) {
        if ((typeof f != "string" || f === "") && (f = "utf8"),
        !a.isEncoding(f))
            throw new TypeError("Unknown encoding: " + f);
        const d = A(m, f) | 0;
        let E = o(d);
        const R = E.write(m, f);
        return R !== d && (E = E.slice(0, R)),
        E
    }
    function g(m) {
        const f = m.length < 0 ? 0 : I(m.length) | 0
          , d = o(f);
        for (let E = 0; E < f; E += 1)
            d[E] = m[E] & 255;
        return d
    }
    function S(m) {
        if (ne(m, Uint8Array)) {
            const f = new Uint8Array(m);
            return x(f.buffer, f.byteOffset, f.byteLength)
        }
        return g(m)
    }
    function x(m, f, d) {
        if (f < 0 || m.byteLength < f)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (m.byteLength < f + (d || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let E;
        return f === void 0 && d === void 0 ? E = new Uint8Array(m) : d === void 0 ? E = new Uint8Array(m,f) : E = new Uint8Array(m,f,d),
        Object.setPrototypeOf(E, a.prototype),
        E
    }
    function v(m) {
        if (a.isBuffer(m)) {
            const f = I(m.length) | 0
              , d = o(f);
            return d.length === 0 || m.copy(d, 0, 0, f),
            d
        }
        if (m.length !== void 0)
            return typeof m.length != "number" || de(m.length) ? o(0) : g(m);
        if (m.type === "Buffer" && Array.isArray(m.data))
            return g(m.data)
    }
    function I(m) {
        if (m >= i)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return m | 0
    }
    function M(m) {
        return +m != m && (m = 0),
        a.alloc(+m)
    }
    a.isBuffer = function(f) {
        return f != null && f._isBuffer === !0 && f !== a.prototype
    }
    ,
    a.compare = function(f, d) {
        if (ne(f, Uint8Array) && (f = a.from(f, f.offset, f.byteLength)),
        ne(d, Uint8Array) && (d = a.from(d, d.offset, d.byteLength)),
        !a.isBuffer(f) || !a.isBuffer(d))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (f === d)
            return 0;
        let E = f.length
          , R = d.length;
        for (let j = 0, V = Math.min(E, R); j < V; ++j)
            if (f[j] !== d[j]) {
                E = f[j],
                R = d[j];
                break
            }
        return E < R ? -1 : R < E ? 1 : 0
    }
    ,
    a.isEncoding = function(f) {
        switch (String(f).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    a.concat = function(f, d) {
        if (!Array.isArray(f))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (f.length === 0)
            return a.alloc(0);
        let E;
        if (d === void 0)
            for (d = 0,
            E = 0; E < f.length; ++E)
                d += f[E].length;
        const R = a.allocUnsafe(d);
        let j = 0;
        for (E = 0; E < f.length; ++E) {
            let V = f[E];
            if (ne(V, Uint8Array))
                j + V.length > R.length ? (a.isBuffer(V) || (V = a.from(V)),
                V.copy(R, j)) : Uint8Array.prototype.set.call(R, V, j);
            else if (a.isBuffer(V))
                V.copy(R, j);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            j += V.length
        }
        return R
    }
    ;
    function A(m, f) {
        if (a.isBuffer(m))
            return m.length;
        if (ArrayBuffer.isView(m) || ne(m, ArrayBuffer))
            return m.byteLength;
        if (typeof m != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof m);
        const d = m.length
          , E = arguments.length > 2 && arguments[2] === !0;
        if (!E && d === 0)
            return 0;
        let R = !1;
        for (; ; )
            switch (f) {
            case "ascii":
            case "latin1":
            case "binary":
                return d;
            case "utf8":
            case "utf-8":
                return X(m).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return d * 2;
            case "hex":
                return d >>> 1;
            case "base64":
                return oe(m).length;
            default:
                if (R)
                    return E ? -1 : X(m).length;
                f = ("" + f).toLowerCase(),
                R = !0
            }
    }
    a.byteLength = A;
    function k(m, f, d) {
        let E = !1;
        if ((f === void 0 || f < 0) && (f = 0),
        f > this.length || ((d === void 0 || d > this.length) && (d = this.length),
        d <= 0) || (d >>>= 0,
        f >>>= 0,
        d <= f))
            return "";
        for (m || (m = "utf8"); ; )
            switch (m) {
            case "hex":
                return P(this, f, d);
            case "utf8":
            case "utf-8":
                return y(this, f, d);
            case "ascii":
                return T(this, f, d);
            case "latin1":
            case "binary":
                return C(this, f, d);
            case "base64":
                return B(this, f, d);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return W(this, f, d);
            default:
                if (E)
                    throw new TypeError("Unknown encoding: " + m);
                m = (m + "").toLowerCase(),
                E = !0
            }
    }
    a.prototype._isBuffer = !0;
    function L(m, f, d) {
        const E = m[f];
        m[f] = m[d],
        m[d] = E
    }
    a.prototype.swap16 = function() {
        const f = this.length;
        if (f % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let d = 0; d < f; d += 2)
            L(this, d, d + 1);
        return this
    }
    ,
    a.prototype.swap32 = function() {
        const f = this.length;
        if (f % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let d = 0; d < f; d += 4)
            L(this, d, d + 3),
            L(this, d + 1, d + 2);
        return this
    }
    ,
    a.prototype.swap64 = function() {
        const f = this.length;
        if (f % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let d = 0; d < f; d += 8)
            L(this, d, d + 7),
            L(this, d + 1, d + 6),
            L(this, d + 2, d + 5),
            L(this, d + 3, d + 4);
        return this
    }
    ,
    a.prototype.toString = function() {
        const f = this.length;
        return f === 0 ? "" : arguments.length === 0 ? y(this, 0, f) : k.apply(this, arguments)
    }
    ,
    a.prototype.toLocaleString = a.prototype.toString,
    a.prototype.equals = function(f) {
        if (!a.isBuffer(f))
            throw new TypeError("Argument must be a Buffer");
        return this === f ? !0 : a.compare(this, f) === 0
    }
    ,
    a.prototype.inspect = function() {
        let f = "";
        const d = e.INSPECT_MAX_BYTES;
        return f = this.toString("hex", 0, d).replace(/(.{2})/g, "$1 ").trim(),
        this.length > d && (f += " ... "),
        "<Buffer " + f + ">"
    }
    ,
    n && (a.prototype[n] = a.prototype.inspect),
    a.prototype.compare = function(f, d, E, R, j) {
        if (ne(f, Uint8Array) && (f = a.from(f, f.offset, f.byteLength)),
        !a.isBuffer(f))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof f);
        if (d === void 0 && (d = 0),
        E === void 0 && (E = f ? f.length : 0),
        R === void 0 && (R = 0),
        j === void 0 && (j = this.length),
        d < 0 || E > f.length || R < 0 || j > this.length)
            throw new RangeError("out of range index");
        if (R >= j && d >= E)
            return 0;
        if (R >= j)
            return -1;
        if (d >= E)
            return 1;
        if (d >>>= 0,
        E >>>= 0,
        R >>>= 0,
        j >>>= 0,
        this === f)
            return 0;
        let V = j - R
          , pe = E - d;
        const _e = Math.min(V, pe)
          , ge = this.slice(R, j)
          , Ce = f.slice(d, E);
        for (let we = 0; we < _e; ++we)
            if (ge[we] !== Ce[we]) {
                V = ge[we],
                pe = Ce[we];
                break
            }
        return V < pe ? -1 : pe < V ? 1 : 0
    }
    ;
    function O(m, f, d, E, R) {
        if (m.length === 0)
            return -1;
        if (typeof d == "string" ? (E = d,
        d = 0) : d > 2147483647 ? d = 2147483647 : d < -2147483648 && (d = -2147483648),
        d = +d,
        de(d) && (d = R ? 0 : m.length - 1),
        d < 0 && (d = m.length + d),
        d >= m.length) {
            if (R)
                return -1;
            d = m.length - 1
        } else if (d < 0)
            if (R)
                d = 0;
            else
                return -1;
        if (typeof f == "string" && (f = a.from(f, E)),
        a.isBuffer(f))
            return f.length === 0 ? -1 : $(m, f, d, E, R);
        if (typeof f == "number")
            return f = f & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? R ? Uint8Array.prototype.indexOf.call(m, f, d) : Uint8Array.prototype.lastIndexOf.call(m, f, d) : $(m, [f], d, E, R);
        throw new TypeError("val must be string, number or Buffer")
    }
    function $(m, f, d, E, R) {
        let j = 1
          , V = m.length
          , pe = f.length;
        if (E !== void 0 && (E = String(E).toLowerCase(),
        E === "ucs2" || E === "ucs-2" || E === "utf16le" || E === "utf-16le")) {
            if (m.length < 2 || f.length < 2)
                return -1;
            j = 2,
            V /= 2,
            pe /= 2,
            d /= 2
        }
        function _e(Ce, we) {
            return j === 1 ? Ce[we] : Ce.readUInt16BE(we * j)
        }
        let ge;
        if (R) {
            let Ce = -1;
            for (ge = d; ge < V; ge++)
                if (_e(m, ge) === _e(f, Ce === -1 ? 0 : ge - Ce)) {
                    if (Ce === -1 && (Ce = ge),
                    ge - Ce + 1 === pe)
                        return Ce * j
                } else
                    Ce !== -1 && (ge -= ge - Ce),
                    Ce = -1
        } else
            for (d + pe > V && (d = V - pe),
            ge = d; ge >= 0; ge--) {
                let Ce = !0;
                for (let we = 0; we < pe; we++)
                    if (_e(m, ge + we) !== _e(f, we)) {
                        Ce = !1;
                        break
                    }
                if (Ce)
                    return ge
            }
        return -1
    }
    a.prototype.includes = function(f, d, E) {
        return this.indexOf(f, d, E) !== -1
    }
    ,
    a.prototype.indexOf = function(f, d, E) {
        return O(this, f, d, E, !0)
    }
    ,
    a.prototype.lastIndexOf = function(f, d, E) {
        return O(this, f, d, E, !1)
    }
    ;
    function D(m, f, d, E) {
        d = Number(d) || 0;
        const R = m.length - d;
        E ? (E = Number(E),
        E > R && (E = R)) : E = R;
        const j = f.length;
        E > j / 2 && (E = j / 2);
        let V;
        for (V = 0; V < E; ++V) {
            const pe = parseInt(f.substr(V * 2, 2), 16);
            if (de(pe))
                return V;
            m[d + V] = pe
        }
        return V
    }
    function K(m, f, d, E) {
        return ae(X(f, m.length - d), m, d, E)
    }
    function G(m, f, d, E) {
        return ae(ce(f), m, d, E)
    }
    function F(m, f, d, E) {
        return ae(oe(f), m, d, E)
    }
    function q(m, f, d, E) {
        return ae(me(f, m.length - d), m, d, E)
    }
    a.prototype.write = function(f, d, E, R) {
        if (d === void 0)
            R = "utf8",
            E = this.length,
            d = 0;
        else if (E === void 0 && typeof d == "string")
            R = d,
            E = this.length,
            d = 0;
        else if (isFinite(d))
            d = d >>> 0,
            isFinite(E) ? (E = E >>> 0,
            R === void 0 && (R = "utf8")) : (R = E,
            E = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const j = this.length - d;
        if ((E === void 0 || E > j) && (E = j),
        f.length > 0 && (E < 0 || d < 0) || d > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        R || (R = "utf8");
        let V = !1;
        for (; ; )
            switch (R) {
            case "hex":
                return D(this, f, d, E);
            case "utf8":
            case "utf-8":
                return K(this, f, d, E);
            case "ascii":
            case "latin1":
            case "binary":
                return G(this, f, d, E);
            case "base64":
                return F(this, f, d, E);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return q(this, f, d, E);
            default:
                if (V)
                    throw new TypeError("Unknown encoding: " + R);
                R = ("" + R).toLowerCase(),
                V = !0
            }
    }
    ,
    a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function B(m, f, d) {
        return f === 0 && d === m.length ? t.fromByteArray(m) : t.fromByteArray(m.slice(f, d))
    }
    function y(m, f, d) {
        d = Math.min(m.length, d);
        const E = [];
        let R = f;
        for (; R < d; ) {
            const j = m[R];
            let V = null
              , pe = j > 239 ? 4 : j > 223 ? 3 : j > 191 ? 2 : 1;
            if (R + pe <= d) {
                let _e, ge, Ce, we;
                switch (pe) {
                case 1:
                    j < 128 && (V = j);
                    break;
                case 2:
                    _e = m[R + 1],
                    (_e & 192) === 128 && (we = (j & 31) << 6 | _e & 63,
                    we > 127 && (V = we));
                    break;
                case 3:
                    _e = m[R + 1],
                    ge = m[R + 2],
                    (_e & 192) === 128 && (ge & 192) === 128 && (we = (j & 15) << 12 | (_e & 63) << 6 | ge & 63,
                    we > 2047 && (we < 55296 || we > 57343) && (V = we));
                    break;
                case 4:
                    _e = m[R + 1],
                    ge = m[R + 2],
                    Ce = m[R + 3],
                    (_e & 192) === 128 && (ge & 192) === 128 && (Ce & 192) === 128 && (we = (j & 15) << 18 | (_e & 63) << 12 | (ge & 63) << 6 | Ce & 63,
                    we > 65535 && we < 1114112 && (V = we))
                }
            }
            V === null ? (V = 65533,
            pe = 1) : V > 65535 && (V -= 65536,
            E.push(V >>> 10 & 1023 | 55296),
            V = 56320 | V & 1023),
            E.push(V),
            R += pe
        }
        return _(E)
    }
    const b = 4096;
    function _(m) {
        const f = m.length;
        if (f <= b)
            return String.fromCharCode.apply(String, m);
        let d = ""
          , E = 0;
        for (; E < f; )
            d += String.fromCharCode.apply(String, m.slice(E, E += b));
        return d
    }
    function T(m, f, d) {
        let E = "";
        d = Math.min(m.length, d);
        for (let R = f; R < d; ++R)
            E += String.fromCharCode(m[R] & 127);
        return E
    }
    function C(m, f, d) {
        let E = "";
        d = Math.min(m.length, d);
        for (let R = f; R < d; ++R)
            E += String.fromCharCode(m[R]);
        return E
    }
    function P(m, f, d) {
        const E = m.length;
        (!f || f < 0) && (f = 0),
        (!d || d < 0 || d > E) && (d = E);
        let R = "";
        for (let j = f; j < d; ++j)
            R += ye[m[j]];
        return R
    }
    function W(m, f, d) {
        const E = m.slice(f, d);
        let R = "";
        for (let j = 0; j < E.length - 1; j += 2)
            R += String.fromCharCode(E[j] + E[j + 1] * 256);
        return R
    }
    a.prototype.slice = function(f, d) {
        const E = this.length;
        f = ~~f,
        d = d === void 0 ? E : ~~d,
        f < 0 ? (f += E,
        f < 0 && (f = 0)) : f > E && (f = E),
        d < 0 ? (d += E,
        d < 0 && (d = 0)) : d > E && (d = E),
        d < f && (d = f);
        const R = this.subarray(f, d);
        return Object.setPrototypeOf(R, a.prototype),
        R
    }
    ;
    function N(m, f, d) {
        if (m % 1 !== 0 || m < 0)
            throw new RangeError("offset is not uint");
        if (m + f > d)
            throw new RangeError("Trying to access beyond buffer length")
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(f, d, E) {
        f = f >>> 0,
        d = d >>> 0,
        E || N(f, d, this.length);
        let R = this[f]
          , j = 1
          , V = 0;
        for (; ++V < d && (j *= 256); )
            R += this[f + V] * j;
        return R
    }
    ,
    a.prototype.readUintBE = a.prototype.readUIntBE = function(f, d, E) {
        f = f >>> 0,
        d = d >>> 0,
        E || N(f, d, this.length);
        let R = this[f + --d]
          , j = 1;
        for (; d > 0 && (j *= 256); )
            R += this[f + --d] * j;
        return R
    }
    ,
    a.prototype.readUint8 = a.prototype.readUInt8 = function(f, d) {
        return f = f >>> 0,
        d || N(f, 1, this.length),
        this[f]
    }
    ,
    a.prototype.readUint16LE = a.prototype.readUInt16LE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 2, this.length),
        this[f] | this[f + 1] << 8
    }
    ,
    a.prototype.readUint16BE = a.prototype.readUInt16BE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 2, this.length),
        this[f] << 8 | this[f + 1]
    }
    ,
    a.prototype.readUint32LE = a.prototype.readUInt32LE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        (this[f] | this[f + 1] << 8 | this[f + 2] << 16) + this[f + 3] * 16777216
    }
    ,
    a.prototype.readUint32BE = a.prototype.readUInt32BE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        this[f] * 16777216 + (this[f + 1] << 16 | this[f + 2] << 8 | this[f + 3])
    }
    ,
    a.prototype.readBigUInt64LE = ve(function(f) {
        f = f >>> 0,
        z(f, "offset");
        const d = this[f]
          , E = this[f + 7];
        (d === void 0 || E === void 0) && H(f, this.length - 8);
        const R = d + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24
          , j = this[++f] + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + E * 2 ** 24;
        return BigInt(R) + (BigInt(j) << BigInt(32))
    }),
    a.prototype.readBigUInt64BE = ve(function(f) {
        f = f >>> 0,
        z(f, "offset");
        const d = this[f]
          , E = this[f + 7];
        (d === void 0 || E === void 0) && H(f, this.length - 8);
        const R = d * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f]
          , j = this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + E;
        return (BigInt(R) << BigInt(32)) + BigInt(j)
    }),
    a.prototype.readIntLE = function(f, d, E) {
        f = f >>> 0,
        d = d >>> 0,
        E || N(f, d, this.length);
        let R = this[f]
          , j = 1
          , V = 0;
        for (; ++V < d && (j *= 256); )
            R += this[f + V] * j;
        return j *= 128,
        R >= j && (R -= Math.pow(2, 8 * d)),
        R
    }
    ,
    a.prototype.readIntBE = function(f, d, E) {
        f = f >>> 0,
        d = d >>> 0,
        E || N(f, d, this.length);
        let R = d
          , j = 1
          , V = this[f + --R];
        for (; R > 0 && (j *= 256); )
            V += this[f + --R] * j;
        return j *= 128,
        V >= j && (V -= Math.pow(2, 8 * d)),
        V
    }
    ,
    a.prototype.readInt8 = function(f, d) {
        return f = f >>> 0,
        d || N(f, 1, this.length),
        this[f] & 128 ? (255 - this[f] + 1) * -1 : this[f]
    }
    ,
    a.prototype.readInt16LE = function(f, d) {
        f = f >>> 0,
        d || N(f, 2, this.length);
        const E = this[f] | this[f + 1] << 8;
        return E & 32768 ? E | 4294901760 : E
    }
    ,
    a.prototype.readInt16BE = function(f, d) {
        f = f >>> 0,
        d || N(f, 2, this.length);
        const E = this[f + 1] | this[f] << 8;
        return E & 32768 ? E | 4294901760 : E
    }
    ,
    a.prototype.readInt32LE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        this[f] | this[f + 1] << 8 | this[f + 2] << 16 | this[f + 3] << 24
    }
    ,
    a.prototype.readInt32BE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        this[f] << 24 | this[f + 1] << 16 | this[f + 2] << 8 | this[f + 3]
    }
    ,
    a.prototype.readBigInt64LE = ve(function(f) {
        f = f >>> 0,
        z(f, "offset");
        const d = this[f]
          , E = this[f + 7];
        (d === void 0 || E === void 0) && H(f, this.length - 8);
        const R = this[f + 4] + this[f + 5] * 2 ** 8 + this[f + 6] * 2 ** 16 + (E << 24);
        return (BigInt(R) << BigInt(32)) + BigInt(d + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24)
    }),
    a.prototype.readBigInt64BE = ve(function(f) {
        f = f >>> 0,
        z(f, "offset");
        const d = this[f]
          , E = this[f + 7];
        (d === void 0 || E === void 0) && H(f, this.length - 8);
        const R = (d << 24) + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f];
        return (BigInt(R) << BigInt(32)) + BigInt(this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + E)
    }),
    a.prototype.readFloatLE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        r.read(this, f, !0, 23, 4)
    }
    ,
    a.prototype.readFloatBE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 4, this.length),
        r.read(this, f, !1, 23, 4)
    }
    ,
    a.prototype.readDoubleLE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 8, this.length),
        r.read(this, f, !0, 52, 8)
    }
    ,
    a.prototype.readDoubleBE = function(f, d) {
        return f = f >>> 0,
        d || N(f, 8, this.length),
        r.read(this, f, !1, 52, 8)
    }
    ;
    function w(m, f, d, E, R, j) {
        if (!a.isBuffer(m))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (f > R || f < j)
            throw new RangeError('"value" argument is out of bounds');
        if (d + E > m.length)
            throw new RangeError("Index out of range")
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(f, d, E, R) {
        if (f = +f,
        d = d >>> 0,
        E = E >>> 0,
        !R) {
            const pe = Math.pow(2, 8 * E) - 1;
            w(this, f, d, E, pe, 0)
        }
        let j = 1
          , V = 0;
        for (this[d] = f & 255; ++V < E && (j *= 256); )
            this[d + V] = f / j & 255;
        return d + E
    }
    ,
    a.prototype.writeUintBE = a.prototype.writeUIntBE = function(f, d, E, R) {
        if (f = +f,
        d = d >>> 0,
        E = E >>> 0,
        !R) {
            const pe = Math.pow(2, 8 * E) - 1;
            w(this, f, d, E, pe, 0)
        }
        let j = E - 1
          , V = 1;
        for (this[d + j] = f & 255; --j >= 0 && (V *= 256); )
            this[d + j] = f / V & 255;
        return d + E
    }
    ,
    a.prototype.writeUint8 = a.prototype.writeUInt8 = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 1, 255, 0),
        this[d] = f & 255,
        d + 1
    }
    ,
    a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 2, 65535, 0),
        this[d] = f & 255,
        this[d + 1] = f >>> 8,
        d + 2
    }
    ,
    a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 2, 65535, 0),
        this[d] = f >>> 8,
        this[d + 1] = f & 255,
        d + 2
    }
    ,
    a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 4, 4294967295, 0),
        this[d + 3] = f >>> 24,
        this[d + 2] = f >>> 16,
        this[d + 1] = f >>> 8,
        this[d] = f & 255,
        d + 4
    }
    ,
    a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 4, 4294967295, 0),
        this[d] = f >>> 24,
        this[d + 1] = f >>> 16,
        this[d + 2] = f >>> 8,
        this[d + 3] = f & 255,
        d + 4
    }
    ;
    function U(m, f, d, E, R) {
        Ae(f, E, R, m, d, 7);
        let j = Number(f & BigInt(4294967295));
        m[d++] = j,
        j = j >> 8,
        m[d++] = j,
        j = j >> 8,
        m[d++] = j,
        j = j >> 8,
        m[d++] = j;
        let V = Number(f >> BigInt(32) & BigInt(4294967295));
        return m[d++] = V,
        V = V >> 8,
        m[d++] = V,
        V = V >> 8,
        m[d++] = V,
        V = V >> 8,
        m[d++] = V,
        d
    }
    function re(m, f, d, E, R) {
        Ae(f, E, R, m, d, 7);
        let j = Number(f & BigInt(4294967295));
        m[d + 7] = j,
        j = j >> 8,
        m[d + 6] = j,
        j = j >> 8,
        m[d + 5] = j,
        j = j >> 8,
        m[d + 4] = j;
        let V = Number(f >> BigInt(32) & BigInt(4294967295));
        return m[d + 3] = V,
        V = V >> 8,
        m[d + 2] = V,
        V = V >> 8,
        m[d + 1] = V,
        V = V >> 8,
        m[d] = V,
        d + 8
    }
    a.prototype.writeBigUInt64LE = ve(function(f, d=0) {
        return U(this, f, d, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    a.prototype.writeBigUInt64BE = ve(function(f, d=0) {
        return re(this, f, d, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    a.prototype.writeIntLE = function(f, d, E, R) {
        if (f = +f,
        d = d >>> 0,
        !R) {
            const _e = Math.pow(2, 8 * E - 1);
            w(this, f, d, E, _e - 1, -_e)
        }
        let j = 0
          , V = 1
          , pe = 0;
        for (this[d] = f & 255; ++j < E && (V *= 256); )
            f < 0 && pe === 0 && this[d + j - 1] !== 0 && (pe = 1),
            this[d + j] = (f / V >> 0) - pe & 255;
        return d + E
    }
    ,
    a.prototype.writeIntBE = function(f, d, E, R) {
        if (f = +f,
        d = d >>> 0,
        !R) {
            const _e = Math.pow(2, 8 * E - 1);
            w(this, f, d, E, _e - 1, -_e)
        }
        let j = E - 1
          , V = 1
          , pe = 0;
        for (this[d + j] = f & 255; --j >= 0 && (V *= 256); )
            f < 0 && pe === 0 && this[d + j + 1] !== 0 && (pe = 1),
            this[d + j] = (f / V >> 0) - pe & 255;
        return d + E
    }
    ,
    a.prototype.writeInt8 = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 1, 127, -128),
        f < 0 && (f = 255 + f + 1),
        this[d] = f & 255,
        d + 1
    }
    ,
    a.prototype.writeInt16LE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 2, 32767, -32768),
        this[d] = f & 255,
        this[d + 1] = f >>> 8,
        d + 2
    }
    ,
    a.prototype.writeInt16BE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 2, 32767, -32768),
        this[d] = f >>> 8,
        this[d + 1] = f & 255,
        d + 2
    }
    ,
    a.prototype.writeInt32LE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 4, 2147483647, -2147483648),
        this[d] = f & 255,
        this[d + 1] = f >>> 8,
        this[d + 2] = f >>> 16,
        this[d + 3] = f >>> 24,
        d + 4
    }
    ,
    a.prototype.writeInt32BE = function(f, d, E) {
        return f = +f,
        d = d >>> 0,
        E || w(this, f, d, 4, 2147483647, -2147483648),
        f < 0 && (f = 4294967295 + f + 1),
        this[d] = f >>> 24,
        this[d + 1] = f >>> 16,
        this[d + 2] = f >>> 8,
        this[d + 3] = f & 255,
        d + 4
    }
    ,
    a.prototype.writeBigInt64LE = ve(function(f, d=0) {
        return U(this, f, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    a.prototype.writeBigInt64BE = ve(function(f, d=0) {
        return re(this, f, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function ie(m, f, d, E, R, j) {
        if (d + E > m.length)
            throw new RangeError("Index out of range");
        if (d < 0)
            throw new RangeError("Index out of range")
    }
    function ue(m, f, d, E, R) {
        return f = +f,
        d = d >>> 0,
        R || ie(m, f, d, 4),
        r.write(m, f, d, E, 23, 4),
        d + 4
    }
    a.prototype.writeFloatLE = function(f, d, E) {
        return ue(this, f, d, !0, E)
    }
    ,
    a.prototype.writeFloatBE = function(f, d, E) {
        return ue(this, f, d, !1, E)
    }
    ;
    function Q(m, f, d, E, R) {
        return f = +f,
        d = d >>> 0,
        R || ie(m, f, d, 8),
        r.write(m, f, d, E, 52, 8),
        d + 8
    }
    a.prototype.writeDoubleLE = function(f, d, E) {
        return Q(this, f, d, !0, E)
    }
    ,
    a.prototype.writeDoubleBE = function(f, d, E) {
        return Q(this, f, d, !1, E)
    }
    ,
    a.prototype.copy = function(f, d, E, R) {
        if (!a.isBuffer(f))
            throw new TypeError("argument should be a Buffer");
        if (E || (E = 0),
        !R && R !== 0 && (R = this.length),
        d >= f.length && (d = f.length),
        d || (d = 0),
        R > 0 && R < E && (R = E),
        R === E || f.length === 0 || this.length === 0)
            return 0;
        if (d < 0)
            throw new RangeError("targetStart out of bounds");
        if (E < 0 || E >= this.length)
            throw new RangeError("Index out of range");
        if (R < 0)
            throw new RangeError("sourceEnd out of bounds");
        R > this.length && (R = this.length),
        f.length - d < R - E && (R = f.length - d + E);
        const j = R - E;
        return this === f && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(d, E, R) : Uint8Array.prototype.set.call(f, this.subarray(E, R), d),
        j
    }
    ,
    a.prototype.fill = function(f, d, E, R) {
        if (typeof f == "string") {
            if (typeof d == "string" ? (R = d,
            d = 0,
            E = this.length) : typeof E == "string" && (R = E,
            E = this.length),
            R !== void 0 && typeof R != "string")
                throw new TypeError("encoding must be a string");
            if (typeof R == "string" && !a.isEncoding(R))
                throw new TypeError("Unknown encoding: " + R);
            if (f.length === 1) {
                const V = f.charCodeAt(0);
                (R === "utf8" && V < 128 || R === "latin1") && (f = V)
            }
        } else
            typeof f == "number" ? f = f & 255 : typeof f == "boolean" && (f = Number(f));
        if (d < 0 || this.length < d || this.length < E)
            throw new RangeError("Out of range index");
        if (E <= d)
            return this;
        d = d >>> 0,
        E = E === void 0 ? this.length : E >>> 0,
        f || (f = 0);
        let j;
        if (typeof f == "number")
            for (j = d; j < E; ++j)
                this[j] = f;
        else {
            const V = a.isBuffer(f) ? f : a.from(f, R)
              , pe = V.length;
            if (pe === 0)
                throw new TypeError('The value "' + f + '" is invalid for argument "value"');
            for (j = 0; j < E - d; ++j)
                this[j + d] = V[j % pe]
        }
        return this
    }
    ;
    const ee = {};
    function te(m, f, d) {
        ee[m] = class extends d {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: f.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${m}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return m
            }
            set code(R) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: R,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${m}]: ${this.message}`
            }
        }
    }
    te("ERR_BUFFER_OUT_OF_BOUNDS", function(m) {
        return m ? `${m} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    te("ERR_INVALID_ARG_TYPE", function(m, f) {
        return `The "${m}" argument must be of type number. Received type ${typeof f}`
    }, TypeError),
    te("ERR_OUT_OF_RANGE", function(m, f, d) {
        let E = `The value of "${m}" is out of range.`
          , R = d;
        return Number.isInteger(d) && Math.abs(d) > 2 ** 32 ? R = he(String(d)) : typeof d == "bigint" && (R = String(d),
        (d > BigInt(2) ** BigInt(32) || d < -(BigInt(2) ** BigInt(32))) && (R = he(R)),
        R += "n"),
        E += ` It must be ${f}. Received ${R}`,
        E
    }, RangeError);
    function he(m) {
        let f = ""
          , d = m.length;
        const E = m[0] === "-" ? 1 : 0;
        for (; d >= E + 4; d -= 3)
            f = `_${m.slice(d - 3, d)}${f}`;
        return `${m.slice(0, d)}${f}`
    }
    function xe(m, f, d) {
        z(f, "offset"),
        (m[f] === void 0 || m[f + d] === void 0) && H(f, m.length - (d + 1))
    }
    function Ae(m, f, d, E, R, j) {
        if (m > d || m < f) {
            const V = typeof f == "bigint" ? "n" : "";
            let pe;
            throw j > 3 ? f === 0 || f === BigInt(0) ? pe = `>= 0${V} and < 2${V} ** ${(j + 1) * 8}${V}` : pe = `>= -(2${V} ** ${(j + 1) * 8 - 1}${V}) and < 2 ** ${(j + 1) * 8 - 1}${V}` : pe = `>= ${f}${V} and <= ${d}${V}`,
            new ee.ERR_OUT_OF_RANGE("value",pe,m)
        }
        xe(E, R, j)
    }
    function z(m, f) {
        if (typeof m != "number")
            throw new ee.ERR_INVALID_ARG_TYPE(f,"number",m)
    }
    function H(m, f, d) {
        throw Math.floor(m) !== m ? (z(m, d),
        new ee.ERR_OUT_OF_RANGE(d || "offset","an integer",m)) : f < 0 ? new ee.ERR_BUFFER_OUT_OF_BOUNDS : new ee.ERR_OUT_OF_RANGE(d || "offset",`>= ${d ? 1 : 0} and <= ${f}`,m)
    }
    const Y = /[^+/0-9A-Za-z-_]/g;
    function se(m) {
        if (m = m.split("=")[0],
        m = m.trim().replace(Y, ""),
        m.length < 2)
            return "";
        for (; m.length % 4 !== 0; )
            m = m + "=";
        return m
    }
    function X(m, f) {
        f = f || 1 / 0;
        let d;
        const E = m.length;
        let R = null;
        const j = [];
        for (let V = 0; V < E; ++V) {
            if (d = m.charCodeAt(V),
            d > 55295 && d < 57344) {
                if (!R) {
                    if (d > 56319) {
                        (f -= 3) > -1 && j.push(239, 191, 189);
                        continue
                    } else if (V + 1 === E) {
                        (f -= 3) > -1 && j.push(239, 191, 189);
                        continue
                    }
                    R = d;
                    continue
                }
                if (d < 56320) {
                    (f -= 3) > -1 && j.push(239, 191, 189),
                    R = d;
                    continue
                }
                d = (R - 55296 << 10 | d - 56320) + 65536
            } else
                R && (f -= 3) > -1 && j.push(239, 191, 189);
            if (R = null,
            d < 128) {
                if ((f -= 1) < 0)
                    break;
                j.push(d)
            } else if (d < 2048) {
                if ((f -= 2) < 0)
                    break;
                j.push(d >> 6 | 192, d & 63 | 128)
            } else if (d < 65536) {
                if ((f -= 3) < 0)
                    break;
                j.push(d >> 12 | 224, d >> 6 & 63 | 128, d & 63 | 128)
            } else if (d < 1114112) {
                if ((f -= 4) < 0)
                    break;
                j.push(d >> 18 | 240, d >> 12 & 63 | 128, d >> 6 & 63 | 128, d & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return j
    }
    function ce(m) {
        const f = [];
        for (let d = 0; d < m.length; ++d)
            f.push(m.charCodeAt(d) & 255);
        return f
    }
    function me(m, f) {
        let d, E, R;
        const j = [];
        for (let V = 0; V < m.length && !((f -= 2) < 0); ++V)
            d = m.charCodeAt(V),
            E = d >> 8,
            R = d % 256,
            j.push(R),
            j.push(E);
        return j
    }
    function oe(m) {
        return t.toByteArray(se(m))
    }
    function ae(m, f, d, E) {
        let R;
        for (R = 0; R < E && !(R + d >= f.length || R >= m.length); ++R)
            f[R + d] = m[R];
        return R
    }
    function ne(m, f) {
        return m instanceof f || m != null && m.constructor != null && m.constructor.name != null && m.constructor.name === f.name
    }
    function de(m) {
        return m !== m
    }
    const ye = function() {
        const m = "0123456789abcdef"
          , f = new Array(256);
        for (let d = 0; d < 16; ++d) {
            const E = d * 16;
            for (let R = 0; R < 16; ++R)
                f[E + R] = m[d] + m[R]
        }
        return f
    }();
    function ve(m) {
        return typeof BigInt > "u" ? Ee : m
    }
    function Ee() {
        throw new Error("BigInt not supported")
    }
}
)(Z4);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
    var r = Z4
      , n = r.Buffer;
    function i(o, a) {
        for (var u in o)
            a[u] = o[u]
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i(r, t),
    t.Buffer = s);
    function s(o, a, u) {
        return n(o, a, u)
    }
    s.prototype = Object.create(n.prototype),
    i(n, s),
    s.from = function(o, a, u) {
        if (typeof o == "number")
            throw new TypeError("Argument must not be a number");
        return n(o, a, u)
    }
    ,
    s.alloc = function(o, a, u) {
        if (typeof o != "number")
            throw new TypeError("Argument must be a number");
        var c = n(o);
        return a !== void 0 ? typeof u == "string" ? c.fill(a, u) : c.fill(a) : c.fill(0),
        c
    }
    ,
    s.allocUnsafe = function(o) {
        if (typeof o != "number")
            throw new TypeError("Argument must be a number");
        return n(o)
    }
    ,
    s.allocUnsafeSlow = function(o) {
        if (typeof o != "number")
            throw new TypeError("Argument must be a number");
        return r.SlowBuffer(o)
    }
}
)(mp, mp.exports);
var Jc = mp.exports.Buffer;
function oj(e) {
    if (e.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
        t[r] = 255;
    for (var n = 0; n < e.length; n++) {
        var i = e.charAt(n)
          , s = i.charCodeAt(0);
        if (t[s] !== 255)
            throw new TypeError(i + " is ambiguous");
        t[s] = n
    }
    var o = e.length
      , a = e.charAt(0)
      , u = Math.log(o) / Math.log(256)
      , c = Math.log(256) / Math.log(o);
    function l(g) {
        if ((Array.isArray(g) || g instanceof Uint8Array) && (g = Jc.from(g)),
        !Jc.isBuffer(g))
            throw new TypeError("Expected Buffer");
        if (g.length === 0)
            return "";
        for (var S = 0, x = 0, v = 0, I = g.length; v !== I && g[v] === 0; )
            v++,
            S++;
        for (var M = (I - v) * c + 1 >>> 0, A = new Uint8Array(M); v !== I; ) {
            for (var k = g[v], L = 0, O = M - 1; (k !== 0 || L < x) && O !== -1; O--,
            L++)
                k += 256 * A[O] >>> 0,
                A[O] = k % o >>> 0,
                k = k / o >>> 0;
            if (k !== 0)
                throw new Error("Non-zero carry");
            x = L,
            v++
        }
        for (var $ = M - x; $ !== M && A[$] === 0; )
            $++;
        for (var D = a.repeat(S); $ < M; ++$)
            D += e.charAt(A[$]);
        return D
    }
    function p(g) {
        if (typeof g != "string")
            throw new TypeError("Expected String");
        if (g.length === 0)
            return Jc.alloc(0);
        for (var S = 0, x = 0, v = 0; g[S] === a; )
            x++,
            S++;
        for (var I = (g.length - S) * u + 1 >>> 0, M = new Uint8Array(I); g[S]; ) {
            var A = t[g.charCodeAt(S)];
            if (A === 255)
                return;
            for (var k = 0, L = I - 1; (A !== 0 || k < v) && L !== -1; L--,
            k++)
                A += o * M[L] >>> 0,
                M[L] = A % 256 >>> 0,
                A = A / 256 >>> 0;
            if (A !== 0)
                throw new Error("Non-zero carry");
            v = k,
            S++
        }
        for (var O = I - v; O !== I && M[O] === 0; )
            O++;
        var $ = Jc.allocUnsafe(x + (I - O));
        $.fill(0, 0, x);
        for (var D = x; O !== I; )
            $[D++] = M[O++];
        return $
    }
    function h(g) {
        var S = p(g);
        if (S)
            return S;
        throw new Error("Non-base" + o + " character")
    }
    return {
        encode: l,
        decodeUnsafe: p,
        decode: h
    }
}
var aj = oj
  , uj = aj
  , cj = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  , lj = uj(cj);
function $a(e) {
    return "version"in e
}
var vn = globalThis && globalThis.__classPrivateFieldSet || function(e, t, r, n, i) {
    if (n === "m")
        throw new TypeError("Private method is not writable");
    if (n === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(e, r) : i ? i.value = r : t.set(e, r),
    r
}
, De = globalThis && globalThis.__classPrivateFieldGet || function(e, t, r, n) {
    if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e)
}
, Sn, Un, yo, fo, tu, pt, bl, wl, wf, vl, yp, zb, $b, Fb;
function fj(e) {
    return "standard:connect"in e.features && "standard:events"in e.features && ("solana:signAndSendTransaction"in e.features || "solana:signTransaction"in e.features)
}
class dj extends x3 {
    constructor({wallet: t}) {
        super(),
        Sn.add(this),
        Un.set(this, void 0),
        yo.set(this, void 0),
        fo.set(this, void 0),
        tu.set(this, void 0),
        pt.set(this, void 0),
        bl.set(this, void 0),
        wl.set(this, typeof window > "u" || typeof document > "u" ? Qe.Unsupported : Qe.Installed),
        yp.set(this, n => {
            if (!De(this, Un, "f") || !De(this, yo, "f") || !("accounts"in n))
                return;
            const i = De(this, pt, "f").accounts[0];
            if (!i) {
                De(this, Sn, "m", vl).call(this),
                this.emit("error", new id),
                this.emit("disconnect");
                return
            }
            if (i === De(this, Un, "f"))
                return;
            let s;
            try {
                s = new Ne(i.publicKey)
            } catch (o) {
                De(this, Sn, "m", vl).call(this),
                this.emit("error", new Ws(o == null ? void 0 : o.message)),
                this.emit("disconnect");
                return
            }
            De(this, Sn, "m", wf).call(this, i, s),
            this.emit("connect", s)
        }
        ),
        vn(this, pt, t, "f");
        const r = "solana:signAndSendTransaction"in t.features ? t.features["solana:signAndSendTransaction"].supportedTransactionVersions : t.features["solana:signTransaction"].supportedTransactionVersions;
        vn(this, bl, ZP(r, ["legacy"]) ? null : new Set(r), "f"),
        vn(this, Un, null, "f"),
        vn(this, yo, null, "f"),
        vn(this, fo, !1, "f")
    }
    get supportedTransactionVersions() {
        return De(this, bl, "f")
    }
    get name() {
        return De(this, pt, "f").name
    }
    get icon() {
        return De(this, pt, "f").icon
    }
    get url() {
        return "https://github.com/wallet-standard"
    }
    get publicKey() {
        return De(this, yo, "f")
    }
    get connecting() {
        return De(this, fo, "f")
    }
    get readyState() {
        return De(this, wl, "f")
    }
    get wallet() {
        return De(this, pt, "f")
    }
    get standard() {
        return !0
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (De(this, wl, "f") !== Qe.Installed)
                throw new qs;
            if (vn(this, fo, !0, "f"),
            !De(this, pt, "f").accounts.length)
                try {
                    await De(this, pt, "f").features["standard:connect"].connect()
                } catch (n) {
                    throw new Qo(n == null ? void 0 : n.message,n)
                }
            if (!De(this, pt, "f").accounts.length)
                throw new eu;
            const t = De(this, pt, "f").accounts[0];
            let r;
            try {
                r = new Ne(t.publicKey)
            } catch (n) {
                throw new Ws(n == null ? void 0 : n.message,n)
            }
            vn(this, tu, De(this, pt, "f").features["standard:events"].on("change", De(this, yp, "f")), "f"),
            De(this, Sn, "m", wf).call(this, t, r),
            this.emit("connect", r)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            vn(this, fo, !1, "f")
        }
    }
    async disconnect() {
        if ("standard:disconnect"in De(this, pt, "f").features)
            try {
                await De(this, pt, "f").features["standard:disconnect"].disconnect()
            } catch (t) {
                this.emit("error", new Yg(t == null ? void 0 : t.message,t))
            }
        De(this, Sn, "m", vl).call(this),
        this.emit("disconnect")
    }
    async sendTransaction(t, r, n={}) {
        try {
            const i = De(this, Un, "f");
            if (!i)
                throw new It;
            let s;
            if ("solana:signAndSendTransaction"in De(this, pt, "f").features)
                if (i.features.includes("solana:signAndSendTransaction"))
                    s = "solana:signAndSendTransaction";
                else if ("solana:signTransaction"in De(this, pt, "f").features && i.features.includes("solana:signTransaction"))
                    s = "solana:signTransaction";
                else
                    throw new eu;
            else if ("solana:signTransaction"in De(this, pt, "f").features) {
                if (!i.features.includes("solana:signTransaction"))
                    throw new eu;
                s = "solana:signTransaction"
            } else
                throw new Xa;
            const o = YP(r.rpcEndpoint);
            if (!i.chains.includes(o))
                throw new fi;
            try {
                const {signers: a, ...u} = n;
                let c;
                if ($a(t) ? (a != null && a.length && t.sign(a),
                c = t.serialize()) : (t = await this.prepareTransaction(t, r, u),
                a != null && a.length && t.partialSign(...a),
                c = new Uint8Array(t.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))),
                s === "solana:signAndSendTransaction") {
                    const [l] = await De(this, pt, "f").features["solana:signAndSendTransaction"].signAndSendTransaction({
                        account: i,
                        chain: o,
                        transaction: c,
                        options: {
                            preflightCommitment: D0(u.preflightCommitment || r.commitment),
                            skipPreflight: u.skipPreflight,
                            maxRetries: u.maxRetries,
                            minContextSlot: u.minContextSlot
                        }
                    });
                    return lj.encode(l.signature)
                } else {
                    const [l] = await De(this, pt, "f").features["solana:signTransaction"].signTransaction({
                        account: i,
                        chain: o,
                        transaction: c,
                        options: {
                            preflightCommitment: D0(u.preflightCommitment || r.commitment),
                            minContextSlot: u.minContextSlot
                        }
                    });
                    return await r.sendRawTransaction(l.signedTransaction, {
                        ...u,
                        preflightCommitment: D0(u.preflightCommitment || r.commitment)
                    })
                }
            } catch (a) {
                throw a instanceof nr ? a : new fi(a == null ? void 0 : a.message,a)
            }
        } catch (i) {
            throw this.emit("error", i),
            i
        }
    }
}
Un = new WeakMap,
yo = new WeakMap,
fo = new WeakMap,
tu = new WeakMap,
pt = new WeakMap,
bl = new WeakMap,
wl = new WeakMap,
yp = new WeakMap,
Sn = new WeakSet,
wf = function(t, r) {
    vn(this, Un, t, "f"),
    vn(this, yo, r, "f"),
    t != null && t.features.includes("solana:signTransaction") ? (this.signTransaction = De(this, Sn, "m", zb),
    this.signAllTransactions = De(this, Sn, "m", $b)) : (delete this.signTransaction,
    delete this.signAllTransactions),
    t != null && t.features.includes("solana:signMessage") ? this.signMessage = De(this, Sn, "m", Fb) : delete this.signMessage
}
,
vl = function() {
    const t = De(this, tu, "f");
    t && (vn(this, tu, void 0, "f"),
    t()),
    De(this, Sn, "m", wf).call(this, null, null)
}
,
zb = async function(t) {
    try {
        const r = De(this, Un, "f");
        if (!r)
            throw new It;
        if (!("solana:signTransaction"in De(this, pt, "f").features))
            throw new Xa;
        if (!r.features.includes("solana:signTransaction"))
            throw new eu;
        try {
            const i = (await De(this, pt, "f").features["solana:signTransaction"].signTransaction({
                account: r,
                transaction: $a(t) ? t.serialize() : new Uint8Array(t.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            }))[0].signedTransaction;
            return $a(t) ? Mu.deserialize(i) : ta.from(i)
        } catch (n) {
            throw n instanceof nr ? n : new fn(n == null ? void 0 : n.message,n)
        }
    } catch (r) {
        throw this.emit("error", r),
        r
    }
}
,
$b = async function(t) {
    try {
        const r = De(this, Un, "f");
        if (!r)
            throw new It;
        if (!("solana:signTransaction"in De(this, pt, "f").features))
            throw new Xa;
        if (!r.features.includes("solana:signTransaction"))
            throw new fn;
        try {
            const n = await De(this, pt, "f").features["solana:signTransaction"].signTransaction(...t.map(i => ({
                account: r,
                transaction: $a(i) ? i.serialize() : new Uint8Array(i.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            })));
            return t.map( (i, s) => {
                const o = n[s].signedTransaction;
                return $a(i) ? Mu.deserialize(o) : ta.from(o)
            }
            )
        } catch (n) {
            throw new fn(n == null ? void 0 : n.message,n)
        }
    } catch (r) {
        throw this.emit("error", r),
        r
    }
}
,
Fb = async function(t) {
    try {
        const r = De(this, Un, "f");
        if (!r)
            throw new It;
        if (!("solana:signMessage"in De(this, pt, "f").features))
            throw new Xa;
        if (!r.features.includes("solana:signMessage"))
            throw new Eu;
        try {
            return (await De(this, pt, "f").features["solana:signMessage"].signMessage({
                account: r,
                message: t
            }))[0].signature
        } catch (n) {
            throw new Eu(n == null ? void 0 : n.message,n)
        }
    } catch (r) {
        throw this.emit("error", r),
        r
    }
}
;
var hj = globalThis && globalThis.__classPrivateFieldSet || function(e, t, r, n, i) {
    if (n === "m")
        throw new TypeError("Private method is not writable");
    if (n === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(e, r) : i ? i.value = r : t.set(e, r),
    r
}
, pj = globalThis && globalThis.__classPrivateFieldGet || function(e, t, r, n) {
    if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e)
}
, xl;
let Wr;
const El = new Set
  , bo = {};
function gj() {
    if (Wr || (Wr = Object.freeze({
        register: Hb,
        get: mj,
        on: yj
    }),
    typeof window > "u"))
        return Wr;
    const e = Object.freeze({
        register: Hb
    });
    try {
        window.addEventListener("wallet-standard:register-wallet", ({detail: t}) => t(e))
    } catch (t) {
        console.error(`wallet-standard:register-wallet event listener could not be added
`, t)
    }
    try {
        window.dispatchEvent(new bj(e))
    } catch (t) {
        console.error(`wallet-standard:app-ready event could not be dispatched
`, t)
    }
    return Wr
}
function Hb(...e) {
    var t;
    return e = e.filter(r => !El.has(r)),
    e.length ? (e.forEach(r => El.add(r)),
    (t = bo.register) == null || t.forEach(r => bp( () => r(...e))),
    function() {
        var n;
        e.forEach(i => El.delete(i)),
        (n = bo.unregister) == null || n.forEach(i => bp( () => i(...e)))
    }
    ) : () => {}
}
function mj() {
    return [...El]
}
function yj(e, t) {
    var r;
    return (r = bo[e]) != null && r.push(t) || (bo[e] = [t]),
    function() {
        var i;
        bo[e] = (i = bo[e]) == null ? void 0 : i.filter(s => t !== s)
    }
}
function bp(e) {
    try {
        e()
    } catch (t) {
        console.error(t)
    }
}
class bj extends Event {
    constructor(t) {
        super("wallet-standard:app-ready", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }),
        xl.set(this, void 0),
        hj(this, xl, t, "f")
    }
    get detail() {
        return pj(this, xl, "f")
    }
    get type() {
        return "wallet-standard:app-ready"
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}
xl = new WeakMap;
function wj() {
    if (Wr || (Wr = gj(),
    typeof window > "u"))
        return Wr;
    const e = window.navigator.wallets || [];
    if (!Array.isArray(e))
        return console.error("window.navigator.wallets is not an array"),
        Wr;
    const {register: t} = Wr
      , r = (...n) => n.forEach(i => bp( () => i({
        register: t
    })));
    try {
        Object.defineProperty(window.navigator, "wallets", {
            value: Object.freeze({
                push: r
            })
        })
    } catch {
        return console.error("window.navigator.wallets could not be set"),
        Wr
    }
    return r(...e),
    Wr
}
function vj(e) {
    const t = new Set
      , {get: r, on: n} = wj()
      , i = Pr(qb(r()));
    return Cn(s => {
        const o = [n("register", (...a) => i.value = [...i.value, ...qb(a)]), n("unregister", (...a) => i.value = i.value.filter(u => a.some(c => c === u.wallet)))];
        s( () => o.forEach(a => a()))
    }
    ),
    Se( () => [...i.value, ...e.value.filter( ({name: s}) => i.value.some(o => o.name === s) ? (t.has(s) || (t.add(s),
    console.warn(`${s} was registered as a Standard Wallet. The Wallet Adapter for ${s} can be removed from your app.`)),
    !1) : !0)])
}
function qb(e) {
    return e.filter(fj).map(t => new dj({
        wallet: t
    }))
}
function xj(e, t) {
    const r = async (o, a, u) => {
        var c;
        const l = (c = e.value) == null ? void 0 : c.adapter;
        if (!l)
            throw t(new V4);
        if (!l.connected)
            throw t(new It, l);
        return await l.sendTransaction(o, a, u)
    }
      , n = Se( () => {
        var o;
        const a = (o = e.value) == null ? void 0 : o.adapter;
        if (a && "signTransaction"in a)
            return async u => {
                if (!a.connected)
                    throw t(new It);
                return await a.signTransaction(u)
            }
    }
    )
      , i = Se( () => {
        var o;
        const a = (o = e.value) == null ? void 0 : o.adapter;
        if (a && "signAllTransactions"in a)
            return async u => {
                if (!a.connected)
                    throw t(new It);
                return await a.signAllTransactions(u)
            }
    }
    )
      , s = Se( () => {
        var o;
        const a = (o = e.value) == null ? void 0 : o.adapter;
        if (a && "signMessage"in a)
            return async u => {
                if (!a.connected)
                    throw t(new It);
                return await a.signMessage(u)
            }
    }
    );
    return {
        sendTransaction: r,
        signTransaction: n,
        signAllTransactions: i,
        signMessage: s
    }
}
function Ej(e) {
    const t = Ue(!1);
    return typeof window > "u" || Cn(r => {
        if (e.value)
            return;
        const n = () => t.value = !0;
        window.addEventListener("beforeunload", n),
        r( () => window.removeEventListener("beforeunload", n))
    }
    ),
    t
}
function Sj(e, t) {
    const r = Pr(null)
      , n = Ue(null)
      , i = Ue(!1)
      , s = Ue(Qe.Unsupported)
      , o = Se( () => s.value === Qe.Installed || s.value === Qe.Loadable)
      , a = () => {
        var u, c, l, p, h, g;
        n.value = (c = (u = r.value) == null ? void 0 : u.adapter.publicKey) != null ? c : null,
        i.value = (p = (l = r.value) == null ? void 0 : l.adapter.connected) != null ? p : !1,
        s.value = (g = (h = r.value) == null ? void 0 : h.readyState) != null ? g : Qe.Unsupported
    }
    ;
    return Cn( () => {
        var u;
        r.value = t.value && (u = e.value.find( ({adapter: c}) => c.name === t.value)) != null ? u : null,
        a()
    }
    ),
    {
        wallet: r,
        publicKey: n,
        connected: i,
        readyState: s,
        ready: o,
        refreshWalletState: a
    }
}
function _j(e) {
    const t = Pr([]);
    return Cn( () => {
        t.value = e.value.map(r => ({
            adapter: r,
            readyState: r.readyState
        }))
    }
    ),
    t
}
const Aj = ({wallets: e=[], autoConnect: t=!1, cluster: r="mainnet-beta", onError: n, localStorageKey: i="walletName"}) => {
    const s = Ue(r)
      , o = Ue(!1)
      , a = Ue(!1)
      , u = Pr(e)
      , c = vj(u)
      , {isMobile: l, uriForAppIdentity: p} = PP(c)
      , h = HP(c, l, p, s)
      , g = _j(h)
      , {name: S, isUsingMwaAdapterOnMobile: x, select: v, deselect: I} = WP(i, l)
      , {wallet: M, publicKey: A, connected: k, readyState: L, ready: O, refreshWalletState: $} = Sj(g, S)
      , D = Ej(x)
      , K = FP(D, n);
    qP(g),
    RP(M, D, x, I, $, K);
    const G = BP(t, M, x, o, k, O, I)
      , {sendTransaction: F, signTransaction: q, signAllTransactions: B, signMessage: y} = xj(M, K);
    return {
        wallets: g,
        autoConnect: G,
        cluster: s,
        wallet: M,
        publicKey: A,
        readyState: L,
        ready: O,
        connected: k,
        connecting: o,
        disconnecting: a,
        select: v,
        connect: async () => {
            if (k.value || o.value || a.value)
                return;
            if (!M.value)
                throw K(new V4);
            const T = M.value.adapter;
            if (!O.value)
                throw K(new qs, T);
            try {
                o.value = !0,
                await T.connect()
            } catch (C) {
                throw I(),
                C
            } finally {
                o.value = !1
            }
        }
        ,
        disconnect: async () => {
            if (!(a.value || !M.value))
                try {
                    a.value = !0,
                    await M.value.adapter.disconnect()
                } finally {
                    a.value = !1
                }
        }
        ,
        sendTransaction: F,
        signTransaction: q,
        signAllTransactions: B,
        signMessage: y
    }
}
;
let wp = null;
const Mj = () => {
    if (wp)
        return wp;
    throw new GB("Wallet not initialized. Please use the `initWallet` method to initialize the wallet.")
}
  , Ij = e => {
    wp = Aj(e)
}
  , Tj = {
    install: (e, t={}) => {
        Ij(t),
        e.config.globalProperties.$wallet = Mj()
    }
}
  , Cj = "Phantom";
class kj extends Zg {
    constructor(t={}) {
        super(),
        this.name = Cj,
        this.url = "https://phantom.app",
        this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==",
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this._readyState = typeof window > "u" || typeof document > "u" ? Qe.Unsupported : Qe.NotDetected,
        this._disconnected = () => {
            const r = this._wallet;
            r && (r.off("disconnect", this._disconnected),
            r.off("accountChanged", this._accountChanged),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new id),
            this.emit("disconnect"))
        }
        ,
        this._accountChanged = r => {
            const n = this._publicKey;
            if (n) {
                try {
                    r = new Ne(r.toBytes())
                } catch (i) {
                    this.emit("error", new Ws(i == null ? void 0 : i.message,i));
                    return
                }
                n.equals(r) || (this._publicKey = r,
                this.emit("connect", r))
            }
        }
        ,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._readyState !== Qe.Unsupported && (rp() ? (this._readyState = Qe.Loadable,
        this.emit("readyStateChange", this._readyState)) : E3( () => {
            var r, n, i;
            return (n = (r = window.phantom) == null ? void 0 : r.solana) != null && n.isPhantom || (i = window.solana) != null && i.isPhantom ? (this._readyState = Qe.Installed,
            this.emit("readyStateChange", this._readyState),
            !0) : !1
        }
        ))
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    async autoConnect() {
        this.readyState === Qe.Installed && await this.connect()
    }
    async connect() {
        var t;
        try {
            if (this.connected || this.connecting)
                return;
            if (this.readyState === Qe.Loadable) {
                const i = encodeURIComponent(window.location.href)
                  , s = encodeURIComponent(window.location.origin);
                window.location.href = `https://phantom.app/ul/browse/${i}?ref=${s}`;
                return
            }
            if (this.readyState !== Qe.Installed)
                throw new qs;
            this._connecting = !0;
            const r = ((t = window.phantom) == null ? void 0 : t.solana) || window.solana;
            if (!r.isConnected)
                try {
                    await r.connect()
                } catch (i) {
                    throw new Qo(i == null ? void 0 : i.message,i)
                }
            if (!r.publicKey)
                throw new eu;
            let n;
            try {
                n = new Ne(r.publicKey.toBytes())
            } catch (i) {
                throw new Ws(i == null ? void 0 : i.message,i)
            }
            r.on("disconnect", this._disconnected),
            r.on("accountChanged", this._accountChanged),
            this._wallet = r,
            this._publicKey = n,
            this.emit("connect", n)
        } catch (r) {
            throw this.emit("error", r),
            r
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const t = this._wallet;
        if (t) {
            t.off("disconnect", this._disconnected),
            t.off("accountChanged", this._accountChanged),
            this._wallet = null,
            this._publicKey = null;
            try {
                await t.disconnect()
            } catch (r) {
                this.emit("error", new Yg(r == null ? void 0 : r.message,r))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(t, r, n={}) {
        try {
            const i = this._wallet;
            if (!i)
                throw new It;
            try {
                const {signers: s, ...o} = n;
                sf(t) ? s != null && s.length && t.sign(s) : (t = await this.prepareTransaction(t, r, o),
                s != null && s.length && t.partialSign(...s)),
                o.preflightCommitment = o.preflightCommitment || r.commitment;
                const {signature: a} = await i.signAndSendTransaction(t, o);
                return a
            } catch (s) {
                throw s instanceof nr ? s : new fi(s == null ? void 0 : s.message,s)
            }
        } catch (i) {
            throw this.emit("error", i),
            i
        }
    }
    async signTransaction(t) {
        try {
            const r = this._wallet;
            if (!r)
                throw new It;
            try {
                return await r.signTransaction(t) || t
            } catch (n) {
                throw new fn(n == null ? void 0 : n.message,n)
            }
        } catch (r) {
            throw this.emit("error", r),
            r
        }
    }
    async signAllTransactions(t) {
        try {
            const r = this._wallet;
            if (!r)
                throw new It;
            try {
                return await r.signAllTransactions(t) || t
            } catch (n) {
                throw new fn(n == null ? void 0 : n.message,n)
            }
        } catch (r) {
            throw this.emit("error", r),
            r
        }
    }
    async signMessage(t) {
        try {
            const r = this._wallet;
            if (!r)
                throw new It;
            try {
                const {signature: n} = await r.signMessage(t);
                return n
            } catch (n) {
                throw new Eu(n == null ? void 0 : n.message,n)
            }
        } catch (r) {
            throw this.emit("error", r),
            r
        }
    }
}
var Lj = function(e, t, r, n, i) {
    if (n === "m")
        throw new TypeError("Private method is not writable");
    if (n === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(e, r) : i ? i.value = r : t.set(e, r),
    r
}, Oj = function(e, t, r, n) {
    if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e)
}, Sl;
function Nj(e) {
    const t = ({register: r}) => r(e);
    try {
        window.dispatchEvent(new Rj(t))
    } catch (r) {
        console.error(`wallet-standard:register-wallet event could not be dispatched
`, r)
    }
    try {
        window.addEventListener("wallet-standard:app-ready", ({detail: r}) => t(r))
    } catch (r) {
        console.error(`wallet-standard:app-ready event listener could not be added
`, r)
    }
}
class Rj extends Event {
    constructor(t) {
        super("wallet-standard:register-wallet", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }),
        Sl.set(this, void 0),
        Lj(this, Sl, t, "f")
    }
    get detail() {
        return Oj(this, Sl, "f")
    }
    get type() {
        return "wallet-standard:register-wallet"
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}
Sl = new WeakMap;
const Bj = "solana:mainnet"
  , Pj = "solana:devnet"
  , jj = "solana:testnet"
  , Dj = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMxIiB2aWV3Qm94PSIwIDAgMzEgMzEiIHdpZHRoPSIzMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIwLjI1IiB4Mj0iMjYuNTcxIiB5MT0iMjcuMTczIiB5Mj0iMTkuODU4Ij48c3RvcCBvZmZzZXQ9Ii4wOCIgc3RvcC1jb2xvcj0iIzk5NDVmZiIvPjxzdG9wIG9mZnNldD0iLjMiIHN0b3AtY29sb3I9IiM4NzUyZjMiLz48c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNTQ5N2Q1Ii8+PHN0b3Agb2Zmc2V0PSIuNiIgc3RvcC1jb2xvcj0iIzQzYjRjYSIvPjxzdG9wIG9mZnNldD0iLjcyIiBzdG9wLWNvbG9yPSIjMjhlMGI5Ii8+PHN0b3Agb2Zmc2V0PSIuOTciIHN0b3AtY29sb3I9IiMxOWZiOWIiLz48L2xpbmVhckdyYWRpZW50PjxnIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iLjA5NCI+PHBhdGggZD0ibTI2LjEwOSAzLjY0My05LjM2OSA2Ljk1OSAxLjczMy00LjEwNSA3LjYzNy0yLjg1M3oiIGZpbGw9IiNlMjc2MWIiIHN0cm9rZT0iI2UyNzYxYiIvPjxnIGZpbGw9IiNlNDc2MWIiIHN0cm9rZT0iI2U0NzYxYiI+PHBhdGggZD0ibTQuNDgxIDMuNjQzIDkuMjk0IDcuMDI0LTEuNjQ4LTQuMTcxem0xOC4yNTggMTYuMTMtMi40OTUgMy44MjMgNS4zMzkgMS40NjkgMS41MzUtNS4yMDctNC4zNzgtLjA4NXptLTE5LjI0Ny4wODUgMS41MjUgNS4yMDcgNS4zMzktMS40NjktMi40OTUtMy44MjN6Ii8+PHBhdGggZD0ibTEwLjA1NSAxMy4zMTMtMS40ODggMi4yNTEgNS4zMDEuMjM1LS4xODgtNS42OTd6bTEwLjQ4IDAtMy42NzItMy4yNzctLjEyMiA1Ljc2MyA1LjI5Mi0uMjM1LTEuNDk3LTIuMjUxem0tMTAuMTc4IDEwLjI4MyAzLjE4My0xLjU1NC0yLjc0OS0yLjE0Ny0uNDMzIDMuNzAxem02LjY5NS0xLjU1NCAzLjE5MiAxLjU1NC0uNDQzLTMuNzAxeiIvPjwvZz48cGF0aCBkPSJtMjAuMjQ0IDIzLjU5Ni0zLjE5Mi0xLjU1NC4yNTQgMi4wODEtLjAyOC44NzZ6bS05Ljg4NyAwIDIuOTY2IDEuNDAzLS4wMTktLjg3Ni4yMzUtMi4wODEtMy4xODMgMS41NTR6IiBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiLz48cGF0aCBkPSJtMTMuMzY5IDE4LjUyMS0yLjY1NS0uNzgxIDEuODc0LS44NTd6bTMuODUxIDAgLjc4MS0xLjYzOCAxLjg4My44NTctMi42NjUuNzgxeiIgZmlsbD0iIzIzMzQ0NyIgc3Ryb2tlPSIjMjMzNDQ3Ii8+PHBhdGggZD0ibTEwLjM1NyAyMy41OTYuNDUyLTMuODIzLTIuOTQ3LjA4NXptOS40MzUtMy44MjMuNDUyIDMuODIzIDIuNDk1LTMuNzM4em0yLjI0MS00LjIwOS01LjI5Mi4yMzUuNDkgMi43MjEuNzgyLTEuNjM4IDEuODgzLjg1N3ptLTExLjMxOCAyLjE3NSAxLjg4My0uODU3Ljc3MiAxLjYzOC40OTktMi43MjEtNS4zMDEtLjIzNXoiIGZpbGw9IiNjZDYxMTYiIHN0cm9rZT0iI2NkNjExNiIvPjxwYXRoIGQ9Im04LjU2NyAxNS41NjQgMi4yMjIgNC4zMzEtLjA3NS0yLjE1NnptMTEuMzI4IDIuMTc1LS4wOTQgMi4xNTYgMi4yMzItNC4zMzEtMi4xMzcgMi4xNzV6bS02LjAyNi0xLjk0LS40OTkgMi43MjEuNjIxIDMuMjExLjE0MS00LjIyOC0uMjY0LTEuNzA0em0yLjg3MiAwLS4yNTQgMS42OTUuMTEzIDQuMjM3LjYzMS0zLjIxMXoiIGZpbGw9IiNlNDc1MWYiIHN0cm9rZT0iI2U0NzUxZiIvPjxwYXRoIGQ9Im0xNy4yMyAxOC41Mi0uNjMxIDMuMjExLjQ1Mi4zMTEgMi43NS0yLjE0Ny4wOTQtMi4xNTZ6bS02LjUxNi0uNzgxLjA3NSAyLjE1NiAyLjc1IDIuMTQ3LjQ1Mi0uMzExLS42MjItMy4yMTF6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48cGF0aCBkPSJtMTcuMjc3IDI0Ljk5OS4wMjgtLjg3Ni0uMjM1LS4yMDdoLTMuNTVsLS4yMTcuMjA3LjAxOS44NzYtMi45NjYtMS40MDMgMS4wMzYuODQ4IDIuMSAxLjQ1OWgzLjYwNmwyLjEwOS0xLjQ1OSAxLjAzNi0uODQ4eiIgZmlsbD0iI2MwYWQ5ZSIgc3Ryb2tlPSIjYzBhZDllIi8+PHBhdGggZD0ibTE3LjA1MSAyMi4wNDItLjQ1Mi0uMzExaC0yLjYwOGwtLjQ1Mi4zMTEtLjIzNSAyLjA4MS4yMTctLjIwN2gzLjU1bC4yMzUuMjA3LS4yNTQtMi4wODF6IiBmaWxsPSIjMTYxNjE2IiBzdHJva2U9IiMxNjE2MTYiLz48cGF0aCBkPSJtMjYuNTA1IDExLjA1My44LTMuODQyLTEuMTk2LTMuNTY5LTkuMDU4IDYuNzIzIDMuNDg0IDIuOTQ3IDQuOTI1IDEuNDQxIDEuMDkyLTEuMjcxLS40NzEtLjMzOS43NTMtLjY4Ny0uNTg0LS40NTIuNzUzLS41NzQtLjQ5OS0uMzc3em0tMjMuMjExLTMuODQxLjggMy44NDItLjUwOC4zNzcuNzUzLjU3NC0uNTc0LjQ1Mi43NTMuNjg3LS40NzEuMzM5IDEuMDgzIDEuMjcxIDQuOTI1LTEuNDQxIDMuNDg0LTIuOTQ3LTkuMDU5LTYuNzIzeiIgZmlsbD0iIzc2M2QxNiIgc3Ryb2tlPSIjNzYzZDE2Ii8+PHBhdGggZD0ibTI1LjQ2IDE0Ljc1NC00LjkyNS0xLjQ0MSAxLjQ5NyAyLjI1MS0yLjIzMiA0LjMzMSAyLjkzOC0uMDM4aDQuMzc4bC0xLjY1Ny01LjEwNHptLTE1LjQwNS0xLjQ0MS00LjkyNSAxLjQ0MS0xLjYzOCA1LjEwNGg0LjM2OWwyLjkyOC4wMzgtMi4yMjItNC4zMzEgMS40ODgtMi4yNTF6bTYuNjg1IDIuNDg2LjMxMS01LjQzMyAxLjQzMS0zLjg3aC02LjM1NmwxLjQxMyAzLjg3LjMyOSA1LjQzMy4xMTMgMS43MTQuMDA5IDQuMjE5aDIuNjFsLjAxOS00LjIxOS4xMjItMS43MTR6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48L2c+PGNpcmNsZSBjeD0iMjMuNSIgY3k9IjIzLjUiIGZpbGw9IiMwMDAiIHI9IjYuNSIvPjxwYXRoIGQ9Im0yNy40NzMgMjUuNTQ1LTEuMzEgMS4zNjhjLS4wMjkuMDMtLjA2My4wNTMtLjEwMS4wN2EuMzEuMzEgMCAwIDEgLS4xMjEuMDI0aC02LjIwOWMtLjAzIDAtLjA1OS0uMDA4LS4wODMtLjAyNGEuMTUuMTUgMCAwIDEgLS4wNTYtLjA2NWMtLjAxMi0uMDI2LS4wMTUtLjA1Ni0uMDEtLjA4NHMuMDE4LS4wNTUuMDM5LS4wNzZsMS4zMTEtMS4zNjhjLjAyOC0uMDMuMDYzLS4wNTMuMTAxLS4wNjlhLjMxLjMxIDAgMCAxIC4xMjEtLjAyNWg2LjIwOGMuMDMgMCAuMDU5LjAwOC4wODMuMDI0YS4xNS4xNSAwIDAgMSAuMDU2LjA2NWMuMDEyLjAyNi4wMTUuMDU2LjAxLjA4NHMtLjAxOC4wNTUtLjAzOS4wNzZ6bS0xLjMxLTIuNzU2Yy0uMDI5LS4wMy0uMDYzLS4wNTMtLjEwMS0uMDdhLjMxLjMxIDAgMCAwIC0uMTIxLS4wMjRoLTYuMjA5Yy0uMDMgMC0uMDU5LjAwOC0uMDgzLjAyNHMtLjA0NC4wMzgtLjA1Ni4wNjUtLjAxNS4wNTYtLjAxLjA4NC4wMTguMDU1LjAzOS4wNzZsMS4zMTEgMS4zNjhjLjAyOC4wMy4wNjMuMDUzLjEwMS4wNjlhLjMxLjMxIDAgMCAwIC4xMjEuMDI1aDYuMjA4Yy4wMyAwIC4wNTktLjAwOC4wODMtLjAyNGEuMTUuMTUgMCAwIDAgLjA1Ni0uMDY1Yy4wMTItLjAyNi4wMTUtLjA1Ni4wMS0uMDg0cy0uMDE4LS4wNTUtLjAzOS0uMDc2em0tNi40MzEtLjk4M2g2LjIwOWEuMzEuMzEgMCAwIDAgLjEyMS0uMDI0Yy4wMzgtLjAxNi4wNzMtLjA0LjEwMS0uMDdsMS4zMS0xLjM2OGMuMDItLjAyMS4wMzQtLjA0Ny4wMzktLjA3NnMuMDAxLS4wNTgtLjAxLS4wODRhLjE1LjE1IDAgMCAwIC0uMDU2LS4wNjVjLS4wMjUtLjAxNi0uMDU0LS4wMjQtLjA4My0uMDI0aC02LjIwOGEuMzEuMzEgMCAwIDAgLS4xMjEuMDI1Yy0uMDM4LjAxNi0uMDcyLjA0LS4xMDEuMDY5bC0xLjMxIDEuMzY4Yy0uMDIuMDIxLS4wMzQuMDQ3LS4wMzkuMDc2cy0uMDAxLjA1OC4wMS4wODQuMDMxLjA0OS4wNTYuMDY1LjA1NC4wMjQuMDgzLjAyNHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";
var et = function(e, t, r, n) {
    if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e)
}, Uj = function(e, t, r, n, i) {
    if (n === "m")
        throw new TypeError("Private method is not writable");
    if (n === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(e, r) : i ? i.value = r : t.set(e, r),
    r
}, _l, Is, vp, xp, Ep, mr, Sp, X4, e6, _p, Ap, Mp, Ip, Tp;
class zj {
    constructor() {
        _l.add(this),
        Is.set(this, {}),
        vp.set(this, "1.0.0"),
        xp.set(this, "MetaMask"),
        Ep.set(this, Dj),
        mr.set(this, null),
        Sp.set(this, (t, r) => {
            var n;
            return (n = et(this, Is, "f")[t]) != null && n.push(r) || (et(this, Is, "f")[t] = [r]),
            () => et(this, _l, "m", e6).call(this, t, r)
        }
        ),
        _p.set(this, async () => {
            if (!et(this, mr, "f")) {
                let t;
                try {
                    t = (await Be( () => import("./sAPkX2kl.js"), __vite__mapDeps([37, 38]), import.meta.url)).default
                } catch {
                    throw new Error("Unable to load Solflare MetaMask SDK")
                }
                Uj(this, mr, new t, "f"),
                et(this, mr, "f").on("standard_change", r => et(this, _l, "m", X4).call(this, "change", r))
            }
            return this.accounts.length || await et(this, mr, "f").connect(),
            {
                accounts: this.accounts
            }
        }
        ),
        Ap.set(this, async () => {
            et(this, mr, "f") && await et(this, mr, "f").disconnect()
        }
        ),
        Mp.set(this, async (...t) => {
            if (!et(this, mr, "f"))
                throw new It;
            return await et(this, mr, "f").standardSignAndSendTransaction(...t)
        }
        ),
        Ip.set(this, async (...t) => {
            if (!et(this, mr, "f"))
                throw new It;
            return await et(this, mr, "f").standardSignTransaction(...t)
        }
        ),
        Tp.set(this, async (...t) => {
            if (!et(this, mr, "f"))
                throw new It;
            return await et(this, mr, "f").standardSignMessage(...t)
        }
        )
    }
    get version() {
        return et(this, vp, "f")
    }
    get name() {
        return et(this, xp, "f")
    }
    get icon() {
        return et(this, Ep, "f")
    }
    get chains() {
        return [Bj, Pj, jj]
    }
    get features() {
        return {
            [P9]: {
                version: "1.0.0",
                connect: et(this, _p, "f")
            },
            [j9]: {
                version: "1.0.0",
                disconnect: et(this, Ap, "f")
            },
            [D9]: {
                version: "1.0.0",
                on: et(this, Sp, "f")
            },
            [N9]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signAndSendTransaction: et(this, Mp, "f")
            },
            [B9]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signTransaction: et(this, Ip, "f")
            },
            [R9]: {
                version: "1.0.0",
                signMessage: et(this, Tp, "f")
            }
        }
    }
    get accounts() {
        return et(this, mr, "f") ? et(this, mr, "f").standardAccounts : []
    }
}
Is = new WeakMap,
vp = new WeakMap,
xp = new WeakMap,
Ep = new WeakMap,
mr = new WeakMap,
Sp = new WeakMap,
_p = new WeakMap,
Ap = new WeakMap,
Mp = new WeakMap,
Ip = new WeakMap,
Tp = new WeakMap,
_l = new WeakSet,
X4 = function(t, ...r) {
    var n;
    (n = et(this, Is, "f")[t]) == null || n.forEach(i => i.apply(null, r))
}
,
e6 = function(t, r) {
    var n;
    et(this, Is, "f")[t] = (n = et(this, Is, "f")[t]) == null ? void 0 : n.filter(i => r !== i)
}
;
let Wb = !1;
function $j() {
    Wb || (Nj(new zj),
    Wb = !0)
}
async function Fj() {
    const e = "solflare-detect-metamask";
    function t() {
        window.postMessage({
            target: "metamask-contentscript",
            data: {
                name: "metamask-provider",
                data: {
                    id: e,
                    jsonrpc: "2.0",
                    method: "wallet_getSnaps"
                }
            }
        }, window.location.origin)
    }
    function r(n) {
        var s, o;
        const i = n.data;
        (i == null ? void 0 : i.target) === "metamask-inpage" && ((s = i.data) == null ? void 0 : s.name) === "metamask-provider" && (((o = i.data.data) == null ? void 0 : o.id) === e ? (window.removeEventListener("message", r),
        i.data.data.error || $j()) : t())
    }
    window.addEventListener("message", r),
    window.setTimeout( () => window.removeEventListener("message", r), 5e3),
    t()
}
const Hj = "Solflare";
class qj extends Zg {
    constructor(t={}) {
        super(),
        this.name = Hj,
        this.url = "https://solflare.com",
        this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+",
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this._readyState = typeof window > "u" || typeof document > "u" ? Qe.Unsupported : Qe.Loadable,
        this._disconnected = () => {
            const r = this._wallet;
            r && (r.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new id),
            this.emit("disconnect"))
        }
        ,
        this._accountChanged = r => {
            if (!r)
                return;
            const n = this._publicKey;
            if (n) {
                try {
                    r = new Ne(r.toBytes())
                } catch (i) {
                    this.emit("error", new Ws(i == null ? void 0 : i.message,i));
                    return
                }
                n.equals(r) || (this._publicKey = r,
                this.emit("connect", r))
            }
        }
        ,
        this._connecting = !1,
        this._publicKey = null,
        this._wallet = null,
        this._config = t,
        this._readyState !== Qe.Unsupported && (E3( () => {
            var r;
            return (r = window.solflare) != null && r.isSolflare || window.SolflareApp ? (this._readyState = Qe.Installed,
            this.emit("readyStateChange", this._readyState),
            !0) : !1
        }
        ),
        Fj())
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        var t;
        return !!((t = this._wallet) != null && t.connected)
    }
    get readyState() {
        return this._readyState
    }
    async autoConnect() {
        this.readyState === Qe.Loadable && rp() || await this.connect()
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Qe.Loadable && this._readyState !== Qe.Installed)
                throw new qs;
            if (this.readyState === Qe.Loadable && rp()) {
                const i = encodeURIComponent(window.location.href)
                  , s = encodeURIComponent(window.location.origin);
                window.location.href = `https://solflare.com/ul/v1/browse/${i}?ref=${s}`;
                return
            }
            let t;
            try {
                t = (await Be( () => import("./BDy-5V57.js"), __vite__mapDeps([39, 38]), import.meta.url)).default
            } catch (i) {
                throw new L9(i == null ? void 0 : i.message,i)
            }
            let r;
            try {
                r = new t({
                    network: this._config.network
                })
            } catch (i) {
                throw new Xa(i == null ? void 0 : i.message,i)
            }
            if (this._connecting = !0,
            !r.connected)
                try {
                    await r.connect()
                } catch (i) {
                    throw new Qo(i == null ? void 0 : i.message,i)
                }
            if (!r.publicKey)
                throw new Qo;
            let n;
            try {
                n = new Ne(r.publicKey.toBytes())
            } catch (i) {
                throw new Ws(i == null ? void 0 : i.message,i)
            }
            r.on("disconnect", this._disconnected),
            r.on("accountChanged", this._accountChanged),
            this._wallet = r,
            this._publicKey = n,
            this.emit("connect", n)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const t = this._wallet;
        if (t) {
            t.off("disconnect", this._disconnected),
            t.off("accountChanged", this._accountChanged),
            this._wallet = null,
            this._publicKey = null;
            try {
                await t.disconnect()
            } catch (r) {
                this.emit("error", new Yg(r == null ? void 0 : r.message,r))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(t, r, n={}) {
        try {
            const i = this._wallet;
            if (!i)
                throw new It;
            try {
                const {signers: s, ...o} = n;
                return sf(t) ? s != null && s.length && t.sign(s) : (t = await this.prepareTransaction(t, r, o),
                s != null && s.length && t.partialSign(...s)),
                o.preflightCommitment = o.preflightCommitment || r.commitment,
                await i.signAndSendTransaction(t, o)
            } catch (s) {
                throw s instanceof nr ? s : new fi(s == null ? void 0 : s.message,s)
            }
        } catch (i) {
            throw this.emit("error", i),
            i
        }
    }
    async signTransaction(t) {
        try {
            const r = this._wallet;
            if (!r)
                throw new It;
            try {
                return await r.signTransaction(t) || t
            } catch (n) {
                throw new fn(n == null ? void 0 : n.message,n)
            }
        } catch (r) {
            throw this.emit("error", r),
            r
        }
    }
    async signAllTransactions(t) {
        try {
            const r = this._wallet;
            if (!r)
                throw new It;
            try {
                return await r.signAllTransactions(t) || t
            } catch (n) {
                throw new fn(n == null ? void 0 : n.message,n)
            }
        } catch (r) {
            throw this.emit("error", r),
            r
        }
    }
    async signMessage(t) {
        try {
            const r = this._wallet;
            if (!r)
                throw new It;
            try {
                return await r.signMessage(t, "utf8")
            } catch (n) {
                throw new Eu(n == null ? void 0 : n.message,n)
            }
        } catch (r) {
            throw this.emit("error", r),
            r
        }
    }
}
const Wj = _t(e => {
    const t = {
        wallets: [new kj, new qj],
        autoConnect: !1
    };
    e.vueApp.use(Tj, t)
}
)
  , Vj = _t(e => {
    function t(i, s=24, o) {
        o = o ?? "...";
        var a = document.createElement("div");
        a.innerHTML = i;
        var u = a.textContent;
        return u.length > s ? u.slice(0, s) + o : u
    }
    function r(i) {
        var o = i;
        if (o && o.startsWith("0x") && o.length == 42) {
            let c = o.slice(0, 6)
              , l = o.slice(38, 42);
            o = c + "..." + l
        }
        var a = document.createElement("div");
        a.innerHTML = o;
        var u = a.textContent;
        return u.length > 24 ? u.slice(0, 24) : u
    }
    function n(i) {
        return !i || isNaN(i) ? i : new Intl.NumberFormat("en",{
            notation: "compact"
        }).format(Number(i))
    }
    e.provide("truncate", t),
    e.provide("shorten_address", r),
    e.provide("shorten_number", n)
}
)
  , Kj = () => da("color-mode").value
  , Gj = "2.12.0"
  , km = e => e
  , Qj = () => `viem@${Gj}`;
class Dr extends Error {
    constructor(t, r={}) {
        var s;
        super(),
        Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ViemError"
        }),
        Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: Qj()
        });
        const n = r.cause instanceof Dr ? r.cause.details : (s = r.cause) != null && s.message ? r.cause.message : r.details
          , i = r.cause instanceof Dr && r.cause.docsPath || r.docsPath;
        this.message = [t || "An error occurred.", "", ...r.metaMessages ? [...r.metaMessages, ""] : [], ...i ? [`Docs: https://viem.sh${i}${r.docsSlug ? `#${r.docsSlug}` : ""}`] : [], ...n ? [`Details: ${n}`] : [], `Version: ${this.version}`].join(`
`),
        r.cause && (this.cause = r.cause),
        this.details = n,
        this.docsPath = i,
        this.metaMessages = r.metaMessages,
        this.shortMessage = t
    }
    walk(t) {
        return t6(this, t)
    }
}
function t6(e, t) {
    return t != null && t(e) ? e : e && typeof e == "object" && "cause"in e ? t6(e.cause, t) : t ? null : e
}
class Yj extends Dr {
    constructor({max: t, min: r, signed: n, size: i, value: s}) {
        super(`Number "${s}" is not in safe ${i ? `${i * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${t ? `(${r} to ${t})` : `(above ${r})`}`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "IntegerOutOfRangeError"
        })
    }
}
class Zj extends Dr {
    constructor({givenSize: t, maxSize: r}) {
        super(`Size cannot exceed ${r} bytes. Given size: ${t} bytes.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SizeOverflowError"
        })
    }
}
class r6 extends Dr {
    constructor({size: t, targetSize: r, type: n}) {
        super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${t}) exceeds padding size (${r}).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SizeExceedsPaddingSizeError"
        })
    }
}
function wa(e, {dir: t, size: r=32}={}) {
    return typeof e == "string" ? Jj(e, {
        dir: t,
        size: r
    }) : Xj(e, {
        dir: t,
        size: r
    })
}
function Jj(e, {dir: t, size: r=32}={}) {
    if (r === null)
        return e;
    const n = e.replace("0x", "");
    if (n.length > r * 2)
        throw new r6({
            size: Math.ceil(n.length / 2),
            targetSize: r,
            type: "hex"
        });
    return `0x${n[t === "right" ? "padEnd" : "padStart"](r * 2, "0")}`
}
function Xj(e, {dir: t, size: r=32}={}) {
    if (r === null)
        return e;
    if (e.length > r)
        throw new r6({
            size: e.length,
            targetSize: r,
            type: "bytes"
        });
    const n = new Uint8Array(r);
    for (let i = 0; i < r; i++) {
        const s = t === "right";
        n[s ? i : r - i - 1] = e[s ? i : e.length - i - 1]
    }
    return n
}
function Lm(e, {strict: t=!0}={}) {
    return !e || typeof e != "string" ? !1 : t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x")
}
function Vb(e) {
    return Lm(e, {
        strict: !1
    }) ? Math.ceil((e.length - 2) / 2) : e.length
}
const eD = new TextEncoder;
function tD(e, t={}) {
    return typeof e == "number" || typeof e == "bigint" ? nD(e, t) : typeof e == "boolean" ? rD(e, t) : Lm(e) ? n6(e, t) : i6(e, t)
}
function rD(e, t={}) {
    const r = new Uint8Array(1);
    return r[0] = Number(e),
    typeof t.size == "number" ? (gc(r, {
        size: t.size
    }),
    wa(r, {
        size: t.size
    })) : r
}
const ni = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function Kb(e) {
    if (e >= ni.zero && e <= ni.nine)
        return e - ni.zero;
    if (e >= ni.A && e <= ni.F)
        return e - (ni.A - 10);
    if (e >= ni.a && e <= ni.f)
        return e - (ni.a - 10)
}
function n6(e, t={}) {
    let r = e;
    t.size && (gc(r, {
        size: t.size
    }),
    r = wa(r, {
        dir: "right",
        size: t.size
    }));
    let n = r.slice(2);
    n.length % 2 && (n = `0${n}`);
    const i = n.length / 2
      , s = new Uint8Array(i);
    for (let o = 0, a = 0; o < i; o++) {
        const u = Kb(n.charCodeAt(a++))
          , c = Kb(n.charCodeAt(a++));
        if (u === void 0 || c === void 0)
            throw new Dr(`Invalid byte sequence ("${n[a - 2]}${n[a - 1]}" in "${n}").`);
        s[o] = u * 16 + c
    }
    return s
}
function nD(e, t) {
    const r = ia(e, t);
    return n6(r)
}
function i6(e, t={}) {
    const r = eD.encode(e);
    return typeof t.size == "number" ? (gc(r, {
        size: t.size
    }),
    wa(r, {
        dir: "right",
        size: t.size
    })) : r
}
function gc(e, {size: t}) {
    if (Vb(e) > t)
        throw new Zj({
            givenSize: Vb(e),
            maxSize: t
        })
}
const iD = Array.from({
    length: 256
}, (e, t) => t.toString(16).padStart(2, "0"));
function sD(e, t={}) {
    return typeof e == "number" || typeof e == "bigint" ? ia(e, t) : typeof e == "string" ? uD(e, t) : typeof e == "boolean" ? oD(e, t) : s6(e, t)
}
function oD(e, t={}) {
    const r = `0x${Number(e)}`;
    return typeof t.size == "number" ? (gc(r, {
        size: t.size
    }),
    wa(r, {
        size: t.size
    })) : r
}
function s6(e, t={}) {
    let r = "";
    for (let i = 0; i < e.length; i++)
        r += iD[e[i]];
    const n = `0x${r}`;
    return typeof t.size == "number" ? (gc(n, {
        size: t.size
    }),
    wa(n, {
        dir: "right",
        size: t.size
    })) : n
}
function ia(e, t={}) {
    const {signed: r, size: n} = t
      , i = BigInt(e);
    let s;
    n ? r ? s = (1n << BigInt(n) * 8n - 1n) - 1n : s = 2n ** (BigInt(n) * 8n) - 1n : typeof e == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
    const o = typeof s == "bigint" && r ? -s - 1n : 0;
    if (s && i > s || i < o) {
        const u = typeof e == "bigint" ? "n" : "";
        throw new Yj({
            max: s ? `${s}${u}` : void 0,
            min: `${o}${u}`,
            signed: r,
            size: n,
            value: `${e}${u}`
        })
    }
    const a = `0x${(r && i < 0 ? (1n << BigInt(n * 8)) + BigInt(i) : i).toString(16)}`;
    return n ? wa(a, {
        size: n
    }) : a
}
const aD = new TextEncoder;
function uD(e, t={}) {
    const r = aD.encode(e);
    return s6(r, t)
}
class cD extends Dr {
    constructor({address: t}) {
        super(`Address "${t}" is invalid.`, {
            metaMessages: ["- Address must be a hex value of 20 bytes (40 hex characters).", "- Address must match its checksum counterpart."]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAddressError"
        })
    }
}
class o6 extends Map {
    constructor(t) {
        super(),
        Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.maxSize = t
    }
    set(t, r) {
        return super.set(t, r),
        this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value),
        this
    }
}
function Gb(e) {
    if (!Number.isSafeInteger(e) || e < 0)
        throw new Error(`Wrong positive integer: ${e}`)
}
function a6(e, ...t) {
    if (!(e instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length))
        throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)
}
function Qb(e, t=!0) {
    if (e.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (t && e.finished)
        throw new Error("Hash#digest() has already been called")
}
function lD(e, t) {
    a6(e);
    const r = t.outputLen;
    if (e.length < r)
        throw new Error(`digestInto() expects output buffer of length at least ${r}`)
}
const Xc = BigInt(2 ** 32 - 1)
  , Yb = BigInt(32);
function fD(e, t=!1) {
    return t ? {
        h: Number(e & Xc),
        l: Number(e >> Yb & Xc)
    } : {
        h: Number(e >> Yb & Xc) | 0,
        l: Number(e & Xc) | 0
    }
}
function dD(e, t=!1) {
    let r = new Uint32Array(e.length)
      , n = new Uint32Array(e.length);
    for (let i = 0; i < e.length; i++) {
        const {h: s, l: o} = fD(e[i], t);
        [r[i],n[i]] = [s, o]
    }
    return [r, n]
}
const hD = (e, t, r) => e << r | t >>> 32 - r
  , pD = (e, t, r) => t << r | e >>> 32 - r
  , gD = (e, t, r) => t << r - 32 | e >>> 64 - r
  , mD = (e, t, r) => e << r - 32 | t >>> 64 - r;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const yD = e => e instanceof Uint8Array
  , bD = e => new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength / 4))
  , wD = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!wD)
    throw new Error("Non little-endian hardware is not supported");
function vD(e) {
    if (typeof e != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e))
}
function u6(e) {
    if (typeof e == "string" && (e = vD(e)),
    !yD(e))
        throw new Error(`expected Uint8Array, got ${typeof e}`);
    return e
}
class xD {
    clone() {
        return this._cloneInto()
    }
}
function ED(e) {
    const t = n => e().update(u6(n)).digest()
      , r = e();
    return t.outputLen = r.outputLen,
    t.blockLen = r.blockLen,
    t.create = () => e(),
    t
}
const [c6,l6,f6] = [[], [], []]
  , SD = BigInt(0)
  , La = BigInt(1)
  , _D = BigInt(2)
  , AD = BigInt(7)
  , MD = BigInt(256)
  , ID = BigInt(113);
for (let e = 0, t = La, r = 1, n = 0; e < 24; e++) {
    [r,n] = [n, (2 * r + 3 * n) % 5],
    c6.push(2 * (5 * n + r)),
    l6.push((e + 1) * (e + 2) / 2 % 64);
    let i = SD;
    for (let s = 0; s < 7; s++)
        t = (t << La ^ (t >> AD) * ID) % MD,
        t & _D && (i ^= La << (La << BigInt(s)) - La);
    f6.push(i)
}
const [TD,CD] = dD(f6, !0)
  , Zb = (e, t, r) => r > 32 ? gD(e, t, r) : hD(e, t, r)
  , Jb = (e, t, r) => r > 32 ? mD(e, t, r) : pD(e, t, r);
function kD(e, t=24) {
    const r = new Uint32Array(10);
    for (let n = 24 - t; n < 24; n++) {
        for (let o = 0; o < 10; o++)
            r[o] = e[o] ^ e[o + 10] ^ e[o + 20] ^ e[o + 30] ^ e[o + 40];
        for (let o = 0; o < 10; o += 2) {
            const a = (o + 8) % 10
              , u = (o + 2) % 10
              , c = r[u]
              , l = r[u + 1]
              , p = Zb(c, l, 1) ^ r[a]
              , h = Jb(c, l, 1) ^ r[a + 1];
            for (let g = 0; g < 50; g += 10)
                e[o + g] ^= p,
                e[o + g + 1] ^= h
        }
        let i = e[2]
          , s = e[3];
        for (let o = 0; o < 24; o++) {
            const a = l6[o]
              , u = Zb(i, s, a)
              , c = Jb(i, s, a)
              , l = c6[o];
            i = e[l],
            s = e[l + 1],
            e[l] = u,
            e[l + 1] = c
        }
        for (let o = 0; o < 50; o += 10) {
            for (let a = 0; a < 10; a++)
                r[a] = e[o + a];
            for (let a = 0; a < 10; a++)
                e[o + a] ^= ~r[(a + 2) % 10] & r[(a + 4) % 10]
        }
        e[0] ^= TD[n],
        e[1] ^= CD[n]
    }
    r.fill(0)
}
class Om extends xD {
    constructor(t, r, n, i=!1, s=24) {
        if (super(),
        this.blockLen = t,
        this.suffix = r,
        this.outputLen = n,
        this.enableXOF = i,
        this.rounds = s,
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        Gb(n),
        0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200),
        this.state32 = bD(this.state)
    }
    keccak() {
        kD(this.state32, this.rounds),
        this.posOut = 0,
        this.pos = 0
    }
    update(t) {
        Qb(this);
        const {blockLen: r, state: n} = this;
        t = u6(t);
        const i = t.length;
        for (let s = 0; s < i; ) {
            const o = Math.min(r - this.pos, i - s);
            for (let a = 0; a < o; a++)
                n[this.pos++] ^= t[s++];
            this.pos === r && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: t, suffix: r, pos: n, blockLen: i} = this;
        t[n] ^= r,
        r & 128 && n === i - 1 && this.keccak(),
        t[i - 1] ^= 128,
        this.keccak()
    }
    writeInto(t) {
        Qb(this, !1),
        a6(t),
        this.finish();
        const r = this.state
          , {blockLen: n} = this;
        for (let i = 0, s = t.length; i < s; ) {
            this.posOut >= n && this.keccak();
            const o = Math.min(n - this.posOut, s - i);
            t.set(r.subarray(this.posOut, this.posOut + o), i),
            this.posOut += o,
            i += o
        }
        return t
    }
    xofInto(t) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(t)
    }
    xof(t) {
        return Gb(t),
        this.xofInto(new Uint8Array(t))
    }
    digestInto(t) {
        if (lD(t, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(t),
        this.destroy(),
        t
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        this.state.fill(0)
    }
    _cloneInto(t) {
        const {blockLen: r, suffix: n, outputLen: i, rounds: s, enableXOF: o} = this;
        return t || (t = new Om(r,n,i,o,s)),
        t.state32.set(this.state32),
        t.pos = this.pos,
        t.posOut = this.posOut,
        t.finished = this.finished,
        t.rounds = s,
        t.suffix = n,
        t.outputLen = i,
        t.enableXOF = o,
        t.destroyed = this.destroyed,
        t
    }
}
const LD = (e, t, r) => ED( () => new Om(t,e,r))
  , OD = LD(1, 136, 256 / 8);
function ND(e, t) {
    const r = t || "hex"
      , n = OD(Lm(e, {
        strict: !1
    }) ? tD(e) : e);
    return r === "bytes" ? n : sD(n)
}
const z0 = new o6(8192);
function d6(e, t) {
    if (z0.has(`${e}.${t}`))
        return z0.get(`${e}.${t}`);
    const r = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase()
      , n = ND(i6(r), "bytes")
      , i = (t ? r.substring(`${t}0x`.length) : r).split("");
    for (let o = 0; o < 40; o += 2)
        n[o >> 1] >> 4 >= 8 && i[o] && (i[o] = i[o].toUpperCase()),
        (n[o >> 1] & 15) >= 8 && i[o + 1] && (i[o + 1] = i[o + 1].toUpperCase());
    const s = `0x${i.join("")}`;
    return z0.set(`${e}.${t}`, s),
    s
}
function Ts(e, t) {
    if (!BD(e, {
        strict: !1
    }))
        throw new cD({
            address: e
        });
    return d6(e, t)
}
const RD = /^0x[a-fA-F0-9]{40}$/
  , $0 = new o6(8192);
function BD(e, t) {
    const {strict: r=!0} = t ?? {};
    if ($0.has(e))
        return $0.get(e);
    const n = RD.test(e) ? e.toLowerCase() === e ? !0 : r ? d6(e) === e : !0 : !1;
    return $0.set(e, n),
    n
}
function PD(e) {
    return typeof e == "string" ? {
        address: e,
        type: "json-rpc"
    } : e
}
const To = (e, t, r) => JSON.stringify(e, (n, i) => {
    const s = typeof i == "bigint" ? i.toString() : i;
    return typeof t == "function" ? t(n, s) : s
}
, r);
class ru extends Dr {
    constructor({body: t, details: r, headers: n, status: i, url: s}) {
        super("HTTP request failed.", {
            details: r,
            metaMessages: [i && `Status: ${i}`, `URL: ${km(s)}`, t && `Request body: ${To(t)}`].filter(Boolean)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "HttpRequestError"
        }),
        Object.defineProperty(this, "body", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "headers", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "status", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "url", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.body = t,
        this.headers = n,
        this.status = i,
        this.url = s
    }
}
class h6 extends Dr {
    constructor({body: t, error: r, url: n}) {
        super("RPC Request failed.", {
            cause: r,
            details: r.message,
            metaMessages: [`URL: ${km(n)}`, `Request body: ${To(t)}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcRequestError"
        }),
        Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.code = r.code
    }
}
class Xb extends Dr {
    constructor({body: t, url: r}) {
        super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${km(r)}`, `Request body: ${To(t)}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TimeoutError"
        })
    }
}
const jD = -1;
class zr extends Dr {
    constructor(t, {code: r, docsPath: n, metaMessages: i, shortMessage: s}) {
        super(s, {
            cause: t,
            docsPath: n,
            metaMessages: i || (t == null ? void 0 : t.metaMessages)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcError"
        }),
        Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.name = t.name,
        this.code = t instanceof h6 ? t.code : r ?? jD
    }
}
class va extends zr {
    constructor(t, r) {
        super(t, r),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderRpcError"
        }),
        Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.data = r.data
    }
}
class Iu extends zr {
    constructor(t) {
        super(t, {
            code: Iu.code,
            shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ParseRpcError"
        })
    }
}
Object.defineProperty(Iu, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32700
});
class Tu extends zr {
    constructor(t) {
        super(t, {
            code: Tu.code,
            shortMessage: "JSON is not a valid request object."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidRequestRpcError"
        })
    }
}
Object.defineProperty(Tu, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32600
});
class Cu extends zr {
    constructor(t) {
        super(t, {
            code: Cu.code,
            shortMessage: "The method does not exist / is not available."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MethodNotFoundRpcError"
        })
    }
}
Object.defineProperty(Cu, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32601
});
class ku extends zr {
    constructor(t) {
        super(t, {
            code: ku.code,
            shortMessage: ["Invalid parameters were provided to the RPC method.", "Double check you have provided the correct parameters."].join(`
`)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidParamsRpcError"
        })
    }
}
Object.defineProperty(ku, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32602
});
class sa extends zr {
    constructor(t) {
        super(t, {
            code: sa.code,
            shortMessage: "An internal error was received."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InternalRpcError"
        })
    }
}
Object.defineProperty(sa, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32603
});
class Lu extends zr {
    constructor(t) {
        super(t, {
            code: Lu.code,
            shortMessage: ["Missing or invalid parameters.", "Double check you have provided the correct parameters."].join(`
`)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidInputRpcError"
        })
    }
}
Object.defineProperty(Lu, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32e3
});
class Ou extends zr {
    constructor(t) {
        super(t, {
            code: Ou.code,
            shortMessage: "Requested resource not found."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ResourceNotFoundRpcError"
        })
    }
}
Object.defineProperty(Ou, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32001
});
class ts extends zr {
    constructor(t) {
        super(t, {
            code: ts.code,
            shortMessage: "Requested resource not available."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ResourceUnavailableRpcError"
        })
    }
}
Object.defineProperty(ts, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32002
});
class Nu extends zr {
    constructor(t) {
        super(t, {
            code: Nu.code,
            shortMessage: "Transaction creation failed."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionRejectedRpcError"
        })
    }
}
Object.defineProperty(Nu, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32003
});
class Ru extends zr {
    constructor(t) {
        super(t, {
            code: Ru.code,
            shortMessage: "Method is not implemented."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MethodNotSupportedRpcError"
        })
    }
}
Object.defineProperty(Ru, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32004
});
class oa extends zr {
    constructor(t) {
        super(t, {
            code: oa.code,
            shortMessage: "Request exceeds defined limit."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "LimitExceededRpcError"
        })
    }
}
Object.defineProperty(oa, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32005
});
class Bu extends zr {
    constructor(t) {
        super(t, {
            code: Bu.code,
            shortMessage: "Version of JSON-RPC protocol is not supported."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "JsonRpcVersionUnsupportedError"
        })
    }
}
Object.defineProperty(Bu, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32006
});
class ar extends va {
    constructor(t) {
        super(t, {
            code: ar.code,
            shortMessage: "User rejected the request."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UserRejectedRequestError"
        })
    }
}
Object.defineProperty(ar, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4001
});
class Pu extends va {
    constructor(t) {
        super(t, {
            code: Pu.code,
            shortMessage: "The requested method and/or account has not been authorized by the user."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnauthorizedProviderError"
        })
    }
}
Object.defineProperty(Pu, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4100
});
class ju extends va {
    constructor(t) {
        super(t, {
            code: ju.code,
            shortMessage: "The Provider does not support the requested method."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnsupportedProviderMethodError"
        })
    }
}
Object.defineProperty(ju, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4200
});
class Du extends va {
    constructor(t) {
        super(t, {
            code: Du.code,
            shortMessage: "The Provider is disconnected from all chains."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderDisconnectedError"
        })
    }
}
Object.defineProperty(Du, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4900
});
class Uu extends va {
    constructor(t) {
        super(t, {
            code: Uu.code,
            shortMessage: "The Provider is not connected to the requested chain."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainDisconnectedError"
        })
    }
}
Object.defineProperty(Uu, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4901
});
class bi extends va {
    constructor(t) {
        super(t, {
            code: bi.code,
            shortMessage: "An error occurred when attempting to switch chain."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SwitchChainError"
        })
    }
}
Object.defineProperty(bi, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4902
});
class DD extends zr {
    constructor(t) {
        super(t, {
            shortMessage: "An unknown RPC error occurred."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnknownRpcError"
        })
    }
}
const F0 = new Map;
function UD({fn: e, id: t, shouldSplitBatch: r, wait: n=0, sort: i}) {
    const s = async () => {
        const l = u();
        o();
        const p = l.map( ({args: h}) => h);
        p.length !== 0 && e(p).then(h => {
            var g;
            i && Array.isArray(h) && h.sort(i);
            for (let S = 0; S < l.length; S++) {
                const {pendingPromise: x} = l[S];
                (g = x.resolve) == null || g.call(x, [h[S], h])
            }
        }
        ).catch(h => {
            var g;
            for (let S = 0; S < l.length; S++) {
                const {pendingPromise: x} = l[S];
                (g = x.reject) == null || g.call(x, h)
            }
        }
        )
    }
      , o = () => F0.delete(t)
      , a = () => u().map( ({args: l}) => l)
      , u = () => F0.get(t) || []
      , c = l => F0.set(t, [...u(), l]);
    return {
        flush: o,
        async schedule(l) {
            const p = {}
              , h = new Promise( (x, v) => {
                p.resolve = x,
                p.reject = v
            }
            );
            return (r == null ? void 0 : r([...a(), l])) && s(),
            u().length > 0 ? (c({
                args: l,
                pendingPromise: p
            }),
            h) : (c({
                args: l,
                pendingPromise: p
            }),
            setTimeout(s, n),
            h)
        }
    }
}
async function zD(e) {
    return new Promise(t => setTimeout(t, e))
}
function p6(e, {delay: t=100, retryCount: r=2, shouldRetry: n= () => !0}={}) {
    return new Promise( (i, s) => {
        const o = async ({count: a=0}={}) => {
            const u = async ({error: c}) => {
                const l = typeof t == "function" ? t({
                    count: a,
                    error: c
                }) : t;
                l && await zD(l),
                o({
                    count: a + 1
                })
            }
            ;
            try {
                const c = await e();
                i(c)
            } catch (c) {
                if (a < r && await n({
                    count: a,
                    error: c
                }))
                    return u({
                        error: c
                    });
                s(c)
            }
        }
        ;
        o()
    }
    )
}
function $D(e, t={}) {
    return async (r, n={}) => {
        const {retryDelay: i=150, retryCount: s=3} = {
            ...t,
            ...n
        };
        return p6(async () => {
            try {
                return await e(r)
            } catch (o) {
                const a = o;
                switch (a.code) {
                case Iu.code:
                    throw new Iu(a);
                case Tu.code:
                    throw new Tu(a);
                case Cu.code:
                    throw new Cu(a);
                case ku.code:
                    throw new ku(a);
                case sa.code:
                    throw new sa(a);
                case Lu.code:
                    throw new Lu(a);
                case Ou.code:
                    throw new Ou(a);
                case ts.code:
                    throw new ts(a);
                case Nu.code:
                    throw new Nu(a);
                case Ru.code:
                    throw new Ru(a);
                case oa.code:
                    throw new oa(a);
                case Bu.code:
                    throw new Bu(a);
                case ar.code:
                    throw new ar(a);
                case Pu.code:
                    throw new Pu(a);
                case ju.code:
                    throw new ju(a);
                case Du.code:
                    throw new Du(a);
                case Uu.code:
                    throw new Uu(a);
                case bi.code:
                    throw new bi(a);
                case 5e3:
                    throw new ar(a);
                default:
                    throw o instanceof Dr ? o : new DD(a)
                }
            }
        }
        , {
            delay: ({count: o, error: a}) => {
                var u;
                if (a && a instanceof ru) {
                    const c = (u = a == null ? void 0 : a.headers) == null ? void 0 : u.get("Retry-After");
                    if (c != null && c.match(/\d/))
                        return Number.parseInt(c) * 1e3
                }
                return ~~(1 << o) * i
            }
            ,
            retryCount: s,
            shouldRetry: ({error: o}) => FD(o)
        })
    }
}
function FD(e) {
    return "code"in e && typeof e.code == "number" ? e.code === -1 || e.code === oa.code || e.code === sa.code : e instanceof ru && e.status ? e.status === 403 || e.status === 408 || e.status === 413 || e.status === 429 || e.status === 500 || e.status === 502 || e.status === 503 || e.status === 504 : !0
}
function HD(e) {
    return {
        formatters: void 0,
        fees: void 0,
        serializers: void 0,
        ...e
    }
}
function g6(e, {errorInstance: t=new Error("timed out"), timeout: r, signal: n}) {
    return new Promise( (i, s) => {
        (async () => {
            let o;
            try {
                const a = new AbortController;
                r > 0 && (o = setTimeout( () => {
                    n ? a.abort() : s(t)
                }
                , r)),
                i(await e({
                    signal: (a == null ? void 0 : a.signal) || null
                }))
            } catch (a) {
                a.name === "AbortError" && s(t),
                s(a)
            } finally {
                clearTimeout(o)
            }
        }
        )()
    }
    )
}
function qD() {
    return {
        current: 0,
        take() {
            return this.current++
        },
        reset() {
            this.current = 0
        }
    }
}
const ew = qD();
function WD(e, t={}) {
    return {
        async request(r) {
            var p;
            const {body: n, onRequest: i=t.onRequest, onResponse: s=t.onResponse, timeout: o=t.timeout ?? 1e4} = r
              , a = {
                ...t.fetchOptions ?? {},
                ...r.fetchOptions ?? {}
            }
              , {headers: u, method: c, signal: l} = a;
            try {
                const h = await g6(async ({signal: S}) => {
                    const x = {
                        ...a,
                        body: Array.isArray(n) ? To(n.map(M => ({
                            jsonrpc: "2.0",
                            id: M.id ?? ew.take(),
                            ...M
                        }))) : To({
                            jsonrpc: "2.0",
                            id: n.id ?? ew.take(),
                            ...n
                        }),
                        headers: {
                            ...u,
                            "Content-Type": "application/json"
                        },
                        method: c || "POST",
                        signal: l || (o > 0 ? S : null)
                    }
                      , v = new Request(e,x);
                    return i && await i(v),
                    await fetch(e, x)
                }
                , {
                    errorInstance: new Xb({
                        body: n,
                        url: e
                    }),
                    timeout: o,
                    signal: !0
                });
                s && await s(h);
                let g;
                if ((p = h.headers.get("Content-Type")) != null && p.startsWith("application/json") ? g = await h.json() : (g = await h.text(),
                g = JSON.parse(g || "{}")),
                !h.ok)
                    throw new ru({
                        body: n,
                        details: To(g.error) || h.statusText,
                        headers: h.headers,
                        status: h.status,
                        url: e
                    });
                return g
            } catch (h) {
                throw h instanceof ru || h instanceof Xb ? h : new ru({
                    body: n,
                    details: h.message,
                    url: e
                })
            }
        }
    }
}
function VD(e) {
    const t = r => e(r.detail);
    return window.addEventListener("eip6963:announceProvider", t),
    window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),
    () => window.removeEventListener("eip6963:announceProvider", t)
}
function KD() {
    const e = new Set;
    let t = [];
    const r = () => VD(i => {
        t.some( ({info: s}) => s.uuid === i.info.uuid) || (t = [...t, i],
        e.forEach(s => s(t, {
            added: [i]
        })))
    }
    );
    let n = r();
    return {
        _listeners() {
            return e
        },
        clear() {
            e.forEach(i => i([], {
                removed: [...t]
            })),
            t = []
        },
        destroy() {
            this.clear(),
            e.clear(),
            n()
        },
        findProvider({rdns: i}) {
            return t.find(s => s.info.rdns === i)
        },
        getProviders() {
            return t
        },
        reset() {
            this.clear(),
            n(),
            n = r()
        },
        subscribe(i, {emitImmediately: s}={}) {
            return e.add(i),
            s && i(t, {
                added: t
            }),
            () => e.delete(i)
        }
    }
}
const Cp = 256;
let el = Cp, tl;
function GD(e=11) {
    if (!tl || el + e > Cp * 2) {
        tl = "",
        el = 0;
        for (let t = 0; t < Cp; t++)
            tl += (256 + Math.random() * 256 | 0).toString(16).substring(1)
    }
    return tl.substring(el, el++ + e)
}
function QD(e) {
    const {batch: t, cacheTime: r=e.pollingInterval ?? 4e3, ccipRead: n, key: i="base", name: s="Base Client", pollingInterval: o=4e3, type: a="base"} = e
      , u = e.chain
      , c = e.account ? PD(e.account) : void 0
      , {config: l, request: p, value: h} = e.transport({
        chain: u,
        pollingInterval: o
    })
      , g = {
        ...l,
        ...h
    }
      , S = {
        account: c,
        batch: t,
        cacheTime: r,
        ccipRead: n,
        chain: u,
        key: i,
        name: s,
        pollingInterval: o,
        request: p,
        transport: g,
        type: a,
        uid: GD()
    };
    function x(v) {
        return I => {
            const M = I(v);
            for (const k in S)
                delete M[k];
            const A = {
                ...v,
                ...M
            };
            return Object.assign(A, {
                extend: x(A)
            })
        }
    }
    return Object.assign(S, {
        extend: x(S)
    })
}
function YD({key: e, name: t, request: r, retryCount: n=3, retryDelay: i=150, timeout: s, type: o}, a) {
    return {
        config: {
            key: e,
            name: t,
            request: r,
            retryCount: n,
            retryDelay: i,
            timeout: s,
            type: o
        },
        request: $D(r, {
            retryCount: n,
            retryDelay: i
        }),
        value: a
    }
}
class ZD extends Dr {
    constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
            docsPath: "/docs/clients/intro"
        })
    }
}
function JD(e, t={}) {
    const {batch: r, fetchOptions: n, key: i="http", name: s="HTTP JSON-RPC", onFetchRequest: o, onFetchResponse: a, retryDelay: u} = t;
    return ({chain: c, retryCount: l, timeout: p}) => {
        const {batchSize: h=1e3, wait: g=0} = typeof r == "object" ? r : {}
          , S = t.retryCount ?? l
          , x = p ?? t.timeout ?? 1e4
          , v = e || (c == null ? void 0 : c.rpcUrls.default.http[0]);
        if (!v)
            throw new ZD;
        const I = WD(v, {
            fetchOptions: n,
            onRequest: o,
            onResponse: a,
            timeout: x
        });
        return YD({
            key: i,
            name: s,
            async request({method: M, params: A}) {
                const k = {
                    method: M,
                    params: A
                }
                  , {schedule: L} = UD({
                    id: v,
                    wait: g,
                    shouldSplitBatch(K) {
                        return K.length > h
                    },
                    fn: K => I.request({
                        body: K
                    }),
                    sort: (K, G) => K.id - G.id
                })
                  , O = async K => r ? L(K) : [await I.request({
                    body: K
                })]
                  , [{error: $, result: D}] = await O(k);
                if ($)
                    throw new h6({
                        body: k,
                        error: $,
                        url: v
                    });
                return D
            },
            retryCount: S,
            retryDelay: u,
            timeout: x,
            type: "http"
        }, {
            fetchOptions: n,
            url: v
        })
    }
}
var XD = {
    BASE_URL: "./",
    MODE: "production",
    DEV: !1,
    PROD: !0,
    SSR: !1
};
const eU = e => (t, r, n) => {
    const i = n.subscribe;
    return n.subscribe = (o, a, u) => {
        let c = o;
        if (a) {
            const l = (u == null ? void 0 : u.equalityFn) || Object.is;
            let p = o(n.getState());
            c = h => {
                const g = o(h);
                if (!l(p, g)) {
                    const S = p;
                    a(p = g, S)
                }
            }
            ,
            u != null && u.fireImmediately && a(p, p)
        }
        return i(c)
    }
    ,
    e(t, r, n)
}
  , tU = eU;
function rU(e, t) {
    let r;
    try {
        r = e()
    } catch {
        return
    }
    return {
        getItem: i => {
            var s;
            const o = u => u === null ? null : JSON.parse(u, t == null ? void 0 : t.reviver)
              , a = (s = r.getItem(i)) != null ? s : null;
            return a instanceof Promise ? a.then(o) : o(a)
        }
        ,
        setItem: (i, s) => r.setItem(i, JSON.stringify(s, t == null ? void 0 : t.replacer)),
        removeItem: i => r.removeItem(i)
    }
}
const zu = e => t => {
    try {
        const r = e(t);
        return r instanceof Promise ? r : {
            then(n) {
                return zu(n)(r)
            },
            catch(n) {
                return this
            }
        }
    } catch (r) {
        return {
            then(n) {
                return this
            },
            catch(n) {
                return zu(n)(r)
            }
        }
    }
}
  , nU = (e, t) => (r, n, i) => {
    let s = {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: v => v,
        version: 0,
        merge: (v, I) => ({
            ...I,
            ...v
        }),
        ...t
    }
      , o = !1;
    const a = new Set
      , u = new Set;
    let c;
    try {
        c = s.getStorage()
    } catch {}
    if (!c)
        return e( (...v) => {
            console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),
            r(...v)
        }
        , n, i);
    const l = zu(s.serialize)
      , p = () => {
        const v = s.partialize({
            ...n()
        });
        let I;
        const M = l({
            state: v,
            version: s.version
        }).then(A => c.setItem(s.name, A)).catch(A => {
            I = A
        }
        );
        if (I)
            throw I;
        return M
    }
      , h = i.setState;
    i.setState = (v, I) => {
        h(v, I),
        p()
    }
    ;
    const g = e( (...v) => {
        r(...v),
        p()
    }
    , n, i);
    let S;
    const x = () => {
        var v;
        if (!c)
            return;
        o = !1,
        a.forEach(M => M(n()));
        const I = ((v = s.onRehydrateStorage) == null ? void 0 : v.call(s, n())) || void 0;
        return zu(c.getItem.bind(c))(s.name).then(M => {
            if (M)
                return s.deserialize(M)
        }
        ).then(M => {
            if (M)
                if (typeof M.version == "number" && M.version !== s.version) {
                    if (s.migrate)
                        return s.migrate(M.state, M.version);
                    console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                } else
                    return M.state
        }
        ).then(M => {
            var A;
            return S = s.merge(M, (A = n()) != null ? A : g),
            r(S, !0),
            p()
        }
        ).then( () => {
            I == null || I(S, void 0),
            o = !0,
            u.forEach(M => M(S))
        }
        ).catch(M => {
            I == null || I(void 0, M)
        }
        )
    }
    ;
    return i.persist = {
        setOptions: v => {
            s = {
                ...s,
                ...v
            },
            v.getStorage && (c = v.getStorage())
        }
        ,
        clearStorage: () => {
            c == null || c.removeItem(s.name)
        }
        ,
        getOptions: () => s,
        rehydrate: () => x(),
        hasHydrated: () => o,
        onHydrate: v => (a.add(v),
        () => {
            a.delete(v)
        }
        ),
        onFinishHydration: v => (u.add(v),
        () => {
            u.delete(v)
        }
        )
    },
    x(),
    S || g
}
  , iU = (e, t) => (r, n, i) => {
    let s = {
        storage: rU( () => localStorage),
        partialize: x => x,
        version: 0,
        merge: (x, v) => ({
            ...v,
            ...x
        }),
        ...t
    }
      , o = !1;
    const a = new Set
      , u = new Set;
    let c = s.storage;
    if (!c)
        return e( (...x) => {
            console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),
            r(...x)
        }
        , n, i);
    const l = () => {
        const x = s.partialize({
            ...n()
        });
        return c.setItem(s.name, {
            state: x,
            version: s.version
        })
    }
      , p = i.setState;
    i.setState = (x, v) => {
        p(x, v),
        l()
    }
    ;
    const h = e( (...x) => {
        r(...x),
        l()
    }
    , n, i);
    let g;
    const S = () => {
        var x, v;
        if (!c)
            return;
        o = !1,
        a.forEach(M => {
            var A;
            return M((A = n()) != null ? A : h)
        }
        );
        const I = ((v = s.onRehydrateStorage) == null ? void 0 : v.call(s, (x = n()) != null ? x : h)) || void 0;
        return zu(c.getItem.bind(c))(s.name).then(M => {
            if (M)
                if (typeof M.version == "number" && M.version !== s.version) {
                    if (s.migrate)
                        return s.migrate(M.state, M.version);
                    console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                } else
                    return M.state
        }
        ).then(M => {
            var A;
            return g = s.merge(M, (A = n()) != null ? A : h),
            r(g, !0),
            l()
        }
        ).then( () => {
            I == null || I(g, void 0),
            g = n(),
            o = !0,
            u.forEach(M => M(g))
        }
        ).catch(M => {
            I == null || I(void 0, M)
        }
        )
    }
    ;
    return i.persist = {
        setOptions: x => {
            s = {
                ...s,
                ...x
            },
            x.storage && (c = x.storage)
        }
        ,
        clearStorage: () => {
            c == null || c.removeItem(s.name)
        }
        ,
        getOptions: () => s,
        rehydrate: () => S(),
        hasHydrated: () => o,
        onHydrate: x => (a.add(x),
        () => {
            a.delete(x)
        }
        ),
        onFinishHydration: x => (u.add(x),
        () => {
            u.delete(x)
        }
        )
    },
    s.skipHydration || S(),
    g || h
}
  , sU = (e, t) => "getStorage"in t || "serialize"in t || "deserialize"in t ? ((XD ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),
nU(e, t)) : iU(e, t)
  , oU = sU;
var aU = {
    BASE_URL: "./",
    MODE: "production",
    DEV: !1,
    PROD: !0,
    SSR: !1
};
const tw = e => {
    let t;
    const r = new Set
      , n = (u, c) => {
        const l = typeof u == "function" ? u(t) : u;
        if (!Object.is(l, t)) {
            const p = t;
            t = c ?? typeof l != "object" ? l : Object.assign({}, t, l),
            r.forEach(h => h(t, p))
        }
    }
      , i = () => t
      , a = {
        setState: n,
        getState: i,
        subscribe: u => (r.add(u),
        () => r.delete(u)),
        destroy: () => {
            (aU ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),
            r.clear()
        }
    };
    return t = e(n, i, a),
    a
}
  , H0 = e => e ? tw(e) : tw;
var m6 = {
    exports: {}
};
(function(e) {
    var t = Object.prototype.hasOwnProperty
      , r = "~";
    function n() {}
    Object.create && (n.prototype = Object.create(null),
    new n().__proto__ || (r = !1));
    function i(u, c, l) {
        this.fn = u,
        this.context = c,
        this.once = l || !1
    }
    function s(u, c, l, p, h) {
        if (typeof l != "function")
            throw new TypeError("The listener must be a function");
        var g = new i(l,p || u,h)
          , S = r ? r + c : c;
        return u._events[S] ? u._events[S].fn ? u._events[S] = [u._events[S], g] : u._events[S].push(g) : (u._events[S] = g,
        u._eventsCount++),
        u
    }
    function o(u, c) {
        --u._eventsCount === 0 ? u._events = new n : delete u._events[c]
    }
    function a() {
        this._events = new n,
        this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var c = [], l, p;
        if (this._eventsCount === 0)
            return c;
        for (p in l = this._events)
            t.call(l, p) && c.push(r ? p.slice(1) : p);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(l)) : c
    }
    ,
    a.prototype.listeners = function(c) {
        var l = r ? r + c : c
          , p = this._events[l];
        if (!p)
            return [];
        if (p.fn)
            return [p.fn];
        for (var h = 0, g = p.length, S = new Array(g); h < g; h++)
            S[h] = p[h].fn;
        return S
    }
    ,
    a.prototype.listenerCount = function(c) {
        var l = r ? r + c : c
          , p = this._events[l];
        return p ? p.fn ? 1 : p.length : 0
    }
    ,
    a.prototype.emit = function(c, l, p, h, g, S) {
        var x = r ? r + c : c;
        if (!this._events[x])
            return !1;
        var v = this._events[x], I = arguments.length, M, A;
        if (v.fn) {
            switch (v.once && this.removeListener(c, v.fn, void 0, !0),
            I) {
            case 1:
                return v.fn.call(v.context),
                !0;
            case 2:
                return v.fn.call(v.context, l),
                !0;
            case 3:
                return v.fn.call(v.context, l, p),
                !0;
            case 4:
                return v.fn.call(v.context, l, p, h),
                !0;
            case 5:
                return v.fn.call(v.context, l, p, h, g),
                !0;
            case 6:
                return v.fn.call(v.context, l, p, h, g, S),
                !0
            }
            for (A = 1,
            M = new Array(I - 1); A < I; A++)
                M[A - 1] = arguments[A];
            v.fn.apply(v.context, M)
        } else {
            var k = v.length, L;
            for (A = 0; A < k; A++)
                switch (v[A].once && this.removeListener(c, v[A].fn, void 0, !0),
                I) {
                case 1:
                    v[A].fn.call(v[A].context);
                    break;
                case 2:
                    v[A].fn.call(v[A].context, l);
                    break;
                case 3:
                    v[A].fn.call(v[A].context, l, p);
                    break;
                case 4:
                    v[A].fn.call(v[A].context, l, p, h);
                    break;
                default:
                    if (!M)
                        for (L = 1,
                        M = new Array(I - 1); L < I; L++)
                            M[L - 1] = arguments[L];
                    v[A].fn.apply(v[A].context, M)
                }
        }
        return !0
    }
    ,
    a.prototype.on = function(c, l, p) {
        return s(this, c, l, p, !1)
    }
    ,
    a.prototype.once = function(c, l, p) {
        return s(this, c, l, p, !0)
    }
    ,
    a.prototype.removeListener = function(c, l, p, h) {
        var g = r ? r + c : c;
        if (!this._events[g])
            return this;
        if (!l)
            return o(this, g),
            this;
        var S = this._events[g];
        if (S.fn)
            S.fn === l && (!h || S.once) && (!p || S.context === p) && o(this, g);
        else {
            for (var x = 0, v = [], I = S.length; x < I; x++)
                (S[x].fn !== l || h && !S[x].once || p && S[x].context !== p) && v.push(S[x]);
            v.length ? this._events[g] = v.length === 1 ? v[0] : v : o(this, g)
        }
        return this
    }
    ,
    a.prototype.removeAllListeners = function(c) {
        var l;
        return c ? (l = r ? r + c : c,
        this._events[l] && o(this, l)) : (this._events = new n,
        this._eventsCount = 0),
        this
    }
    ,
    a.prototype.off = a.prototype.removeListener,
    a.prototype.addListener = a.prototype.on,
    a.prefixed = r,
    a.EventEmitter = a,
    e.exports = a
}
)(m6);
var uU = m6.exports;
const cU = ic(uU);
var Oa = function(e, t, r, n) {
    if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e)
}, gs;
class lU {
    constructor(t) {
        Object.defineProperty(this, "uid", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: t
        }),
        gs.set(this, new cU)
    }
    on(t, r) {
        Oa(this, gs, "f").on(t, r)
    }
    once(t, r) {
        Oa(this, gs, "f").once(t, r)
    }
    off(t, r) {
        Oa(this, gs, "f").off(t, r)
    }
    emit(t, ...r) {
        const n = r[0];
        Oa(this, gs, "f").emit(t, {
            uid: this.uid,
            ...n
        })
    }
    listenerCount(t) {
        return Oa(this, gs, "f").listenerCount(t)
    }
}
gs = new WeakMap;
function fU(e) {
    return new lU(e)
}
function dU(e, t) {
    return JSON.parse(e, (r, n) => {
        let i = n;
        return (i == null ? void 0 : i.__type) === "bigint" && (i = BigInt(i.value)),
        (i == null ? void 0 : i.__type) === "Map" && (i = new Map(i.value)),
        (t == null ? void 0 : t(r, i)) ?? i
    }
    )
}
function rw(e, t) {
    return e.slice(0, t).join(".") || "."
}
function nw(e, t) {
    const {length: r} = e;
    for (let n = 0; n < r; ++n)
        if (e[n] === t)
            return n + 1;
    return 0
}
function hU(e, t) {
    const r = typeof e == "function"
      , n = typeof t == "function"
      , i = []
      , s = [];
    return function(a, u) {
        if (typeof u == "object")
            if (i.length) {
                const c = nw(i, this);
                c === 0 ? i[i.length] = this : (i.splice(c),
                s.splice(c)),
                s[s.length] = a;
                const l = nw(i, u);
                if (l !== 0)
                    return n ? t.call(this, a, u, rw(s, l)) : `[ref=${rw(s, l)}]`
            } else
                i[0] = u,
                s[0] = a;
        return r ? e.call(this, a, u) : u
    }
}
function pU(e, t, r, n) {
    return JSON.stringify(e, hU( (i, s) => {
        let o = s;
        return typeof o == "bigint" && (o = {
            __type: "bigint",
            value: s.toString()
        }),
        o instanceof Map && (o = {
            __type: "Map",
            value: Array.from(s.entries())
        }),
        (t == null ? void 0 : t(i, o)) ?? o
    }
    , n), r ?? void 0)
}
function gU(e) {
    const {deserialize: t=dU, key: r="wagmi", serialize: n=pU, storage: i=y6} = e;
    function s(o) {
        return o instanceof Promise ? o.then(a => a).catch( () => null) : o
    }
    return {
        ...i,
        key: r,
        async getItem(o, a) {
            const u = i.getItem(`${r}.${o}`)
              , c = await s(u);
            return c ? t(c) ?? null : a ?? null
        },
        async setItem(o, a) {
            const u = `${r}.${o}`;
            a === null ? await s(i.removeItem(u)) : await s(i.setItem(u, n(a)))
        },
        async removeItem(o) {
            await s(i.removeItem(`${r}.${o}`))
        }
    }
}
const y6 = {
    getItem: () => null,
    setItem: () => {}
    ,
    removeItem: () => {}
};
const Al = "2.8.0"
  , mU = () => `@wagmi/core@${Al}`;
var b6 = function(e, t, r, n) {
    if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e)
}, vf, w6;
let mc = class kp extends Error {
    get docsBaseUrl() {
        return "https://wagmi.sh/core"
    }
    get version() {
        return mU()
    }
    constructor(t, r={}) {
        var s;
        super(),
        vf.add(this),
        Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WagmiCoreError"
        });
        const n = r.cause instanceof kp ? r.cause.details : (s = r.cause) != null && s.message ? r.cause.message : r.details
          , i = r.cause instanceof kp && r.cause.docsPath || r.docsPath;
        this.message = [t || "An error occurred.", "", ...r.metaMessages ? [...r.metaMessages, ""] : [], ...i ? [`Docs: ${this.docsBaseUrl}${i}.html${r.docsSlug ? `#${r.docsSlug}` : ""}`] : [], ...n ? [`Details: ${n}`] : [], `Version: ${this.version}`].join(`
`),
        r.cause && (this.cause = r.cause),
        this.details = n,
        this.docsPath = i,
        this.metaMessages = r.metaMessages,
        this.shortMessage = t
    }
    walk(t) {
        return b6(this, vf, "m", w6).call(this, this, t)
    }
}
;
vf = new WeakSet,
w6 = function e(t, r) {
    return r != null && r(t) ? t : t.cause ? b6(this, vf, "m", e).call(this, t.cause, r) : t
}
;
class xf extends mc {
    constructor() {
        super("Chain not configured."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainNotConfiguredError"
        })
    }
}
class QF extends mc {
    constructor() {
        super("Connector already connected."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorAlreadyConnectedError"
        })
    }
}
class YF extends mc {
    constructor() {
        super("Connector not connected."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorNotConnectedError"
        })
    }
}
class ZF extends mc {
    constructor({address: t, connector: r}) {
        super(`Account "${t}" not found for connector "${r.name}".`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorAccountNotFoundError"
        })
    }
}
class ms extends mc {
    constructor() {
        super("Provider not found."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderNotFoundError"
        })
    }
}
const yU = /(rabby|trustwallet)/
  , bU = {
    coinbaseWallet: {
        id: "coinbaseWallet",
        name: "Coinbase Wallet",
        provider(e) {
            return e != null && e.coinbaseWalletExtension ? e.coinbaseWalletExtension : Ml(e, "isCoinbaseWallet")
        }
    },
    metaMask: {
        id: "metaMask",
        name: "MetaMask",
        provider(e) {
            return Ml(e, t => {
                if (!t.isMetaMask || t.isBraveWallet && !t._events && !t._state)
                    return !1;
                const r = ["isApexWallet", "isAvalanche", "isBitKeep", "isBlockWallet", "isKuCoinWallet", "isMathWallet", "isOkxWallet", "isOKExWallet", "isOneInchIOSWallet", "isOneInchAndroidWallet", "isOpera", "isPortal", "isRabby", "isTokenPocket", "isTokenary", "isZerion"];
                for (const n of r)
                    if (t[n])
                        return !1;
                return !0
            }
            )
        }
    },
    phantom: {
        id: "phantom",
        name: "Phantom",
        provider(e) {
            var t, r;
            return (t = e == null ? void 0 : e.phantom) != null && t.ethereum ? (r = e.phantom) == null ? void 0 : r.ethereum : Ml(e, "isPhantom")
        }
    }
};
bd.type = "injected";
function bd(e={}) {
    const {shimDisconnect: t=!0, unstable_shimAsyncInject: r} = e;
    function n() {
        const u = e.target;
        if (typeof u == "function") {
            const c = u();
            if (c)
                return c
        }
        return typeof u == "object" ? u : typeof u == "string" ? {
            ...bU[u] ?? {
                id: u,
                name: `${u[0].toUpperCase()}${u.slice(1)}`,
                provider: `is${u[0].toUpperCase()}${u.slice(1)}`
            }
        } : {
            id: "injected",
            name: "Injected",
            provider(c) {
                return c == null ? void 0 : c.ethereum
            }
        }
    }
    let i, s, o, a;
    return u => ({
        get icon() {
            return n().icon
        },
        get id() {
            return n().id
        },
        get name() {
            return n().name
        },
        get supportsSimulation() {
            return yU.test(this.id.toLowerCase())
        },
        type: bd.type,
        async setup() {
            const c = await this.getProvider();
            c && e.target && (o || (o = this.onConnect.bind(this),
            c.on("connect", o)),
            i || (i = this.onAccountsChanged.bind(this),
            c.on("accountsChanged", i)))
        },
        async connect({chainId: c, isReconnecting: l}={}) {
            var g, S, x, v, I, M;
            const p = await this.getProvider();
            if (!p)
                throw new ms;
            let h = [];
            if (l)
                h = await this.getAccounts().catch( () => []);
            else if (t)
                try {
                    h = (v = (x = (S = (g = (await p.request({
                        method: "wallet_requestPermissions",
                        params: [{
                            eth_accounts: {}
                        }]
                    }))[0]) == null ? void 0 : g.caveats) == null ? void 0 : S[0]) == null ? void 0 : x.value) == null ? void 0 : v.map(k => Ts(k))
                } catch (A) {
                    const k = A;
                    if (k.code === ar.code)
                        throw new ar(k);
                    if (k.code === ts.code)
                        throw k
                }
            try {
                !(h != null && h.length) && !l && (h = (await p.request({
                    method: "eth_requestAccounts"
                })).map(L => Ts(L))),
                o && (p.removeListener("connect", o),
                o = void 0),
                i || (i = this.onAccountsChanged.bind(this),
                p.on("accountsChanged", i)),
                s || (s = this.onChainChanged.bind(this),
                p.on("chainChanged", s)),
                a || (a = this.onDisconnect.bind(this),
                p.on("disconnect", a));
                let A = await this.getChainId();
                if (c && A !== c) {
                    const k = await this.switchChain({
                        chainId: c
                    }).catch(L => {
                        if (L.code === ar.code)
                            throw L;
                        return {
                            id: A
                        }
                    }
                    );
                    A = (k == null ? void 0 : k.id) ?? A
                }
                return t && await ((I = u.storage) == null ? void 0 : I.removeItem(`${this.id}.disconnected`)),
                e.target || await ((M = u.storage) == null ? void 0 : M.setItem("injected.connected", !0)),
                {
                    accounts: h,
                    chainId: A
                }
            } catch (A) {
                const k = A;
                throw k.code === ar.code ? new ar(k) : k.code === ts.code ? new ts(k) : k
            }
        },
        async disconnect() {
            var l, p;
            const c = await this.getProvider();
            if (!c)
                throw new ms;
            s && (c.removeListener("chainChanged", s),
            s = void 0),
            a && (c.removeListener("disconnect", a),
            a = void 0),
            o || (o = this.onConnect.bind(this),
            c.on("connect", o)),
            t && await ((l = u.storage) == null ? void 0 : l.setItem(`${this.id}.disconnected`, !0)),
            e.target || await ((p = u.storage) == null ? void 0 : p.removeItem("injected.connected"))
        },
        async getAccounts() {
            const c = await this.getProvider();
            if (!c)
                throw new ms;
            return (await c.request({
                method: "eth_accounts"
            })).map(p => Ts(p))
        },
        async getChainId() {
            const c = await this.getProvider();
            if (!c)
                throw new ms;
            const l = await c.request({
                method: "eth_chainId"
            });
            return Number(l)
        },
        async getProvider() {
            if (typeof window > "u")
                return;
            let c;
            const l = n();
            return typeof l.provider == "function" ? c = l.provider(window) : typeof l.provider == "string" ? c = Ml(window, l.provider) : c = l.provider,
            c && !c.removeListener && ("off"in c && typeof c.off == "function" ? c.removeListener = c.off : c.removeListener = () => {}
            ),
            c
        },
        async isAuthorized() {
            var c, l;
            try {
                if (t && await ((c = u.storage) == null ? void 0 : c.getItem(`${this.id}.disconnected`)) || !e.target && !await ((l = u.storage) == null ? void 0 : l.getItem("injected.connected")))
                    return !1;
                if (!await this.getProvider()) {
                    if (r !== void 0 && r !== !1) {
                        const S = async () => (typeof window < "u" && window.removeEventListener("ethereum#initialized", S),
                        !!await this.getProvider())
                          , x = typeof r == "number" ? r : 1e3;
                        if (await Promise.race([...typeof window < "u" ? [new Promise(I => window.addEventListener("ethereum#initialized", () => I(S()), {
                            once: !0
                        }))] : [], new Promise(I => setTimeout( () => I(S()), x))]))
                            return !0
                    }
                    throw new ms
                }
                return !!(await p6( () => g6( () => this.getAccounts(), {
                    timeout: 100
                }))).length
            } catch {
                return !1
            }
        },
        async switchChain({addEthereumChainParameter: c, chainId: l}) {
            var g, S, x, v;
            const p = await this.getProvider();
            if (!p)
                throw new ms;
            const h = u.chains.find(I => I.id === l);
            if (!h)
                throw new bi(new xf);
            try {
                return await Promise.all([p.request({
                    method: "wallet_switchEthereumChain",
                    params: [{
                        chainId: ia(l)
                    }]
                }).then(async () => {
                    await this.getChainId() === l && u.emitter.emit("change", {
                        chainId: l
                    })
                }
                ), new Promise(I => u.emitter.once("change", ({chainId: M}) => {
                    M === l && I()
                }
                ))]),
                h
            } catch (I) {
                const M = I;
                if (M.code === 4902 || ((S = (g = M == null ? void 0 : M.data) == null ? void 0 : g.originalError) == null ? void 0 : S.code) === 4902)
                    try {
                        const {default: A, ...k} = h.blockExplorers ?? {};
                        let L;
                        c != null && c.blockExplorerUrls ? L = c.blockExplorerUrls : A && (L = [A.url, ...Object.values(k).map(K => K.url)]);
                        let O;
                        (x = c == null ? void 0 : c.rpcUrls) != null && x.length ? O = c.rpcUrls : O = [((v = h.rpcUrls.default) == null ? void 0 : v.http[0]) ?? ""];
                        const $ = {
                            blockExplorerUrls: L,
                            chainId: ia(l),
                            chainName: (c == null ? void 0 : c.chainName) ?? h.name,
                            iconUrls: c == null ? void 0 : c.iconUrls,
                            nativeCurrency: (c == null ? void 0 : c.nativeCurrency) ?? h.nativeCurrency,
                            rpcUrls: O
                        };
                        if (await p.request({
                            method: "wallet_addEthereumChain",
                            params: [$]
                        }),
                        await this.getChainId() !== l)
                            throw new ar(new Error("User rejected switch after adding network."));
                        return h
                    } catch (A) {
                        throw new ar(A)
                    }
                throw M.code === ar.code ? new ar(M) : new bi(M)
            }
        },
        async onAccountsChanged(c) {
            var l;
            if (c.length === 0)
                this.onDisconnect();
            else if (u.emitter.listenerCount("connect")) {
                const p = (await this.getChainId()).toString();
                this.onConnect({
                    chainId: p
                }),
                t && await ((l = u.storage) == null ? void 0 : l.removeItem(`${this.id}.disconnected`))
            } else
                u.emitter.emit("change", {
                    accounts: c.map(p => Ts(p))
                })
        },
        onChainChanged(c) {
            const l = Number(c);
            u.emitter.emit("change", {
                chainId: l
            })
        },
        async onConnect(c) {
            const l = await this.getAccounts();
            if (l.length === 0)
                return;
            const p = Number(c.chainId);
            u.emitter.emit("connect", {
                accounts: l,
                chainId: p
            });
            const h = await this.getProvider();
            h && (o && (h.removeListener("connect", o),
            o = void 0),
            i || (i = this.onAccountsChanged.bind(this),
            h.on("accountsChanged", i)),
            s || (s = this.onChainChanged.bind(this),
            h.on("chainChanged", s)),
            a || (a = this.onDisconnect.bind(this),
            h.on("disconnect", a)))
        },
        async onDisconnect(c) {
            const l = await this.getProvider();
            c && c.code === 1013 && l && (await this.getAccounts()).length || (u.emitter.emit("disconnect"),
            l && (s && (l.removeListener("chainChanged", s),
            s = void 0),
            a && (l.removeListener("disconnect", a),
            a = void 0),
            o || (o = this.onConnect.bind(this),
            l.on("connect", o))))
        }
    })
}
function Ml(e, t) {
    function r(i) {
        return typeof t == "function" ? t(i) : typeof t == "string" ? i[t] : !0
    }
    const n = e.ethereum;
    if (n != null && n.providers)
        return n.providers.find(i => r(i));
    if (n && r(n))
        return n
}
const Lp = 256;
let rl = Lp, nl;
function wU(e=11) {
    if (!nl || rl + e > Lp * 2) {
        nl = "",
        rl = 0;
        for (let t = 0; t < Lp; t++)
            nl += (256 + Math.random() * 256 | 0).toString(16).substring(1)
    }
    return nl.substring(rl, rl++ + e)
}
function vU(e) {
    const {multiInjectedProviderDiscovery: t=!0, storage: r=gU({
        storage: typeof window < "u" && window.localStorage ? window.localStorage : y6
    }), syncConnectedChain: n=!0, ssr: i, ...s} = e
      , o = typeof window < "u" && t ? KD() : void 0
      , a = H0( () => s.chains)
      , u = H0( () => [...s.connectors ?? [], ...i ? [] : (o == null ? void 0 : o.getProviders().map(l)) ?? []].map(c));
    function c(k) {
        var $;
        const L = fU(wU())
          , O = {
            ...k({
                emitter: L,
                chains: a.getState(),
                storage: r
            }),
            emitter: L,
            uid: L.uid
        };
        return L.on("connect", M),
        ($ = O.setup) == null || $.call(O),
        O
    }
    function l(k) {
        const {info: L} = k
          , O = k.provider;
        return bd({
            target: {
                ...L,
                id: L.rdns,
                provider: O
            }
        })
    }
    const p = new Map;
    function h(k={}) {
        const L = k.chainId ?? v.getState().chainId
          , O = a.getState().find(D => D.id === L);
        if (k.chainId && !O)
            throw new xf;
        {
            const D = p.get(v.getState().chainId);
            if (D && !O)
                return D;
            if (!O)
                throw new xf
        }
        {
            const D = p.get(L);
            if (D)
                return D
        }
        let $;
        if (s.client)
            $ = s.client({
                chain: O
            });
        else {
            const D = O.id
              , K = a.getState().map(q => q.id)
              , G = {}
              , F = Object.entries(s);
            for (const [q,B] of F)
                if (!(q === "chains" || q === "client" || q === "connectors" || q === "transports"))
                    if (typeof B == "object")
                        if (D in B)
                            G[q] = B[D];
                        else {
                            if (K.some(b => b in B))
                                continue;
                            G[q] = B
                        }
                    else
                        G[q] = B;
            $ = QD({
                ...G,
                chain: O,
                batch: G.batch ?? {
                    multicall: !0
                },
                transport: q => s.transports[D]({
                    ...q,
                    connectors: u
                })
            })
        }
        return p.set(L, $),
        $
    }
    function g() {
        return {
            chainId: a.getState()[0].id,
            connections: new Map,
            current: null,
            status: "disconnected"
        }
    }
    let S;
    const x = "0.0.0-canary-";
    Al.startsWith(x) ? S = parseInt(Al.replace(x, "")) : S = parseInt(Al.split(".")[0] ?? "0");
    const v = H0(tU(r ? oU(g, {
        migrate(k, L) {
            if (L === S)
                return k;
            const O = g()
              , $ = k && typeof k == "object" && "chainId"in k && typeof k.chainId == "number" ? k.chainId : O.chainId;
            return {
                ...O,
                chainId: $
            }
        },
        name: "store",
        partialize(k) {
            return {
                connections: {
                    __type: "Map",
                    value: Array.from(k.connections.entries()).map( ([L,O]) => {
                        const {id: $, name: D, type: K, uid: G} = O.connector;
                        return [L, {
                            ...O,
                            connector: {
                                id: $,
                                name: D,
                                type: K,
                                uid: G
                            }
                        }]
                    }
                    )
                },
                chainId: k.chainId,
                current: k.current
            }
        },
        skipHydration: i,
        storage: r,
        version: S
    }) : g));
    n && v.subscribe( ({connections: k, current: L}) => {
        var O;
        return L ? (O = k.get(L)) == null ? void 0 : O.chainId : void 0
    }
    , k => {
        if (a.getState().some(O => O.id === k))
            return v.setState(O => ({
                ...O,
                chainId: k ?? O.chainId
            }))
    }
    ),
    o == null || o.subscribe(k => {
        const L = new Map;
        for (const $ of u.getState())
            L.set($.id, !0);
        const O = [];
        for (const $ of k) {
            const D = c(l($));
            L.has(D.id) || O.push(D)
        }
        r && !v.persist.hasHydrated() || u.setState($ => [...$, ...O], !0)
    }
    );
    function I(k) {
        v.setState(L => {
            const O = L.connections.get(k.uid);
            return O ? {
                ...L,
                connections: new Map(L.connections).set(k.uid, {
                    accounts: k.accounts ?? O.accounts,
                    chainId: k.chainId ?? O.chainId,
                    connector: O.connector
                })
            } : L
        }
        )
    }
    function M(k) {
        v.getState().status === "connecting" || v.getState().status === "reconnecting" || v.setState(L => {
            const O = u.getState().find($ => $.uid === k.uid);
            return O ? (O.emitter.listenerCount("connect") && O.emitter.off("connect", I),
            O.emitter.listenerCount("change") || O.emitter.on("change", I),
            O.emitter.listenerCount("disconnect") || O.emitter.on("disconnect", A),
            {
                ...L,
                connections: new Map(L.connections).set(k.uid, {
                    accounts: k.accounts,
                    chainId: k.chainId,
                    connector: O
                }),
                current: k.uid,
                status: "connected"
            }) : L
        }
        )
    }
    function A(k) {
        v.setState(L => {
            const O = L.connections.get(k.uid);
            if (O) {
                const D = O.connector;
                D.emitter.listenerCount("change") && O.connector.emitter.off("change", I),
                D.emitter.listenerCount("disconnect") && O.connector.emitter.off("disconnect", A),
                D.emitter.listenerCount("connect") || O.connector.emitter.on("connect", M)
            }
            if (L.connections.delete(k.uid),
            L.connections.size === 0)
                return {
                    ...L,
                    connections: new Map,
                    current: null,
                    status: "disconnected"
                };
            const $ = L.connections.values().next().value;
            return {
                ...L,
                connections: new Map(L.connections),
                current: $.connector.uid
            }
        }
        )
    }
    return {
        get chains() {
            return a.getState()
        },
        get connectors() {
            return u.getState()
        },
        storage: r,
        getClient: h,
        get state() {
            return v.getState()
        },
        setState(k) {
            let L;
            typeof k == "function" ? L = k(v.getState()) : L = k;
            const O = g();
            typeof L != "object" && (L = O),
            Object.keys(O).some(D => !(D in L)) && (L = O),
            v.setState(L, !0)
        },
        subscribe(k, L, O) {
            return v.subscribe(k, L, O ? {
                ...O,
                fireImmediately: O.emitImmediately
            } : void 0)
        },
        _internal: {
            mipd: o,
            store: v,
            ssr: !!i,
            syncConnectedChain: n,
            transports: s.transports,
            chains: {
                setState(k) {
                    const L = typeof k == "function" ? k(a.getState()) : k;
                    if (L.length !== 0)
                        return a.setState(L, !0)
                },
                subscribe(k) {
                    return a.subscribe(k)
                }
            },
            connectors: {
                providerDetailToConnector: l,
                setup: c,
                setState(k) {
                    return u.setState(typeof k == "function" ? k(u.getState()) : k, !0)
                },
                subscribe(k) {
                    return u.subscribe(k)
                }
            },
            events: {
                change: I,
                connect: M,
                disconnect: A
            }
        }
    }
}
let q0 = !1;
async function xU(e, t={}) {
    var c, l;
    if (q0)
        return [];
    q0 = !0,
    e.setState(p => ({
        ...p,
        status: p.current ? "reconnecting" : "connecting"
    }));
    const r = [];
    if ((c = t.connectors) != null && c.length)
        for (const p of t.connectors) {
            let h;
            typeof p == "function" ? h = e._internal.connectors.setup(p) : h = p,
            r.push(h)
        }
    else
        r.push(...e.connectors);
    let n;
    try {
        n = await ((l = e.storage) == null ? void 0 : l.getItem("recentConnectorId"))
    } catch {}
    const i = {};
    for (const [,p] of e.state.connections)
        i[p.connector.id] = 1;
    n && (i[n] = 0);
    const s = Object.keys(i).length > 0 ? [...r].sort( (p, h) => (i[p.id] ?? 10) - (i[h.id] ?? 10)) : r;
    let o = !1;
    const a = []
      , u = [];
    for (const p of s) {
        const h = await p.getProvider();
        if (!h || u.some(x => x === h) || !await p.isAuthorized())
            continue;
        const S = await p.connect({
            isReconnecting: !0
        }).catch( () => null);
        S && (p.emitter.off("connect", e._internal.events.connect),
        p.emitter.on("change", e._internal.events.change),
        p.emitter.on("disconnect", e._internal.events.disconnect),
        e.setState(x => {
            const v = new Map(o ? x.connections : new Map).set(p.uid, {
                accounts: S.accounts,
                chainId: S.chainId,
                connector: p
            });
            return {
                ...x,
                current: o ? x.current : p.uid,
                connections: v
            }
        }
        ),
        a.push({
            accounts: S.accounts,
            chainId: S.chainId,
            connector: p
        }),
        u.push(h),
        o = !0)
    }
    return (e.state.status === "reconnecting" || e.state.status === "connecting") && (o ? e.setState(p => ({
        ...p,
        status: "connected"
    })) : e.setState(p => ({
        ...p,
        connections: new Map,
        current: null,
        status: "disconnected"
    }))),
    q0 = !1,
    a
}
function EU(e, t) {
    const {initialState: r, reconnectOnMount: n} = t;
    return r && !e._internal.store.persist.hasHydrated() && e.setState({
        ...r,
        connections: n ? r.connections : new Map,
        status: n ? "reconnecting" : "disconnected"
    }),
    {
        async onMount() {
            var i;
            if (e._internal.ssr) {
                await e._internal.store.persist.rehydrate();
                const s = (i = e._internal.mipd) == null ? void 0 : i.getProviders().map(e._internal.connectors.providerDetailToConnector).map(e._internal.connectors.setup);
                e._internal.connectors.setState(o => [...o, ...s ?? []])
            }
            n ? xU(e) : e.storage && e.setState(s => ({
                ...s,
                connections: new Map
            }))
        }
    }
}
const SU = "use-wagmi-config"
  , _U = {
    install: (e, t) => {
        const {config: r, initialState: n, reconnectOnMount: i=!0} = t
          , {onMount: s} = EU(r, {
            initialState: n,
            reconnectOnMount: i
        });
        r._internal.ssr || s();
        const o = Ue(!0);
        Cn(a => {
            o.value && r._internal.ssr && (s(),
            a( () => {
                o.value = !1
            }
            ))
        }
        ),
        e.provide(SU, r)
    }
};
var wd = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(e) {
        return this.listeners.add(e),
        this.onSubscribe(),
        () => {
            this.listeners.delete(e),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
  , yc = typeof window > "u" || "Deno"in globalThis;
function xn() {}
function AU(e, t) {
    return typeof e == "function" ? e(t) : e
}
function MU(e) {
    return typeof e == "number" && e >= 0 && e !== 1 / 0
}
function IU(e, t) {
    return Math.max(e + (t || 0) - Date.now(), 0)
}
function iw(e, t) {
    const {type: r="all", exact: n, fetchStatus: i, predicate: s, queryKey: o, stale: a} = e;
    if (o) {
        if (n) {
            if (t.queryHash !== Nm(o, t.options))
                return !1
        } else if (!Fu(t.queryKey, o))
            return !1
    }
    if (r !== "all") {
        const u = t.isActive();
        if (r === "active" && !u || r === "inactive" && u)
            return !1
    }
    return !(typeof a == "boolean" && t.isStale() !== a || i && i !== t.state.fetchStatus || s && !s(t))
}
function sw(e, t) {
    const {exact: r, status: n, predicate: i, mutationKey: s} = e;
    if (s) {
        if (!t.options.mutationKey)
            return !1;
        if (r) {
            if ($u(t.options.mutationKey) !== $u(s))
                return !1
        } else if (!Fu(t.options.mutationKey, s))
            return !1
    }
    return !(n && t.state.status !== n || i && !i(t))
}
function Nm(e, t) {
    return ((t == null ? void 0 : t.queryKeyHashFn) || $u)(e)
}
function $u(e) {
    return JSON.stringify(e, (t, r) => Op(r) ? Object.keys(r).sort().reduce( (n, i) => (n[i] = r[i],
    n), {}) : r)
}
function Fu(e, t) {
    return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some(r => !Fu(e[r], t[r])) : !1
}
function v6(e, t) {
    if (e === t)
        return e;
    const r = ow(e) && ow(t);
    if (r || Op(e) && Op(t)) {
        const n = r ? e : Object.keys(e)
          , i = n.length
          , s = r ? t : Object.keys(t)
          , o = s.length
          , a = r ? [] : {};
        let u = 0;
        for (let c = 0; c < o; c++) {
            const l = r ? c : s[c];
            (!r && n.includes(l) || r) && e[l] === void 0 && t[l] === void 0 ? (a[l] = void 0,
            u++) : (a[l] = v6(e[l], t[l]),
            a[l] === e[l] && e[l] !== void 0 && u++)
        }
        return i === o && u === i ? e : a
    }
    return t
}
function JF(e, t) {
    if (!t || Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const r in e)
        if (e[r] !== t[r])
            return !1;
    return !0
}
function ow(e) {
    return Array.isArray(e) && e.length === Object.keys(e).length
}
function Op(e) {
    if (!aw(e))
        return !1;
    const t = e.constructor;
    if (t === void 0)
        return !0;
    const r = t.prototype;
    return !(!aw(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype)
}
function aw(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}
function TU(e) {
    return new Promise(t => {
        setTimeout(t, e)
    }
    )
}
function CU(e, t, r) {
    return typeof r.structuralSharing == "function" ? r.structuralSharing(e, t) : r.structuralSharing !== !1 ? v6(e, t) : t
}
function kU(e, t, r=0) {
    const n = [...e, t];
    return r && n.length > r ? n.slice(1) : n
}
function LU(e, t, r=0) {
    const n = [t, ...e];
    return r && n.length > r ? n.slice(0, -1) : n
}
var Rm = Symbol(), Cs, zi, Co, Cw, OU = (Cw = class extends wd {
    constructor() {
        super();
        Xe(this, Cs, void 0);
        Xe(this, zi, void 0);
        Xe(this, Co, void 0);
        Fe(this, Co, t => {
            if (!yc && window.addEventListener) {
                const r = () => t();
                return window.addEventListener("visibilitychange", r, !1),
                () => {
                    window.removeEventListener("visibilitychange", r)
                }
            }
        }
        )
    }
    onSubscribe() {
        le(this, zi) || this.setEventListener(le(this, Co))
    }
    onUnsubscribe() {
        var t;
        this.hasListeners() || ((t = le(this, zi)) == null || t.call(this),
        Fe(this, zi, void 0))
    }
    setEventListener(t) {
        var r;
        Fe(this, Co, t),
        (r = le(this, zi)) == null || r.call(this),
        Fe(this, zi, t(n => {
            typeof n == "boolean" ? this.setFocused(n) : this.onFocus()
        }
        ))
    }
    setFocused(t) {
        le(this, Cs) !== t && (Fe(this, Cs, t),
        this.onFocus())
    }
    onFocus() {
        const t = this.isFocused();
        this.listeners.forEach(r => {
            r(t)
        }
        )
    }
    isFocused() {
        var t;
        return typeof le(this, Cs) == "boolean" ? le(this, Cs) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden"
    }
}
,
Cs = new WeakMap,
zi = new WeakMap,
Co = new WeakMap,
Cw), x6 = new OU, ko, $i, Lo, kw, NU = (kw = class extends wd {
    constructor() {
        super();
        Xe(this, ko, !0);
        Xe(this, $i, void 0);
        Xe(this, Lo, void 0);
        Fe(this, Lo, t => {
            if (!yc && window.addEventListener) {
                const r = () => t(!0)
                  , n = () => t(!1);
                return window.addEventListener("online", r, !1),
                window.addEventListener("offline", n, !1),
                () => {
                    window.removeEventListener("online", r),
                    window.removeEventListener("offline", n)
                }
            }
        }
        )
    }
    onSubscribe() {
        le(this, $i) || this.setEventListener(le(this, Lo))
    }
    onUnsubscribe() {
        var t;
        this.hasListeners() || ((t = le(this, $i)) == null || t.call(this),
        Fe(this, $i, void 0))
    }
    setEventListener(t) {
        var r;
        Fe(this, Lo, t),
        (r = le(this, $i)) == null || r.call(this),
        Fe(this, $i, t(this.setOnline.bind(this)))
    }
    setOnline(t) {
        le(this, ko) !== t && (Fe(this, ko, t),
        this.listeners.forEach(n => {
            n(t)
        }
        ))
    }
    isOnline() {
        return le(this, ko)
    }
}
,
ko = new WeakMap,
$i = new WeakMap,
Lo = new WeakMap,
kw), Ef = new NU;
function RU(e) {
    return Math.min(1e3 * 2 ** e, 3e4)
}
function E6(e) {
    return (e ?? "online") === "online" ? Ef.isOnline() : !0
}
var S6 = class {
    constructor(e) {
        this.revert = e == null ? void 0 : e.revert,
        this.silent = e == null ? void 0 : e.silent
    }
}
;
function W0(e) {
    return e instanceof S6
}
function _6(e) {
    let t = !1, r = 0, n = !1, i, s, o;
    const a = new Promise( (I, M) => {
        s = I,
        o = M
    }
    )
      , u = I => {
        var M;
        n || (S(new S6(I)),
        (M = e.abort) == null || M.call(e))
    }
      , c = () => {
        t = !0
    }
      , l = () => {
        t = !1
    }
      , p = () => x6.isFocused() && (e.networkMode === "always" || Ef.isOnline()) && e.canRun()
      , h = () => E6(e.networkMode) && e.canRun()
      , g = I => {
        var M;
        n || (n = !0,
        (M = e.onSuccess) == null || M.call(e, I),
        i == null || i(),
        s(I))
    }
      , S = I => {
        var M;
        n || (n = !0,
        (M = e.onError) == null || M.call(e, I),
        i == null || i(),
        o(I))
    }
      , x = () => new Promise(I => {
        var M;
        i = A => {
            (n || p()) && I(A)
        }
        ,
        (M = e.onPause) == null || M.call(e)
    }
    ).then( () => {
        var I;
        i = void 0,
        n || (I = e.onContinue) == null || I.call(e)
    }
    )
      , v = () => {
        if (n)
            return;
        let I;
        try {
            I = e.fn()
        } catch (M) {
            I = Promise.reject(M)
        }
        Promise.resolve(I).then(g).catch(M => {
            var $;
            if (n)
                return;
            const A = e.retry ?? (yc ? 0 : 3)
              , k = e.retryDelay ?? RU
              , L = typeof k == "function" ? k(r, M) : k
              , O = A === !0 || typeof A == "number" && r < A || typeof A == "function" && A(r, M);
            if (t || !O) {
                S(M);
                return
            }
            r++,
            ($ = e.onFail) == null || $.call(e, r, M),
            TU(L).then( () => p() ? void 0 : x()).then( () => {
                t ? S(M) : v()
            }
            )
        }
        )
    }
    ;
    return {
        promise: a,
        cancel: u,
        continue: () => (i == null || i(),
        a),
        cancelRetry: c,
        continueRetry: l,
        canStart: h,
        start: () => (h() ? v() : x().then(v),
        a)
    }
}
function BU() {
    let e = []
      , t = 0
      , r = h => {
        h()
    }
      , n = h => {
        h()
    }
      , i = h => setTimeout(h, 0);
    const s = h => {
        i = h
    }
      , o = h => {
        let g;
        t++;
        try {
            g = h()
        } finally {
            t--,
            t || c()
        }
        return g
    }
      , a = h => {
        t ? e.push(h) : i( () => {
            r(h)
        }
        )
    }
      , u = h => (...g) => {
        a( () => {
            h(...g)
        }
        )
    }
      , c = () => {
        const h = e;
        e = [],
        h.length && i( () => {
            n( () => {
                h.forEach(g => {
                    r(g)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: o,
        batchCalls: u,
        schedule: a,
        setNotifyFunction: h => {
            r = h
        }
        ,
        setBatchNotifyFunction: h => {
            n = h
        }
        ,
        setScheduler: s
    }
}
var Mr = BU(), ks, Lw, A6 = (Lw = class {
    constructor() {
        Xe(this, ks, void 0)
    }
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        MU(this.gcTime) && Fe(this, ks, setTimeout( () => {
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(e) {
        this.gcTime = Math.max(this.gcTime || 0, e ?? (yc ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
        le(this, ks) && (clearTimeout(le(this, ks)),
        Fe(this, ks, void 0))
    }
}
,
ks = new WeakMap,
Lw), Oo, No, nn, vr, Wu, Ls, En, oi, Ow, PU = (Ow = class extends A6 {
    constructor(t) {
        super();
        Xe(this, En);
        Xe(this, Oo, void 0);
        Xe(this, No, void 0);
        Xe(this, nn, void 0);
        Xe(this, vr, void 0);
        Xe(this, Wu, void 0);
        Xe(this, Ls, void 0);
        Fe(this, Ls, !1),
        Fe(this, Wu, t.defaultOptions),
        this.setOptions(t.options),
        this.observers = [],
        Fe(this, nn, t.cache),
        this.queryKey = t.queryKey,
        this.queryHash = t.queryHash,
        Fe(this, Oo, t.state || DU(this.options)),
        this.state = le(this, Oo),
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    setOptions(t) {
        this.options = {
            ...le(this, Wu),
            ...t
        },
        this.updateGcTime(this.options.gcTime)
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && le(this, nn).remove(this)
    }
    setData(t, r) {
        const n = CU(this.state.data, t, this.options);
        return fr(this, En, oi).call(this, {
            data: n,
            type: "success",
            dataUpdatedAt: r == null ? void 0 : r.updatedAt,
            manual: r == null ? void 0 : r.manual
        }),
        n
    }
    setState(t, r) {
        fr(this, En, oi).call(this, {
            type: "setState",
            state: t,
            setStateOptions: r
        })
    }
    cancel(t) {
        var n, i;
        const r = (n = le(this, vr)) == null ? void 0 : n.promise;
        return (i = le(this, vr)) == null || i.cancel(t),
        r ? r.then(xn).catch(xn) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(le(this, Oo))
    }
    isActive() {
        return this.observers.some(t => t.options.enabled !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive()
    }
    isStale() {
        return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0
    }
    isStaleByTime(t=0) {
        return this.state.isInvalidated || this.state.data === void 0 || !IU(this.state.dataUpdatedAt, t)
    }
    onFocus() {
        var r;
        const t = this.observers.find(n => n.shouldFetchOnWindowFocus());
        t == null || t.refetch({
            cancelRefetch: !1
        }),
        (r = le(this, vr)) == null || r.continue()
    }
    onOnline() {
        var r;
        const t = this.observers.find(n => n.shouldFetchOnReconnect());
        t == null || t.refetch({
            cancelRefetch: !1
        }),
        (r = le(this, vr)) == null || r.continue()
    }
    addObserver(t) {
        this.observers.includes(t) || (this.observers.push(t),
        this.clearGcTimeout(),
        le(this, nn).notify({
            type: "observerAdded",
            query: this,
            observer: t
        }))
    }
    removeObserver(t) {
        this.observers.includes(t) && (this.observers = this.observers.filter(r => r !== t),
        this.observers.length || (le(this, vr) && (le(this, Ls) ? le(this, vr).cancel({
            revert: !0
        }) : le(this, vr).cancelRetry()),
        this.scheduleGc()),
        le(this, nn).notify({
            type: "observerRemoved",
            query: this,
            observer: t
        }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || fr(this, En, oi).call(this, {
            type: "invalidate"
        })
    }
    fetch(t, r) {
        var c, l, p;
        if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && (r != null && r.cancelRefetch))
                this.cancel({
                    silent: !0
                });
            else if (le(this, vr))
                return le(this, vr).continueRetry(),
                le(this, vr).promise
        }
        if (t && this.setOptions(t),
        !this.options.queryFn) {
            const h = this.observers.find(g => g.options.queryFn);
            h && this.setOptions(h.options)
        }
        const n = new AbortController
          , i = {
            queryKey: this.queryKey,
            meta: this.meta
        }
          , s = h => {
            Object.defineProperty(h, "signal", {
                enumerable: !0,
                get: () => (Fe(this, Ls, !0),
                n.signal)
            })
        }
        ;
        s(i);
        const o = () => !this.options.queryFn || this.options.queryFn === Rm ? Promise.reject(new Error(`Missing queryFn: '${this.options.queryHash}'`)) : (Fe(this, Ls, !1),
        this.options.persister ? this.options.persister(this.options.queryFn, i, this) : this.options.queryFn(i))
          , a = {
            fetchOptions: r,
            options: this.options,
            queryKey: this.queryKey,
            state: this.state,
            fetchFn: o
        };
        s(a),
        (c = this.options.behavior) == null || c.onFetch(a, this),
        Fe(this, No, this.state),
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((l = a.fetchOptions) == null ? void 0 : l.meta)) && fr(this, En, oi).call(this, {
            type: "fetch",
            meta: (p = a.fetchOptions) == null ? void 0 : p.meta
        });
        const u = h => {
            var g, S, x, v;
            W0(h) && h.silent || fr(this, En, oi).call(this, {
                type: "error",
                error: h
            }),
            W0(h) || ((S = (g = le(this, nn).config).onError) == null || S.call(g, h, this),
            (v = (x = le(this, nn).config).onSettled) == null || v.call(x, this.state.data, h, this)),
            this.isFetchingOptimistic || this.scheduleGc(),
            this.isFetchingOptimistic = !1
        }
        ;
        return Fe(this, vr, _6({
            fn: a.fetchFn,
            abort: n.abort.bind(n),
            onSuccess: h => {
                var g, S, x, v;
                if (h === void 0) {
                    u(new Error(`${this.queryHash} data is undefined`));
                    return
                }
                this.setData(h),
                (S = (g = le(this, nn).config).onSuccess) == null || S.call(g, h, this),
                (v = (x = le(this, nn).config).onSettled) == null || v.call(x, h, this.state.error, this),
                this.isFetchingOptimistic || this.scheduleGc(),
                this.isFetchingOptimistic = !1
            }
            ,
            onError: u,
            onFail: (h, g) => {
                fr(this, En, oi).call(this, {
                    type: "failed",
                    failureCount: h,
                    error: g
                })
            }
            ,
            onPause: () => {
                fr(this, En, oi).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                fr(this, En, oi).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: a.options.retry,
            retryDelay: a.options.retryDelay,
            networkMode: a.options.networkMode,
            canRun: () => !0
        })),
        le(this, vr).start()
    }
}
,
Oo = new WeakMap,
No = new WeakMap,
nn = new WeakMap,
vr = new WeakMap,
Wu = new WeakMap,
Ls = new WeakMap,
En = new WeakSet,
oi = function(t) {
    const r = n => {
        switch (t.type) {
        case "failed":
            return {
                ...n,
                fetchFailureCount: t.failureCount,
                fetchFailureReason: t.error
            };
        case "pause":
            return {
                ...n,
                fetchStatus: "paused"
            };
        case "continue":
            return {
                ...n,
                fetchStatus: "fetching"
            };
        case "fetch":
            return {
                ...n,
                ...jU(n.data, this.options),
                fetchMeta: t.meta ?? null
            };
        case "success":
            return {
                ...n,
                data: t.data,
                dataUpdateCount: n.dataUpdateCount + 1,
                dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: !1,
                status: "success",
                ...!t.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null
                }
            };
        case "error":
            const i = t.error;
            return W0(i) && i.revert && le(this, No) ? {
                ...le(this, No),
                fetchStatus: "idle"
            } : {
                ...n,
                error: i,
                errorUpdateCount: n.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: n.fetchFailureCount + 1,
                fetchFailureReason: i,
                fetchStatus: "idle",
                status: "error"
            };
        case "invalidate":
            return {
                ...n,
                isInvalidated: !0
            };
        case "setState":
            return {
                ...n,
                ...t.state
            }
        }
    }
    ;
    this.state = r(this.state),
    Mr.batch( () => {
        this.observers.forEach(n => {
            n.onQueryUpdate()
        }
        ),
        le(this, nn).notify({
            query: this,
            type: "updated",
            action: t
        })
    }
    )
}
,
Ow);
function jU(e, t) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: E6(t.networkMode) ? "fetching" : "paused",
        ...e === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function DU(e) {
    const t = typeof e.initialData == "function" ? e.initialData() : e.initialData
      , r = t !== void 0
      , n = r ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
    return {
        data: t,
        dataUpdateCount: 0,
        dataUpdatedAt: r ? n ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: r ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var Nn, Nw, M6 = (Nw = class extends wd {
    constructor(r={}) {
        super();
        Xe(this, Nn, void 0);
        this.config = r,
        Fe(this, Nn, new Map)
    }
    build(r, n, i) {
        const s = n.queryKey
          , o = n.queryHash ?? Nm(s, n);
        let a = this.get(o);
        return a || (a = new PU({
            cache: this,
            queryKey: s,
            queryHash: o,
            options: r.defaultQueryOptions(n),
            state: i,
            defaultOptions: r.getQueryDefaults(s)
        }),
        this.add(a)),
        a
    }
    add(r) {
        le(this, Nn).has(r.queryHash) || (le(this, Nn).set(r.queryHash, r),
        this.notify({
            type: "added",
            query: r
        }))
    }
    remove(r) {
        const n = le(this, Nn).get(r.queryHash);
        n && (r.destroy(),
        n === r && le(this, Nn).delete(r.queryHash),
        this.notify({
            type: "removed",
            query: r
        }))
    }
    clear() {
        Mr.batch( () => {
            this.getAll().forEach(r => {
                this.remove(r)
            }
            )
        }
        )
    }
    get(r) {
        return le(this, Nn).get(r)
    }
    getAll() {
        return [...le(this, Nn).values()]
    }
    find(r) {
        const n = {
            exact: !0,
            ...r
        };
        return this.getAll().find(i => iw(n, i))
    }
    findAll(r={}) {
        const n = this.getAll();
        return Object.keys(r).length > 0 ? n.filter(i => iw(r, i)) : n
    }
    notify(r) {
        Mr.batch( () => {
            this.listeners.forEach(n => {
                n(r)
            }
            )
        }
        )
    }
    onFocus() {
        Mr.batch( () => {
            this.getAll().forEach(r => {
                r.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        Mr.batch( () => {
            this.getAll().forEach(r => {
                r.onOnline()
            }
            )
        }
        )
    }
}
,
Nn = new WeakMap,
Nw), Rn, xr, Os, Bn, Ri, Rw, UU = (Rw = class extends A6 {
    constructor(t) {
        super();
        Xe(this, Bn);
        Xe(this, Rn, void 0);
        Xe(this, xr, void 0);
        Xe(this, Os, void 0);
        this.mutationId = t.mutationId,
        Fe(this, xr, t.mutationCache),
        Fe(this, Rn, []),
        this.state = t.state || zU(),
        this.setOptions(t.options),
        this.scheduleGc()
    }
    setOptions(t) {
        this.options = t,
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(t) {
        le(this, Rn).includes(t) || (le(this, Rn).push(t),
        this.clearGcTimeout(),
        le(this, xr).notify({
            type: "observerAdded",
            mutation: this,
            observer: t
        }))
    }
    removeObserver(t) {
        Fe(this, Rn, le(this, Rn).filter(r => r !== t)),
        this.scheduleGc(),
        le(this, xr).notify({
            type: "observerRemoved",
            mutation: this,
            observer: t
        })
    }
    optionalRemove() {
        le(this, Rn).length || (this.state.status === "pending" ? this.scheduleGc() : le(this, xr).remove(this))
    }
    continue() {
        var t;
        return ((t = le(this, Os)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables)
    }
    async execute(t) {
        var i, s, o, a, u, c, l, p, h, g, S, x, v, I, M, A, k, L, O, $;
        Fe(this, Os, _6({
            fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")),
            onFail: (D, K) => {
                fr(this, Bn, Ri).call(this, {
                    type: "failed",
                    failureCount: D,
                    error: K
                })
            }
            ,
            onPause: () => {
                fr(this, Bn, Ri).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                fr(this, Bn, Ri).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => le(this, xr).canRun(this)
        }));
        const r = this.state.status === "pending"
          , n = !le(this, Os).canStart();
        try {
            if (!r) {
                fr(this, Bn, Ri).call(this, {
                    type: "pending",
                    variables: t,
                    isPaused: n
                }),
                await ((s = (i = le(this, xr).config).onMutate) == null ? void 0 : s.call(i, t, this));
                const K = await ((a = (o = this.options).onMutate) == null ? void 0 : a.call(o, t));
                K !== this.state.context && fr(this, Bn, Ri).call(this, {
                    type: "pending",
                    context: K,
                    variables: t,
                    isPaused: n
                })
            }
            const D = await le(this, Os).start();
            return await ((c = (u = le(this, xr).config).onSuccess) == null ? void 0 : c.call(u, D, t, this.state.context, this)),
            await ((p = (l = this.options).onSuccess) == null ? void 0 : p.call(l, D, t, this.state.context)),
            await ((g = (h = le(this, xr).config).onSettled) == null ? void 0 : g.call(h, D, null, this.state.variables, this.state.context, this)),
            await ((x = (S = this.options).onSettled) == null ? void 0 : x.call(S, D, null, t, this.state.context)),
            fr(this, Bn, Ri).call(this, {
                type: "success",
                data: D
            }),
            D
        } catch (D) {
            try {
                throw await ((I = (v = le(this, xr).config).onError) == null ? void 0 : I.call(v, D, t, this.state.context, this)),
                await ((A = (M = this.options).onError) == null ? void 0 : A.call(M, D, t, this.state.context)),
                await ((L = (k = le(this, xr).config).onSettled) == null ? void 0 : L.call(k, void 0, D, this.state.variables, this.state.context, this)),
                await (($ = (O = this.options).onSettled) == null ? void 0 : $.call(O, void 0, D, t, this.state.context)),
                D
            } finally {
                fr(this, Bn, Ri).call(this, {
                    type: "error",
                    error: D
                })
            }
        } finally {
            le(this, xr).runNext(this)
        }
    }
}
,
Rn = new WeakMap,
xr = new WeakMap,
Os = new WeakMap,
Bn = new WeakSet,
Ri = function(t) {
    const r = n => {
        switch (t.type) {
        case "failed":
            return {
                ...n,
                failureCount: t.failureCount,
                failureReason: t.error
            };
        case "pause":
            return {
                ...n,
                isPaused: !0
            };
        case "continue":
            return {
                ...n,
                isPaused: !1
            };
        case "pending":
            return {
                ...n,
                context: t.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: t.isPaused,
                status: "pending",
                variables: t.variables,
                submittedAt: Date.now()
            };
        case "success":
            return {
                ...n,
                data: t.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: !1
            };
        case "error":
            return {
                ...n,
                data: void 0,
                error: t.error,
                failureCount: n.failureCount + 1,
                failureReason: t.error,
                isPaused: !1,
                status: "error"
            }
        }
    }
    ;
    this.state = r(this.state),
    Mr.batch( () => {
        le(this, Rn).forEach(n => {
            n.onMutationUpdate(t)
        }
        ),
        le(this, xr).notify({
            mutation: this,
            type: "updated",
            action: t
        })
    }
    )
}
,
Rw);
function zU() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var Hr, Vu, Bw, I6 = (Bw = class extends wd {
    constructor(r={}) {
        super();
        Xe(this, Hr, void 0);
        Xe(this, Vu, void 0);
        this.config = r,
        Fe(this, Hr, new Map),
        Fe(this, Vu, Date.now())
    }
    build(r, n, i) {
        const s = new UU({
            mutationCache: this,
            mutationId: ++bc(this, Vu)._,
            options: r.defaultMutationOptions(n),
            state: i
        });
        return this.add(s),
        s
    }
    add(r) {
        const n = il(r)
          , i = le(this, Hr).get(n) ?? [];
        i.push(r),
        le(this, Hr).set(n, i),
        this.notify({
            type: "added",
            mutation: r
        })
    }
    remove(r) {
        var i;
        const n = il(r);
        if (le(this, Hr).has(n)) {
            const s = (i = le(this, Hr).get(n)) == null ? void 0 : i.filter(o => o !== r);
            s && (s.length === 0 ? le(this, Hr).delete(n) : le(this, Hr).set(n, s))
        }
        this.notify({
            type: "removed",
            mutation: r
        })
    }
    canRun(r) {
        var i;
        const n = (i = le(this, Hr).get(il(r))) == null ? void 0 : i.find(s => s.state.status === "pending");
        return !n || n === r
    }
    runNext(r) {
        var i;
        const n = (i = le(this, Hr).get(il(r))) == null ? void 0 : i.find(s => s !== r && s.state.isPaused);
        return (n == null ? void 0 : n.continue()) ?? Promise.resolve()
    }
    clear() {
        Mr.batch( () => {
            this.getAll().forEach(r => {
                this.remove(r)
            }
            )
        }
        )
    }
    getAll() {
        return [...le(this, Hr).values()].flat()
    }
    find(r) {
        const n = {
            exact: !0,
            ...r
        };
        return this.getAll().find(i => sw(n, i))
    }
    findAll(r={}) {
        return this.getAll().filter(n => sw(r, n))
    }
    notify(r) {
        Mr.batch( () => {
            this.listeners.forEach(n => {
                n(r)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        const r = this.getAll().filter(n => n.state.isPaused);
        return Mr.batch( () => Promise.all(r.map(n => n.continue().catch(xn))))
    }
}
,
Hr = new WeakMap,
Vu = new WeakMap,
Bw);
function il(e) {
    var t;
    return ((t = e.options.scope) == null ? void 0 : t.id) ?? String(e.mutationId)
}
function $U(e) {
    return {
        onFetch: (t, r) => {
            const n = async () => {
                var S, x, v, I, M;
                const i = t.options
                  , s = (v = (x = (S = t.fetchOptions) == null ? void 0 : S.meta) == null ? void 0 : x.fetchMore) == null ? void 0 : v.direction
                  , o = ((I = t.state.data) == null ? void 0 : I.pages) || []
                  , a = ((M = t.state.data) == null ? void 0 : M.pageParams) || []
                  , u = {
                    pages: [],
                    pageParams: []
                };
                let c = !1;
                const l = A => {
                    Object.defineProperty(A, "signal", {
                        enumerable: !0,
                        get: () => (t.signal.aborted ? c = !0 : t.signal.addEventListener("abort", () => {
                            c = !0
                        }
                        ),
                        t.signal)
                    })
                }
                  , p = t.options.queryFn && t.options.queryFn !== Rm ? t.options.queryFn : () => Promise.reject(new Error(`Missing queryFn: '${t.options.queryHash}'`))
                  , h = async (A, k, L) => {
                    if (c)
                        return Promise.reject();
                    if (k == null && A.pages.length)
                        return Promise.resolve(A);
                    const O = {
                        queryKey: t.queryKey,
                        pageParam: k,
                        direction: L ? "backward" : "forward",
                        meta: t.options.meta
                    };
                    l(O);
                    const $ = await p(O)
                      , {maxPages: D} = t.options
                      , K = L ? LU : kU;
                    return {
                        pages: K(A.pages, $, D),
                        pageParams: K(A.pageParams, k, D)
                    }
                }
                ;
                let g;
                if (s && o.length) {
                    const A = s === "backward"
                      , k = A ? FU : uw
                      , L = {
                        pages: o,
                        pageParams: a
                    }
                      , O = k(i, L);
                    g = await h(L, O, A)
                } else {
                    g = await h(u, a[0] ?? i.initialPageParam);
                    const A = e ?? o.length;
                    for (let k = 1; k < A; k++) {
                        const L = uw(i, g);
                        g = await h(g, L)
                    }
                }
                return g
            }
            ;
            t.options.persister ? t.fetchFn = () => {
                var i, s;
                return (s = (i = t.options).persister) == null ? void 0 : s.call(i, n, {
                    queryKey: t.queryKey,
                    meta: t.options.meta,
                    signal: t.signal
                }, r)
            }
            : t.fetchFn = n
        }
    }
}
function uw(e, {pages: t, pageParams: r}) {
    const n = t.length - 1;
    return e.getNextPageParam(t[n], t, r[n], r)
}
function FU(e, {pages: t, pageParams: r}) {
    var n;
    return (n = e.getPreviousPageParam) == null ? void 0 : n.call(e, t[0], t, r[0], r)
}
var At, Fi, Hi, Ro, Bo, qi, Po, jo, Pw, HU = (Pw = class {
    constructor(t={}) {
        Xe(this, At, void 0);
        Xe(this, Fi, void 0);
        Xe(this, Hi, void 0);
        Xe(this, Ro, void 0);
        Xe(this, Bo, void 0);
        Xe(this, qi, void 0);
        Xe(this, Po, void 0);
        Xe(this, jo, void 0);
        Fe(this, At, t.queryCache || new M6),
        Fe(this, Fi, t.mutationCache || new I6),
        Fe(this, Hi, t.defaultOptions || {}),
        Fe(this, Ro, new Map),
        Fe(this, Bo, new Map),
        Fe(this, qi, 0)
    }
    mount() {
        bc(this, qi)._++,
        le(this, qi) === 1 && (Fe(this, Po, x6.subscribe(async t => {
            t && (await this.resumePausedMutations(),
            le(this, At).onFocus())
        }
        )),
        Fe(this, jo, Ef.subscribe(async t => {
            t && (await this.resumePausedMutations(),
            le(this, At).onOnline())
        }
        )))
    }
    unmount() {
        var t, r;
        bc(this, qi)._--,
        le(this, qi) === 0 && ((t = le(this, Po)) == null || t.call(this),
        Fe(this, Po, void 0),
        (r = le(this, jo)) == null || r.call(this),
        Fe(this, jo, void 0))
    }
    isFetching(t) {
        return le(this, At).findAll({
            ...t,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(t) {
        return le(this, Fi).findAll({
            ...t,
            status: "pending"
        }).length
    }
    getQueryData(t) {
        var n;
        const r = this.defaultQueryOptions({
            queryKey: t
        });
        return (n = le(this, At).get(r.queryHash)) == null ? void 0 : n.state.data
    }
    ensureQueryData(t) {
        const r = this.getQueryData(t.queryKey);
        if (r === void 0)
            return this.fetchQuery(t);
        {
            const n = this.defaultQueryOptions(t)
              , i = le(this, At).build(this, n);
            return t.revalidateIfStale && i.isStaleByTime(n.staleTime) && this.prefetchQuery(n),
            Promise.resolve(r)
        }
    }
    getQueriesData(t) {
        return le(this, At).findAll(t).map( ({queryKey: r, state: n}) => {
            const i = n.data;
            return [r, i]
        }
        )
    }
    setQueryData(t, r, n) {
        const i = this.defaultQueryOptions({
            queryKey: t
        })
          , s = le(this, At).get(i.queryHash)
          , o = s == null ? void 0 : s.state.data
          , a = AU(r, o);
        if (a !== void 0)
            return le(this, At).build(this, i).setData(a, {
                ...n,
                manual: !0
            })
    }
    setQueriesData(t, r, n) {
        return Mr.batch( () => le(this, At).findAll(t).map( ({queryKey: i}) => [i, this.setQueryData(i, r, n)]))
    }
    getQueryState(t) {
        var n;
        const r = this.defaultQueryOptions({
            queryKey: t
        });
        return (n = le(this, At).get(r.queryHash)) == null ? void 0 : n.state
    }
    removeQueries(t) {
        const r = le(this, At);
        Mr.batch( () => {
            r.findAll(t).forEach(n => {
                r.remove(n)
            }
            )
        }
        )
    }
    resetQueries(t, r) {
        const n = le(this, At)
          , i = {
            type: "active",
            ...t
        };
        return Mr.batch( () => (n.findAll(t).forEach(s => {
            s.reset()
        }
        ),
        this.refetchQueries(i, r)))
    }
    cancelQueries(t={}, r={}) {
        const n = {
            revert: !0,
            ...r
        }
          , i = Mr.batch( () => le(this, At).findAll(t).map(s => s.cancel(n)));
        return Promise.all(i).then(xn).catch(xn)
    }
    invalidateQueries(t={}, r={}) {
        return Mr.batch( () => {
            if (le(this, At).findAll(t).forEach(i => {
                i.invalidate()
            }
            ),
            t.refetchType === "none")
                return Promise.resolve();
            const n = {
                ...t,
                type: t.refetchType ?? t.type ?? "active"
            };
            return this.refetchQueries(n, r)
        }
        )
    }
    refetchQueries(t={}, r) {
        const n = {
            ...r,
            cancelRefetch: (r == null ? void 0 : r.cancelRefetch) ?? !0
        }
          , i = Mr.batch( () => le(this, At).findAll(t).filter(s => !s.isDisabled()).map(s => {
            let o = s.fetch(void 0, n);
            return n.throwOnError || (o = o.catch(xn)),
            s.state.fetchStatus === "paused" ? Promise.resolve() : o
        }
        ));
        return Promise.all(i).then(xn)
    }
    fetchQuery(t) {
        const r = this.defaultQueryOptions(t);
        r.retry === void 0 && (r.retry = !1);
        const n = le(this, At).build(this, r);
        return n.isStaleByTime(r.staleTime) ? n.fetch(r) : Promise.resolve(n.state.data)
    }
    prefetchQuery(t) {
        return this.fetchQuery(t).then(xn).catch(xn)
    }
    fetchInfiniteQuery(t) {
        return t.behavior = $U(t.pages),
        this.fetchQuery(t)
    }
    prefetchInfiniteQuery(t) {
        return this.fetchInfiniteQuery(t).then(xn).catch(xn)
    }
    resumePausedMutations() {
        return Ef.isOnline() ? le(this, Fi).resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return le(this, At)
    }
    getMutationCache() {
        return le(this, Fi)
    }
    getDefaultOptions() {
        return le(this, Hi)
    }
    setDefaultOptions(t) {
        Fe(this, Hi, t)
    }
    setQueryDefaults(t, r) {
        le(this, Ro).set($u(t), {
            queryKey: t,
            defaultOptions: r
        })
    }
    getQueryDefaults(t) {
        const r = [...le(this, Ro).values()];
        let n = {};
        return r.forEach(i => {
            Fu(t, i.queryKey) && (n = {
                ...n,
                ...i.defaultOptions
            })
        }
        ),
        n
    }
    setMutationDefaults(t, r) {
        le(this, Bo).set($u(t), {
            mutationKey: t,
            defaultOptions: r
        })
    }
    getMutationDefaults(t) {
        const r = [...le(this, Bo).values()];
        let n = {};
        return r.forEach(i => {
            Fu(t, i.mutationKey) && (n = {
                ...n,
                ...i.defaultOptions
            })
        }
        ),
        n
    }
    defaultQueryOptions(t) {
        if (t._defaulted)
            return t;
        const r = {
            ...le(this, Hi).queries,
            ...this.getQueryDefaults(t.queryKey),
            ...t,
            _defaulted: !0
        };
        return r.queryHash || (r.queryHash = Nm(r.queryKey, r)),
        r.refetchOnReconnect === void 0 && (r.refetchOnReconnect = r.networkMode !== "always"),
        r.throwOnError === void 0 && (r.throwOnError = !!r.suspense),
        !r.networkMode && r.persister && (r.networkMode = "offlineFirst"),
        r.enabled !== !0 && r.queryFn === Rm && (r.enabled = !1),
        r
    }
    defaultMutationOptions(t) {
        return t != null && t._defaulted ? t : {
            ...le(this, Hi).mutations,
            ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
            ...t,
            _defaulted: !0
        }
    }
    clear() {
        le(this, At).clear(),
        le(this, Fi).clear()
    }
}
,
At = new WeakMap,
Fi = new WeakMap,
Hi = new WeakMap,
Ro = new WeakMap,
Bo = new WeakMap,
qi = new WeakMap,
Po = new WeakMap,
jo = new WeakMap,
Pw), qU = "VUE_QUERY_CLIENT";
function WU(e) {
    const t = e ? `:${e}` : "";
    return `${qU}${t}`
}
function rH(e, t) {
    Object.keys(e).forEach(r => {
        e[r] = t[r]
    }
    )
}
function Np(e, t) {
    if (t) {
        const r = t(e);
        if (r === void 0 && bt(e) || r !== void 0)
            return r
    }
    if (Array.isArray(e))
        return e.map(r => Np(r, t));
    if (typeof e == "object" && VU(e)) {
        const r = Object.entries(e).map( ([n,i]) => [n, Np(i, t)]);
        return Object.fromEntries(r)
    }
    return e
}
function Ge(e) {
    return Np(e, t => {
        if (bt(t))
            return Ge(ct(t))
    }
    )
}
function VU(e) {
    if (Object.prototype.toString.call(e) !== "[object Object]")
        return !1;
    const t = Object.getPrototypeOf(e);
    return t === null || t === Object.prototype
}
function nH(e, t) {
    return typeof e == "function" ? e(...t) : !!e
}
var KU = class extends M6 {
    find(e) {
        return super.find(Ge(e))
    }
    findAll(e={}) {
        return super.findAll(Ge(e))
    }
}
  , GU = class extends I6 {
    find(e) {
        return super.find(Ge(e))
    }
    findAll(e={}) {
        return super.findAll(Ge(e))
    }
}
  , QU = class extends HU {
    constructor(e={}) {
        const t = {
            defaultOptions: e.defaultOptions,
            queryCache: e.queryCache || new KU,
            mutationCache: e.mutationCache || new GU
        };
        super(t),
        this.isRestoring = Ue(!1)
    }
    isFetching(e={}) {
        return super.isFetching(Ge(e))
    }
    isMutating(e={}) {
        return super.isMutating(Ge(e))
    }
    getQueryData(e) {
        return super.getQueryData(Ge(e))
    }
    ensureQueryData(e) {
        return super.ensureQueryData(Ge(e))
    }
    getQueriesData(e) {
        return super.getQueriesData(Ge(e))
    }
    setQueryData(e, t, r={}) {
        return super.setQueryData(Ge(e), t, Ge(r))
    }
    setQueriesData(e, t, r={}) {
        return super.setQueriesData(Ge(e), t, Ge(r))
    }
    getQueryState(e) {
        return super.getQueryState(Ge(e))
    }
    removeQueries(e={}) {
        return super.removeQueries(Ge(e))
    }
    resetQueries(e={}, t={}) {
        return super.resetQueries(Ge(e), Ge(t))
    }
    cancelQueries(e={}, t={}) {
        return super.cancelQueries(Ge(e), Ge(t))
    }
    invalidateQueries(e={}, t={}) {
        return new Promise(r => {
            setTimeout(async () => {
                await super.invalidateQueries(Ge(e), Ge(t)),
                r()
            }
            , 0)
        }
        )
    }
    refetchQueries(e={}, t={}) {
        return super.refetchQueries(Ge(e), Ge(t))
    }
    fetchQuery(e) {
        return super.fetchQuery(Ge(e))
    }
    prefetchQuery(e) {
        return super.prefetchQuery(Ge(e))
    }
    fetchInfiniteQuery(e) {
        return super.fetchInfiniteQuery(Ge(e))
    }
    prefetchInfiniteQuery(e) {
        return super.prefetchInfiniteQuery(Ge(e))
    }
    setDefaultOptions(e) {
        super.setDefaultOptions(Ge(e))
    }
    setQueryDefaults(e, t) {
        super.setQueryDefaults(Ge(e), Ge(t))
    }
    getQueryDefaults(e) {
        return super.getQueryDefaults(Ge(e))
    }
    setMutationDefaults(e, t) {
        super.setMutationDefaults(Ge(e), Ge(t))
    }
    getMutationDefaults(e) {
        return super.getMutationDefaults(Ge(e))
    }
}
  , YU = {
    install: (e, t={}) => {
        const r = WU(t.queryClientKey);
        let n;
        if ("queryClient"in t && t.queryClient)
            n = t.queryClient;
        else {
            const o = "queryClientConfig"in t ? t.queryClientConfig : void 0;
            n = new QU(o)
        }
        yc || n.mount();
        let i = () => {}
        ;
        if (t.clientPersister) {
            n.isRestoring.value = !0;
            const [o,a] = t.clientPersister(n);
            i = o,
            a.then( () => {
                var u;
                n.isRestoring.value = !1,
                (u = t.clientPersisterOnSuccess) == null || u.call(t, n)
            }
            )
        }
        const s = () => {
            n.unmount(),
            i()
        }
        ;
        if (e.onUnmount)
            e.onUnmount(s);
        else {
            const o = e.unmount;
            e.unmount = function() {
                s(),
                o()
            }
        }
        e.provide(r, n)
    }
};
const cw = HD({
    id: 1,
    name: "Ethereum",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: ["https://cloudflare-eth.com"]
        }
    },
    blockExplorers: {
        default: {
            name: "Etherscan",
            url: "https://etherscan.io",
            apiUrl: "https://api.etherscan.io/api"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
            address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
            blockCreated: 19258213
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 14353601
        }
    }
});
Bm.type = "walletConnect";
function Bm(e) {
    const t = e.isNewChainsStale ?? !0;
    let r, n;
    const i = "eip155";
    return s => ({
        id: "walletConnect",
        name: "WalletConnect",
        type: Bm.type,
        async setup() {
            const o = await this.getProvider().catch( () => null);
            o && (o.on("connect", this.onConnect.bind(this)),
            o.on("session_delete", this.onSessionDelete.bind(this)))
        },
        async connect({chainId: o, ...a}={}) {
            var u, c;
            try {
                const l = await this.getProvider();
                if (!l)
                    throw new ms;
                l.on("display_uri", this.onDisplayUri);
                let p = o;
                if (!p) {
                    const x = await ((u = s.storage) == null ? void 0 : u.getItem("state")) ?? {};
                    s.chains.some(I => I.id === x.chainId) ? p = x.chainId : p = (c = s.chains[0]) == null ? void 0 : c.id
                }
                if (!p)
                    throw new Error("No chains found on connector.");
                const h = await this.isChainsStale();
                if (l.session && h && await l.disconnect(),
                !l.session || h) {
                    const x = s.chains.filter(v => v.id !== p).map(v => v.id);
                    await l.connect({
                        optionalChains: [p, ...x],
                        ..."pairingTopic"in a ? {
                            pairingTopic: a.pairingTopic
                        } : {}
                    }),
                    this.setRequestedChainsIds(s.chains.map(v => v.id))
                }
                const g = (await l.enable()).map(x => Ts(x))
                  , S = await this.getChainId();
                return l.removeListener("display_uri", this.onDisplayUri),
                l.removeListener("connect", this.onConnect.bind(this)),
                l.on("accountsChanged", this.onAccountsChanged.bind(this)),
                l.on("chainChanged", this.onChainChanged),
                l.on("disconnect", this.onDisconnect.bind(this)),
                l.on("session_delete", this.onSessionDelete.bind(this)),
                {
                    accounts: g,
                    chainId: S
                }
            } catch (l) {
                throw /(user rejected|connection request reset)/i.test(l == null ? void 0 : l.message) ? new ar(l) : l
            }
        },
        async disconnect() {
            const o = await this.getProvider();
            try {
                await (o == null ? void 0 : o.disconnect())
            } catch (a) {
                if (!/No matching key/i.test(a.message))
                    throw a
            } finally {
                o == null || o.removeListener("accountsChanged", this.onAccountsChanged.bind(this)),
                o == null || o.removeListener("chainChanged", this.onChainChanged),
                o == null || o.removeListener("disconnect", this.onDisconnect.bind(this)),
                o == null || o.removeListener("session_delete", this.onSessionDelete.bind(this)),
                o == null || o.on("connect", this.onConnect.bind(this)),
                this.setRequestedChainsIds([])
            }
        },
        async getAccounts() {
            return (await this.getProvider()).accounts.map(a => Ts(a))
        },
        async getProvider({chainId: o}={}) {
            var u;
            async function a() {
                const c = s.chains.map(p => p.id);
                if (!c.length)
                    return;
                const {EthereumProvider: l} = await Be( () => import("./DDJ9bMxJ.js"), __vite__mapDeps([40, 3]), import.meta.url);
                return await l.init({
                    ...e,
                    disableProviderPing: !0,
                    optionalChains: c,
                    projectId: e.projectId,
                    rpcMap: Object.fromEntries(s.chains.map(p => [p.id, p.rpcUrls.default.http[0]])),
                    showQrModal: e.showQrModal ?? !0
                })
            }
            return r || (n || (n = a()),
            r = await n,
            r == null || r.events.setMaxListeners(1 / 0)),
            o && await ((u = this.switchChain) == null ? void 0 : u.call(this, {
                chainId: o
            })),
            r
        },
        async getChainId() {
            return (await this.getProvider()).chainId
        },
        async isAuthorized() {
            try {
                const [o,a] = await Promise.all([this.getAccounts(), this.getProvider()]);
                return o.length ? await this.isChainsStale() && a.session ? (await a.disconnect().catch( () => {}
                ),
                !1) : !0 : !1
            } catch {
                return !1
            }
        },
        async switchChain({addEthereumChainParameter: o, chainId: a}) {
            var c, l, p;
            const u = s.chains.find(h => h.id === a);
            if (!u)
                throw new bi(new xf);
            try {
                const h = await this.getProvider()
                  , g = this.getNamespaceChainsIds()
                  , S = this.getNamespaceMethods();
                if (!g.includes(a) && S.includes("wallet_addEthereumChain")) {
                    let v;
                    o != null && o.blockExplorerUrls ? v = o.blockExplorerUrls : v = (c = u.blockExplorers) != null && c.default.url ? [(l = u.blockExplorers) == null ? void 0 : l.default.url] : [];
                    let I;
                    (p = o == null ? void 0 : o.rpcUrls) != null && p.length ? I = o.rpcUrls : I = [...u.rpcUrls.default.http];
                    const M = {
                        blockExplorerUrls: v,
                        chainId: ia(a),
                        chainName: (o == null ? void 0 : o.chainName) ?? u.name,
                        iconUrls: o == null ? void 0 : o.iconUrls,
                        nativeCurrency: (o == null ? void 0 : o.nativeCurrency) ?? u.nativeCurrency,
                        rpcUrls: I
                    };
                    await h.request({
                        method: "wallet_addEthereumChain",
                        params: [M]
                    });
                    const A = await this.getRequestedChainsIds();
                    this.setRequestedChainsIds([...A, a])
                }
                return await h.request({
                    method: "wallet_switchEthereumChain",
                    params: [{
                        chainId: ia(a)
                    }]
                }),
                u
            } catch (h) {
                const g = typeof h == "string" ? h : h == null ? void 0 : h.message;
                throw /user rejected request/i.test(g) ? new ar(h) : new bi(h)
            }
        },
        onAccountsChanged(o) {
            o.length === 0 ? this.onDisconnect() : s.emitter.emit("change", {
                accounts: o.map(a => Ts(a))
            })
        },
        onChainChanged(o) {
            const a = Number(o);
            s.emitter.emit("change", {
                chainId: a
            })
        },
        async onConnect(o) {
            const a = Number(o.chainId)
              , u = await this.getAccounts();
            s.emitter.emit("connect", {
                accounts: u,
                chainId: a
            })
        },
        async onDisconnect(o) {
            this.setRequestedChainsIds([]),
            s.emitter.emit("disconnect");
            const a = await this.getProvider();
            a.removeListener("accountsChanged", this.onAccountsChanged.bind(this)),
            a.removeListener("chainChanged", this.onChainChanged),
            a.removeListener("disconnect", this.onDisconnect.bind(this)),
            a.removeListener("session_delete", this.onSessionDelete.bind(this)),
            a.on("connect", this.onConnect.bind(this))
        },
        onDisplayUri(o) {
            s.emitter.emit("message", {
                type: "display_uri",
                data: o
            })
        },
        onSessionDelete() {
            this.onDisconnect()
        },
        getNamespaceChainsIds() {
            var a, u, c;
            return r ? ((c = (u = (a = r.session) == null ? void 0 : a.namespaces[i]) == null ? void 0 : u.chains) == null ? void 0 : c.map(l => parseInt(l.split(":")[1] || ""))) ?? [] : []
        },
        getNamespaceMethods() {
            var a, u;
            return r ? ((u = (a = r.session) == null ? void 0 : a.namespaces[i]) == null ? void 0 : u.methods) ?? [] : []
        },
        async getRequestedChainsIds() {
            var o;
            return await ((o = s.storage) == null ? void 0 : o.getItem(this.requestedChainsStorageKey)) ?? []
        },
        async isChainsStale() {
            if (this.getNamespaceMethods().includes("wallet_addEthereumChain") || !t)
                return !1;
            const a = s.chains.map(l => l.id)
              , u = this.getNamespaceChainsIds();
            if (u.length && !u.some(l => a.includes(l)))
                return !1;
            const c = await this.getRequestedChainsIds();
            return !a.every(l => c.includes(l))
        },
        async setRequestedChainsIds(o) {
            var a;
            await ((a = s.storage) == null ? void 0 : a.setItem(this.requestedChainsStorageKey, o))
        },
        get requestedChainsStorageKey() {
            return `${this.id}.requestedChains`
        }
    })
}
const {metadata: Na} = M2
  , ZU = _t(e => {
    const t = os()
      , r = vU({
        chains: [cw],
        connectors: [bd({}), Bm({
            projectId: t.public.WALLET_CONNECT_PROJECT_ID,
            metadata: {
                name: Na.app_name,
                description: Na.description,
                url: Na.url,
                icons: [Na.modal_icon, Na.icon]
            },
            qrModalOptions: {
                themeMode: Kj().value
            }
        })],
        transports: {
            [cw.id]: JD("https://rpc.flashbots.net")
        }
    });
    e.vueApp.use(_U, {
        config: r
    }).use(YU)
}
)
  , JU = [mA, bA, OM, RM, PM, jM, JM, UI, zI, $I, lT, dT, PC, UC, zC, $C, VC, QC, T9, C9, Wj, Vj, ZU]
  , XU = lr({
    props: {
        vnode: {
            type: Object,
            required: !0
        },
        route: {
            type: Object,
            required: !0
        },
        vnodeRef: Object,
        renderKey: String,
        trackRootNodes: Boolean
    },
    setup(e) {
        const t = e.renderKey
          , r = e.route
          , n = {};
        for (const i in e.route)
            Object.defineProperty(n, i, {
                get: () => t === e.renderKey ? e.route[i] : r[i]
            });
        return Zi(la, Qu(n)),
        () => cr(e.vnode, {
            ref: e.vnodeRef
        })
    }
})
  , ez = lr({
    name: "NuxtPage",
    inheritAttrs: !1,
    props: {
        name: {
            type: String
        },
        transition: {
            type: [Boolean, Object],
            default: void 0
        },
        keepalive: {
            type: [Boolean, Object],
            default: void 0
        },
        route: {
            type: Object
        },
        pageKey: {
            type: [Function, String],
            default: null
        }
    },
    setup(e, {attrs: t, expose: r}) {
        const n = ut()
          , i = Ue()
          , s = Kt(la, null);
        let o;
        r({
            pageRef: i
        });
        const a = Kt(l2, null);
        let u;
        const c = n.deferHydration();
        if (n.isHydrating) {
            const l = n.hooks.hookOnce("app:error", c);
            Ur().beforeEach(l)
        }
        return e.pageKey && vt( () => e.pageKey, (l, p) => {
            l !== p && n.callHook("page:loading:start")
        }
        ),
        () => cr($2, {
            name: e.name,
            route: e.route,
            ...t
        }, {
            default: l => {
                const p = rz(s, l.route, l.Component)
                  , h = s && s.matched.length === l.route.matched.length;
                if (!l.Component) {
                    if (u && !h)
                        return u;
                    c();
                    return
                }
                if (u && a && !a.isCurrent(l.route))
                    return u;
                if (p && s && (!a || a != null && a.isCurrent(s)))
                    return h ? u : null;
                const g = kh(l, e.pageKey);
                !n.isHydrating && !nz(s, l.route, l.Component) && o === g && n.callHook("page:loading:end"),
                o = g;
                const S = !!(e.transition ?? l.route.meta.pageTransition ?? Mh)
                  , x = S && tz([e.transition, l.route.meta.pageTransition, Mh, {
                    onAfterLeave: () => {
                        n.callHook("page:transition:finish", l.Component)
                    }
                }].filter(Boolean))
                  , v = e.keepalive ?? l.route.meta.keepalive ?? aA;
                return u = F2(ec, S && x, SM(v, cr(og, {
                    suspensible: !0,
                    onPending: () => n.callHook("page:start", l.Component),
                    onResolve: () => {
                        Kn( () => n.callHook("page:finish", l.Component).then( () => n.callHook("page:loading:end")).finally(c))
                    }
                }, {
                    default: () => {
                        const I = cr(XU, {
                            key: g || void 0,
                            vnode: l.Component,
                            route: l.route,
                            renderKey: g || void 0,
                            trackRootNodes: S,
                            vnodeRef: i
                        });
                        return v && (I.type.name = l.Component.type.name || l.Component.type.__name || "RouteProvider"),
                        I
                    }
                }))).default(),
                u
            }
        })
    }
});
function tz(e) {
    const t = e.map(r => ({
        ...r,
        onAfterLeave: r.onAfterLeave ? _g(r.onAfterLeave) : void 0
    }));
    return yg(...t)
}
function rz(e, t, r) {
    if (!e)
        return !1;
    const n = t.matched.findIndex(i => {
        var s;
        return ((s = i.components) == null ? void 0 : s.default) === (r == null ? void 0 : r.type)
    }
    );
    return !n || n === -1 ? !1 : t.matched.slice(0, n).some( (i, s) => {
        var o, a, u;
        return ((o = i.components) == null ? void 0 : o.default) !== ((u = (a = e.matched[s]) == null ? void 0 : a.components) == null ? void 0 : u.default)
    }
    ) || r && kh({
        route: t,
        Component: r
    }) !== kh({
        route: e,
        Component: r
    })
}
function nz(e, t, r) {
    return e ? t.matched.findIndex(i => {
        var s;
        return ((s = i.components) == null ? void 0 : s.default) === (r == null ? void 0 : r.type)
    }
    ) < t.matched.length - 1 : !1
}
const T6 = Object.freeze({
    left: 0,
    top: 0,
    width: 16,
    height: 16
})
  , C6 = Object.freeze({
    rotate: 0,
    vFlip: !1,
    hFlip: !1
})
  , Pm = Object.freeze({
    ...T6,
    ...C6
});
Object.freeze({
    ...Pm,
    body: "",
    hidden: !1
});
({
    ...T6
});
const k6 = Object.freeze({
    width: null,
    height: null
})
  , L6 = Object.freeze({
    ...k6,
    ...C6
});
function iz(e, t) {
    const r = {
        ...e
    };
    for (const n in t) {
        const i = t[n]
          , s = typeof i;
        n in k6 ? (i === null || i && (s === "string" || s === "number")) && (r[n] = i) : s === typeof r[n] && (r[n] = n === "rotate" ? i % 4 : i)
    }
    return r
}
const sz = /[\s,]+/;
function oz(e, t) {
    t.split(sz).forEach(r => {
        switch (r.trim()) {
        case "horizontal":
            e.hFlip = !0;
            break;
        case "vertical":
            e.vFlip = !0;
            break
        }
    }
    )
}
function az(e, t=0) {
    const r = e.replace(/^-?[0-9.]*/, "");
    function n(i) {
        for (; i < 0; )
            i += 4;
        return i % 4
    }
    if (r === "") {
        const i = parseInt(e);
        return isNaN(i) ? 0 : n(i)
    } else if (r !== e) {
        let i = 0;
        switch (r) {
        case "%":
            i = 25;
            break;
        case "deg":
            i = 90
        }
        if (i) {
            let s = parseFloat(e.slice(0, e.length - r.length));
            return isNaN(s) ? 0 : (s = s / i,
            s % 1 === 0 ? n(s) : 0)
        }
    }
    return t
}
const uz = /(-?[0-9.]*[0-9]+[0-9.]*)/g
  , cz = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function lw(e, t, r) {
    if (t === 1)
        return e;
    if (r = r || 100,
    typeof e == "number")
        return Math.ceil(e * t * r) / r;
    if (typeof e != "string")
        return e;
    const n = e.split(uz);
    if (n === null || !n.length)
        return e;
    const i = [];
    let s = n.shift()
      , o = cz.test(s);
    for (; ; ) {
        if (o) {
            const a = parseFloat(s);
            isNaN(a) ? i.push(s) : i.push(Math.ceil(a * t * r) / r)
        } else
            i.push(s);
        if (s = n.shift(),
        s === void 0)
            return i.join("");
        o = !o
    }
}
const lz = e => e === "unset" || e === "undefined" || e === "none";
function fz(e, t) {
    const r = {
        ...Pm,
        ...e
    }
      , n = {
        ...L6,
        ...t
    }
      , i = {
        left: r.left,
        top: r.top,
        width: r.width,
        height: r.height
    };
    let s = r.body;
    [r, n].forEach(S => {
        const x = []
          , v = S.hFlip
          , I = S.vFlip;
        let M = S.rotate;
        v ? I ? M += 2 : (x.push("translate(" + (i.width + i.left).toString() + " " + (0 - i.top).toString() + ")"),
        x.push("scale(-1 1)"),
        i.top = i.left = 0) : I && (x.push("translate(" + (0 - i.left).toString() + " " + (i.height + i.top).toString() + ")"),
        x.push("scale(1 -1)"),
        i.top = i.left = 0);
        let A;
        switch (M < 0 && (M -= Math.floor(M / 4) * 4),
        M = M % 4,
        M) {
        case 1:
            A = i.height / 2 + i.top,
            x.unshift("rotate(90 " + A.toString() + " " + A.toString() + ")");
            break;
        case 2:
            x.unshift("rotate(180 " + (i.width / 2 + i.left).toString() + " " + (i.height / 2 + i.top).toString() + ")");
            break;
        case 3:
            A = i.width / 2 + i.left,
            x.unshift("rotate(-90 " + A.toString() + " " + A.toString() + ")");
            break
        }
        M % 2 === 1 && (i.left !== i.top && (A = i.left,
        i.left = i.top,
        i.top = A),
        i.width !== i.height && (A = i.width,
        i.width = i.height,
        i.height = A)),
        x.length && (s = '<g transform="' + x.join(" ") + '">' + s + "</g>")
    }
    );
    const o = n.width
      , a = n.height
      , u = i.width
      , c = i.height;
    let l, p;
    o === null ? (p = a === null ? "1em" : a === "auto" ? c : a,
    l = lw(p, u / c)) : (l = o === "auto" ? u : o,
    p = a === null ? lw(l, c / u) : a === "auto" ? c : a);
    const h = {}
      , g = (S, x) => {
        lz(x) || (h[S] = x.toString())
    }
    ;
    return g("width", l),
    g("height", p),
    h.viewBox = i.left.toString() + " " + i.top.toString() + " " + u.toString() + " " + c.toString(),
    {
        attributes: h,
        body: s
    }
}
const dz = /\sid="(\S+)"/g
  , hz = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let pz = 0;
function gz(e, t=hz) {
    const r = [];
    let n;
    for (; n = dz.exec(e); )
        r.push(n[1]);
    if (!r.length)
        return e;
    const i = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
    return r.forEach(s => {
        const o = typeof t == "function" ? t(s) : t + (pz++).toString()
          , a = s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        e = e.replace(new RegExp('([#;"])(' + a + ')([")]|\\.[a-z])',"g"), "$1" + o + i + "$3")
    }
    ),
    e = e.replace(new RegExp(i,"g"), ""),
    e
}
function mz(e, t) {
    let r = e.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
    for (const n in t)
        r += " " + n + '="' + t[n] + '"';
    return '<svg xmlns="http://www.w3.org/2000/svg"' + r + ">" + e + "</svg>"
}
function yz(e) {
    return e.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ")
}
function bz(e) {
    return "data:image/svg+xml," + yz(e)
}
function wz(e) {
    return 'url("' + bz(e) + '")'
}
const fw = {
    ...L6,
    inline: !1
}
  , vz = {
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "aria-hidden": !0,
    role: "img"
}
  , xz = {
    display: "inline-block"
}
  , Rp = {
    backgroundColor: "currentColor"
}
  , O6 = {
    backgroundColor: "transparent"
}
  , dw = {
    Image: "var(--svg)",
    Repeat: "no-repeat",
    Size: "100% 100%"
}
  , hw = {
    webkitMask: Rp,
    mask: Rp,
    background: O6
};
for (const e in hw) {
    const t = hw[e];
    for (const r in dw)
        t[e + r] = dw[r]
}
const Il = {};
["horizontal", "vertical"].forEach(e => {
    const t = e.slice(0, 1) + "Flip";
    Il[e + "-flip"] = t,
    Il[e.slice(0, 1) + "-flip"] = t,
    Il[e + "Flip"] = t
}
);
function pw(e) {
    return e + (e.match(/^[-0-9.]+$/) ? "px" : "")
}
const Ez = (e, t) => {
    const r = iz(fw, t)
      , n = {
        ...vz
    }
      , i = t.mode || "svg"
      , s = {}
      , o = t.style
      , a = typeof o == "object" && !(o instanceof Array) ? o : {};
    for (let x in t) {
        const v = t[x];
        if (v !== void 0)
            switch (x) {
            case "icon":
            case "style":
            case "onLoad":
            case "mode":
                break;
            case "inline":
            case "hFlip":
            case "vFlip":
                r[x] = v === !0 || v === "true" || v === 1;
                break;
            case "flip":
                typeof v == "string" && oz(r, v);
                break;
            case "color":
                s.color = v;
                break;
            case "rotate":
                typeof v == "string" ? r[x] = az(v) : typeof v == "number" && (r[x] = v);
                break;
            case "ariaHidden":
            case "aria-hidden":
                v !== !0 && v !== "true" && delete n["aria-hidden"];
                break;
            default:
                {
                    const I = Il[x];
                    I ? (v === !0 || v === "true" || v === 1) && (r[I] = !0) : fw[x] === void 0 && (n[x] = v)
                }
            }
    }
    const u = fz(e, r)
      , c = u.attributes;
    if (r.inline && (s.verticalAlign = "-0.125em"),
    i === "svg") {
        n.style = {
            ...s,
            ...a
        },
        Object.assign(n, c);
        let x = 0
          , v = t.id;
        return typeof v == "string" && (v = v.replace(/-/g, "_")),
        n.innerHTML = gz(u.body, v ? () => v + "ID" + x++ : "iconifyVue"),
        cr("svg", n)
    }
    const {body: l, width: p, height: h} = e
      , g = i === "mask" || (i === "bg" ? !1 : l.indexOf("currentColor") !== -1)
      , S = mz(l, {
        ...c,
        width: p + "",
        height: h + ""
    });
    return n.style = {
        ...s,
        "--svg": wz(S),
        width: pw(c.width),
        height: pw(c.height),
        ...xz,
        ...g ? Rp : O6,
        ...a
    },
    cr("span", n)
}
  , Sz = Object.create(null)
  , _z = lr({
    inheritAttrs: !1,
    render() {
        const e = this.$attrs
          , t = e.icon
          , r = typeof t == "string" ? Sz[t] : typeof t == "object" ? t : null;
        return r === null || typeof r != "object" || typeof r.body != "string" ? this.$slots.default ? this.$slots.default() : null : Ez({
            ...Pm,
            ...r
        }, e)
    }
})
  , nu = /^[a-z0-9]+(-[a-z0-9]+)*$/
  , vd = (e, t, r, n="") => {
    const i = e.split(":");
    if (e.slice(0, 1) === "@") {
        if (i.length < 2 || i.length > 3)
            return null;
        n = i.shift().slice(1)
    }
    if (i.length > 3 || !i.length)
        return null;
    if (i.length > 1) {
        const a = i.pop()
          , u = i.pop()
          , c = {
            provider: i.length > 0 ? i[0] : n,
            prefix: u,
            name: a
        };
        return t && !Tl(c) ? null : c
    }
    const s = i[0]
      , o = s.split("-");
    if (o.length > 1) {
        const a = {
            provider: n,
            prefix: o.shift(),
            name: o.join("-")
        };
        return t && !Tl(a) ? null : a
    }
    if (r && n === "") {
        const a = {
            provider: n,
            prefix: "",
            name: s
        };
        return t && !Tl(a, r) ? null : a
    }
    return null
}
  , Tl = (e, t) => e ? !!((e.provider === "" || e.provider.match(nu)) && (t && e.prefix === "" || e.prefix.match(nu)) && e.name.match(nu)) : !1
  , N6 = Object.freeze({
    left: 0,
    top: 0,
    width: 16,
    height: 16
})
  , Sf = Object.freeze({
    rotate: 0,
    vFlip: !1,
    hFlip: !1
})
  , jm = Object.freeze({
    ...N6,
    ...Sf
})
  , Bp = Object.freeze({
    ...jm,
    body: "",
    hidden: !1
});
function Az(e, t) {
    const r = {};
    !e.hFlip != !t.hFlip && (r.hFlip = !0),
    !e.vFlip != !t.vFlip && (r.vFlip = !0);
    const n = ((e.rotate || 0) + (t.rotate || 0)) % 4;
    return n && (r.rotate = n),
    r
}
function gw(e, t) {
    const r = Az(e, t);
    for (const n in Bp)
        n in Sf ? n in e && !(n in r) && (r[n] = Sf[n]) : n in t ? r[n] = t[n] : n in e && (r[n] = e[n]);
    return r
}
function Mz(e, t) {
    const r = e.icons
      , n = e.aliases || Object.create(null)
      , i = Object.create(null);
    function s(o) {
        if (r[o])
            return i[o] = [];
        if (!(o in i)) {
            i[o] = null;
            const a = n[o] && n[o].parent
              , u = a && s(a);
            u && (i[o] = [a].concat(u))
        }
        return i[o]
    }
    return (t || Object.keys(r).concat(Object.keys(n))).forEach(s),
    i
}
function Iz(e, t, r) {
    const n = e.icons
      , i = e.aliases || Object.create(null);
    let s = {};
    function o(a) {
        s = gw(n[a] || i[a], s)
    }
    return o(t),
    r.forEach(o),
    gw(e, s)
}
function R6(e, t) {
    const r = [];
    if (typeof e != "object" || typeof e.icons != "object")
        return r;
    e.not_found instanceof Array && e.not_found.forEach(i => {
        t(i, null),
        r.push(i)
    }
    );
    const n = Mz(e);
    for (const i in n) {
        const s = n[i];
        s && (t(i, Iz(e, i, s)),
        r.push(i))
    }
    return r
}
const Tz = {
    provider: "",
    aliases: {},
    not_found: {},
    ...N6
};
function V0(e, t) {
    for (const r in t)
        if (r in e && typeof e[r] != typeof t[r])
            return !1;
    return !0
}
function B6(e) {
    if (typeof e != "object" || e === null)
        return null;
    const t = e;
    if (typeof t.prefix != "string" || !e.icons || typeof e.icons != "object" || !V0(e, Tz))
        return null;
    const r = t.icons;
    for (const i in r) {
        const s = r[i];
        if (!i.match(nu) || typeof s.body != "string" || !V0(s, Bp))
            return null
    }
    const n = t.aliases || Object.create(null);
    for (const i in n) {
        const s = n[i]
          , o = s.parent;
        if (!i.match(nu) || typeof o != "string" || !r[o] && !n[o] || !V0(s, Bp))
            return null
    }
    return t
}
const mw = Object.create(null);
function Cz(e, t) {
    return {
        provider: e,
        prefix: t,
        icons: Object.create(null),
        missing: new Set
    }
}
function Qs(e, t) {
    const r = mw[e] || (mw[e] = Object.create(null));
    return r[t] || (r[t] = Cz(e, t))
}
function Dm(e, t) {
    return B6(t) ? R6(t, (r, n) => {
        n ? e.icons[r] = n : e.missing.add(r)
    }
    ) : []
}
function kz(e, t, r) {
    try {
        if (typeof r.body == "string")
            return e.icons[t] = {
                ...r
            },
            !0
    } catch {}
    return !1
}
let Hu = !1;
function P6(e) {
    return typeof e == "boolean" && (Hu = e),
    Hu
}
function Lz(e) {
    const t = typeof e == "string" ? vd(e, !0, Hu) : e;
    if (t) {
        const r = Qs(t.provider, t.prefix)
          , n = t.name;
        return r.icons[n] || (r.missing.has(n) ? null : void 0)
    }
}
function Oz(e, t) {
    const r = vd(e, !0, Hu);
    if (!r)
        return !1;
    const n = Qs(r.provider, r.prefix);
    return kz(n, r.name, t)
}
function Nz(e, t) {
    if (typeof e != "object")
        return !1;
    if (typeof t != "string" && (t = e.provider || ""),
    Hu && !t && !e.prefix) {
        let i = !1;
        return B6(e) && (e.prefix = "",
        R6(e, (s, o) => {
            o && Oz(s, o) && (i = !0)
        }
        )),
        i
    }
    const r = e.prefix;
    if (!Tl({
        provider: t,
        prefix: r,
        name: "a"
    }))
        return !1;
    const n = Qs(t, r);
    return !!Dm(n, e)
}
const Rz = Object.freeze({
    width: null,
    height: null
})
  , Bz = Object.freeze({
    ...Rz,
    ...Sf
});
"" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
const Pp = Object.create(null);
function Pz(e, t) {
    Pp[e] = t
}
function jp(e) {
    return Pp[e] || Pp[""]
}
function Um(e) {
    let t;
    if (typeof e.resources == "string")
        t = [e.resources];
    else if (t = e.resources,
    !(t instanceof Array) || !t.length)
        return null;
    return {
        resources: t,
        path: e.path || "/",
        maxURL: e.maxURL || 500,
        rotate: e.rotate || 750,
        timeout: e.timeout || 5e3,
        random: e.random === !0,
        index: e.index || 0,
        dataAfterTimeout: e.dataAfterTimeout !== !1
    }
}
const zm = Object.create(null)
  , Ra = ["https://api.simplesvg.com", "https://api.unisvg.com"]
  , Cl = [];
for (; Ra.length > 0; )
    Ra.length === 1 || Math.random() > .5 ? Cl.push(Ra.shift()) : Cl.push(Ra.pop());
zm[""] = Um({
    resources: ["https://api.iconify.design"].concat(Cl)
});
function Dp(e, t) {
    const r = Um(t);
    return r === null ? !1 : (zm[e] = r,
    !0)
}
function $m(e) {
    return zm[e]
}
const jz = () => {
    let e;
    try {
        if (e = fetch,
        typeof e == "function")
            return e
    } catch {}
}
;
let yw = jz();
function Dz(e, t) {
    const r = $m(e);
    if (!r)
        return 0;
    let n;
    if (!r.maxURL)
        n = 0;
    else {
        let i = 0;
        r.resources.forEach(o => {
            i = Math.max(i, o.length)
        }
        );
        const s = t + ".json?icons=";
        n = r.maxURL - i - r.path.length - s.length
    }
    return n
}
function Uz(e) {
    return e === 404
}
const zz = (e, t, r) => {
    const n = []
      , i = Dz(e, t)
      , s = "icons";
    let o = {
        type: s,
        provider: e,
        prefix: t,
        icons: []
    }
      , a = 0;
    return r.forEach( (u, c) => {
        a += u.length + 1,
        a >= i && c > 0 && (n.push(o),
        o = {
            type: s,
            provider: e,
            prefix: t,
            icons: []
        },
        a = u.length),
        o.icons.push(u)
    }
    ),
    n.push(o),
    n
}
;
function $z(e) {
    if (typeof e == "string") {
        const t = $m(e);
        if (t)
            return t.path
    }
    return "/"
}
const Fz = (e, t, r) => {
    if (!yw) {
        r("abort", 424);
        return
    }
    let n = $z(t.provider);
    switch (t.type) {
    case "icons":
        {
            const s = t.prefix
              , a = t.icons.join(",")
              , u = new URLSearchParams({
                icons: a
            });
            n += s + ".json?" + u.toString();
            break
        }
    case "custom":
        {
            const s = t.uri;
            n += s.slice(0, 1) === "/" ? s.slice(1) : s;
            break
        }
    default:
        r("abort", 400);
        return
    }
    let i = 503;
    yw(e + n).then(s => {
        const o = s.status;
        if (o !== 200) {
            setTimeout( () => {
                r(Uz(o) ? "abort" : "next", o)
            }
            );
            return
        }
        return i = 501,
        s.json()
    }
    ).then(s => {
        if (typeof s != "object" || s === null) {
            setTimeout( () => {
                s === 404 ? r("abort", s) : r("next", i)
            }
            );
            return
        }
        setTimeout( () => {
            r("success", s)
        }
        )
    }
    ).catch( () => {
        r("next", i)
    }
    )
}
  , Hz = {
    prepare: zz,
    send: Fz
};
function qz(e) {
    const t = {
        loaded: [],
        missing: [],
        pending: []
    }
      , r = Object.create(null);
    e.sort( (i, s) => i.provider !== s.provider ? i.provider.localeCompare(s.provider) : i.prefix !== s.prefix ? i.prefix.localeCompare(s.prefix) : i.name.localeCompare(s.name));
    let n = {
        provider: "",
        prefix: "",
        name: ""
    };
    return e.forEach(i => {
        if (n.name === i.name && n.prefix === i.prefix && n.provider === i.provider)
            return;
        n = i;
        const s = i.provider
          , o = i.prefix
          , a = i.name
          , u = r[s] || (r[s] = Object.create(null))
          , c = u[o] || (u[o] = Qs(s, o));
        let l;
        a in c.icons ? l = t.loaded : o === "" || c.missing.has(a) ? l = t.missing : l = t.pending;
        const p = {
            provider: s,
            prefix: o,
            name: a
        };
        l.push(p)
    }
    ),
    t
}
function j6(e, t) {
    e.forEach(r => {
        const n = r.loaderCallbacks;
        n && (r.loaderCallbacks = n.filter(i => i.id !== t))
    }
    )
}
function Wz(e) {
    e.pendingCallbacksFlag || (e.pendingCallbacksFlag = !0,
    setTimeout( () => {
        e.pendingCallbacksFlag = !1;
        const t = e.loaderCallbacks ? e.loaderCallbacks.slice(0) : [];
        if (!t.length)
            return;
        let r = !1;
        const n = e.provider
          , i = e.prefix;
        t.forEach(s => {
            const o = s.icons
              , a = o.pending.length;
            o.pending = o.pending.filter(u => {
                if (u.prefix !== i)
                    return !0;
                const c = u.name;
                if (e.icons[c])
                    o.loaded.push({
                        provider: n,
                        prefix: i,
                        name: c
                    });
                else if (e.missing.has(c))
                    o.missing.push({
                        provider: n,
                        prefix: i,
                        name: c
                    });
                else
                    return r = !0,
                    !0;
                return !1
            }
            ),
            o.pending.length !== a && (r || j6([e], s.id),
            s.callback(o.loaded.slice(0), o.missing.slice(0), o.pending.slice(0), s.abort))
        }
        )
    }
    ))
}
let Vz = 0;
function Kz(e, t, r) {
    const n = Vz++
      , i = j6.bind(null, r, n);
    if (!t.pending.length)
        return i;
    const s = {
        id: n,
        icons: t,
        callback: e,
        abort: i
    };
    return r.forEach(o => {
        (o.loaderCallbacks || (o.loaderCallbacks = [])).push(s)
    }
    ),
    i
}
function Gz(e, t=!0, r=!1) {
    const n = [];
    return e.forEach(i => {
        const s = typeof i == "string" ? vd(i, t, r) : i;
        s && n.push(s)
    }
    ),
    n
}
var Qz = {
    resources: [],
    index: 0,
    timeout: 2e3,
    rotate: 750,
    random: !1,
    dataAfterTimeout: !1
};
function Yz(e, t, r, n) {
    const i = e.resources.length
      , s = e.random ? Math.floor(Math.random() * i) : e.index;
    let o;
    if (e.random) {
        let O = e.resources.slice(0);
        for (o = []; O.length > 1; ) {
            const $ = Math.floor(Math.random() * O.length);
            o.push(O[$]),
            O = O.slice(0, $).concat(O.slice($ + 1))
        }
        o = o.concat(O)
    } else
        o = e.resources.slice(s).concat(e.resources.slice(0, s));
    const a = Date.now();
    let u = "pending", c = 0, l, p = null, h = [], g = [];
    typeof n == "function" && g.push(n);
    function S() {
        p && (clearTimeout(p),
        p = null)
    }
    function x() {
        u === "pending" && (u = "aborted"),
        S(),
        h.forEach(O => {
            O.status === "pending" && (O.status = "aborted")
        }
        ),
        h = []
    }
    function v(O, $) {
        $ && (g = []),
        typeof O == "function" && g.push(O)
    }
    function I() {
        return {
            startTime: a,
            payload: t,
            status: u,
            queriesSent: c,
            queriesPending: h.length,
            subscribe: v,
            abort: x
        }
    }
    function M() {
        u = "failed",
        g.forEach(O => {
            O(void 0, l)
        }
        )
    }
    function A() {
        h.forEach(O => {
            O.status === "pending" && (O.status = "aborted")
        }
        ),
        h = []
    }
    function k(O, $, D) {
        const K = $ !== "success";
        switch (h = h.filter(G => G !== O),
        u) {
        case "pending":
            break;
        case "failed":
            if (K || !e.dataAfterTimeout)
                return;
            break;
        default:
            return
        }
        if ($ === "abort") {
            l = D,
            M();
            return
        }
        if (K) {
            l = D,
            h.length || (o.length ? L() : M());
            return
        }
        if (S(),
        A(),
        !e.random) {
            const G = e.resources.indexOf(O.resource);
            G !== -1 && G !== e.index && (e.index = G)
        }
        u = "completed",
        g.forEach(G => {
            G(D)
        }
        )
    }
    function L() {
        if (u !== "pending")
            return;
        S();
        const O = o.shift();
        if (O === void 0) {
            if (h.length) {
                p = setTimeout( () => {
                    S(),
                    u === "pending" && (A(),
                    M())
                }
                , e.timeout);
                return
            }
            M();
            return
        }
        const $ = {
            status: "pending",
            resource: O,
            callback: (D, K) => {
                k($, D, K)
            }
        };
        h.push($),
        c++,
        p = setTimeout(L, e.rotate),
        r(O, t, $.callback)
    }
    return setTimeout(L),
    I
}
function D6(e) {
    const t = {
        ...Qz,
        ...e
    };
    let r = [];
    function n() {
        r = r.filter(a => a().status === "pending")
    }
    function i(a, u, c) {
        const l = Yz(t, a, u, (p, h) => {
            n(),
            c && c(p, h)
        }
        );
        return r.push(l),
        l
    }
    function s(a) {
        return r.find(u => a(u)) || null
    }
    return {
        query: i,
        find: s,
        setIndex: a => {
            t.index = a
        }
        ,
        getIndex: () => t.index,
        cleanup: n
    }
}
function bw() {}
const K0 = Object.create(null);
function Zz(e) {
    if (!K0[e]) {
        const t = $m(e);
        if (!t)
            return;
        const r = D6(t)
          , n = {
            config: t,
            redundancy: r
        };
        K0[e] = n
    }
    return K0[e]
}
function Jz(e, t, r) {
    let n, i;
    if (typeof e == "string") {
        const s = jp(e);
        if (!s)
            return r(void 0, 424),
            bw;
        i = s.send;
        const o = Zz(e);
        o && (n = o.redundancy)
    } else {
        const s = Um(e);
        if (s) {
            n = D6(s);
            const o = e.resources ? e.resources[0] : ""
              , a = jp(o);
            a && (i = a.send)
        }
    }
    return !n || !i ? (r(void 0, 424),
    bw) : n.query(t, i, r)().abort
}
const ww = "iconify2"
  , qu = "iconify"
  , U6 = qu + "-count"
  , vw = qu + "-version"
  , z6 = 36e5
  , Xz = 168;
function Up(e, t) {
    try {
        return e.getItem(t)
    } catch {}
}
function Fm(e, t, r) {
    try {
        return e.setItem(t, r),
        !0
    } catch {}
}
function xw(e, t) {
    try {
        e.removeItem(t)
    } catch {}
}
function zp(e, t) {
    return Fm(e, U6, t.toString())
}
function $p(e) {
    return parseInt(Up(e, U6)) || 0
}
const xd = {
    local: !0,
    session: !0
}
  , $6 = {
    local: new Set,
    session: new Set
};
let Hm = !1;
function e$(e) {
    Hm = e
}
let sl = typeof window > "u" ? {} : window;
function F6(e) {
    const t = e + "Storage";
    try {
        if (sl && sl[t] && typeof sl[t].length == "number")
            return sl[t]
    } catch {}
    xd[e] = !1
}
function H6(e, t) {
    const r = F6(e);
    if (!r)
        return;
    const n = Up(r, vw);
    if (n !== ww) {
        if (n) {
            const a = $p(r);
            for (let u = 0; u < a; u++)
                xw(r, qu + u.toString())
        }
        Fm(r, vw, ww),
        zp(r, 0);
        return
    }
    const i = Math.floor(Date.now() / z6) - Xz
      , s = a => {
        const u = qu + a.toString()
          , c = Up(r, u);
        if (typeof c == "string") {
            try {
                const l = JSON.parse(c);
                if (typeof l == "object" && typeof l.cached == "number" && l.cached > i && typeof l.provider == "string" && typeof l.data == "object" && typeof l.data.prefix == "string" && t(l, a))
                    return !0
            } catch {}
            xw(r, u)
        }
    }
    ;
    let o = $p(r);
    for (let a = o - 1; a >= 0; a--)
        s(a) || (a === o - 1 ? (o--,
        zp(r, o)) : $6[e].add(a))
}
function q6() {
    if (!Hm) {
        e$(!0);
        for (const e in xd)
            H6(e, t => {
                const r = t.data
                  , n = t.provider
                  , i = r.prefix
                  , s = Qs(n, i);
                if (!Dm(s, r).length)
                    return !1;
                const o = r.lastModified || -1;
                return s.lastModifiedCached = s.lastModifiedCached ? Math.min(s.lastModifiedCached, o) : o,
                !0
            }
            )
    }
}
function t$(e, t) {
    const r = e.lastModifiedCached;
    if (r && r >= t)
        return r === t;
    if (e.lastModifiedCached = t,
    r)
        for (const n in xd)
            H6(n, i => {
                const s = i.data;
                return i.provider !== e.provider || s.prefix !== e.prefix || s.lastModified === t
            }
            );
    return !0
}
function r$(e, t) {
    Hm || q6();
    function r(n) {
        let i;
        if (!xd[n] || !(i = F6(n)))
            return;
        const s = $6[n];
        let o;
        if (s.size)
            s.delete(o = Array.from(s).shift());
        else if (o = $p(i),
        !zp(i, o + 1))
            return;
        const a = {
            cached: Math.floor(Date.now() / z6),
            provider: e.provider,
            data: t
        };
        return Fm(i, qu + o.toString(), JSON.stringify(a))
    }
    t.lastModified && !t$(e, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t),
    delete t.not_found),
    r("local") || r("session"))
}
function Ew() {}
function n$(e) {
    e.iconsLoaderFlag || (e.iconsLoaderFlag = !0,
    setTimeout( () => {
        e.iconsLoaderFlag = !1,
        Wz(e)
    }
    ))
}
function i$(e, t) {
    e.iconsToLoad ? e.iconsToLoad = e.iconsToLoad.concat(t).sort() : e.iconsToLoad = t,
    e.iconsQueueFlag || (e.iconsQueueFlag = !0,
    setTimeout( () => {
        e.iconsQueueFlag = !1;
        const {provider: r, prefix: n} = e
          , i = e.iconsToLoad;
        delete e.iconsToLoad;
        let s;
        if (!i || !(s = jp(r)))
            return;
        s.prepare(r, n, i).forEach(a => {
            Jz(r, a, u => {
                if (typeof u != "object")
                    a.icons.forEach(c => {
                        e.missing.add(c)
                    }
                    );
                else
                    try {
                        const c = Dm(e, u);
                        if (!c.length)
                            return;
                        const l = e.pendingIcons;
                        l && c.forEach(p => {
                            l.delete(p)
                        }
                        ),
                        r$(e, u)
                    } catch (c) {
                        console.error(c)
                    }
                n$(e)
            }
            )
        }
        )
    }
    ))
}
const s$ = (e, t) => {
    const r = Gz(e, !0, P6())
      , n = qz(r);
    if (!n.pending.length) {
        let u = !0;
        return t && setTimeout( () => {
            u && t(n.loaded, n.missing, n.pending, Ew)
        }
        ),
        () => {
            u = !1
        }
    }
    const i = Object.create(null)
      , s = [];
    let o, a;
    return n.pending.forEach(u => {
        const {provider: c, prefix: l} = u;
        if (l === a && c === o)
            return;
        o = c,
        a = l,
        s.push(Qs(c, l));
        const p = i[c] || (i[c] = Object.create(null));
        p[l] || (p[l] = [])
    }
    ),
    n.pending.forEach(u => {
        const {provider: c, prefix: l, name: p} = u
          , h = Qs(c, l)
          , g = h.pendingIcons || (h.pendingIcons = new Set);
        g.has(p) || (g.add(p),
        i[c][l].push(p))
    }
    ),
    s.forEach(u => {
        const {provider: c, prefix: l} = u;
        i[c][l].length && i$(u, i[c][l])
    }
    ),
    t ? Kz(t, n, s) : Ew
}
  , o$ = e => new Promise( (t, r) => {
    const n = typeof e == "string" ? vd(e, !0) : e;
    if (!n) {
        r(e);
        return
    }
    s$([n || e], i => {
        if (i.length && n) {
            const s = Lz(n);
            if (s) {
                t({
                    ...jm,
                    ...s
                });
                return
            }
        }
        r(e)
    }
    )
}
);
({
    ...Bz
});
const Sw = {
    backgroundColor: "currentColor"
}
  , a$ = {
    backgroundColor: "transparent"
}
  , _w = {
    Image: "var(--svg)",
    Repeat: "no-repeat",
    Size: "100% 100%"
}
  , Aw = {
    webkitMask: Sw,
    mask: Sw,
    background: a$
};
for (const e in Aw) {
    const t = Aw[e];
    for (const r in _w)
        t[e + r] = _w[r]
}
const G0 = {};
["horizontal", "vertical"].forEach(e => {
    const t = e.slice(0, 1) + "Flip";
    G0[e + "-flip"] = t,
    G0[e.slice(0, 1) + "-flip"] = t,
    G0[e + "Flip"] = t
}
);
P6(!0);
Pz("", Hz);
if (typeof document < "u" && typeof window < "u") {
    q6();
    const e = window;
    if (e.IconifyPreload !== void 0) {
        const t = e.IconifyPreload
          , r = "Invalid IconifyPreload syntax.";
        typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach(n => {
            try {
                (typeof n != "object" || n === null || n instanceof Array || typeof n.icons != "object" || typeof n.prefix != "string" || !Nz(n)) && console.error(r)
            } catch {
                console.error(r)
            }
        }
        )
    }
    if (e.IconifyProviders !== void 0) {
        const t = e.IconifyProviders;
        if (typeof t == "object" && t !== null)
            for (let r in t) {
                const n = "IconifyProviders[" + r + "] is invalid.";
                try {
                    const i = t[r];
                    if (typeof i != "object" || !i || i.resources === void 0)
                        continue;
                    Dp(r, i) || console.error(n)
                } catch {
                    console.error(n)
                }
            }
    }
}
({
    ...jm
});
const u$ = ["fluent-emoji-high-contrast", "material-symbols-light", "cryptocurrency-color", "icon-park-outline", "icon-park-twotone", "fluent-emoji-flat", "emojione-monotone", "streamline-emojis", "heroicons-outline", "simple-line-icons", "material-symbols", "flat-color-icons", "icon-park-solid", "pepicons-pencil", "heroicons-solid", "pepicons-print", "cryptocurrency", "pixelarticons", "system-uicons", "bitcoin-icons", "devicon-plain", "entypo-social", "token-branded", "grommet-icons", "vscode-icons", "pepicons-pop", "svg-spinners", "fluent-emoji", "simple-icons", "circle-flags", "medical-icon", "icomoon-free", "majesticons", "radix-icons", "humbleicons", "fa6-regular", "emojione-v1", "skill-icons", "academicons", "healthicons", "fluent-mdl2", "teenyicons", "ant-design", "gravity-ui", "akar-icons", "lets-icons", "streamline", "fa6-brands", "file-icons", "game-icons", "foundation", "fa-regular", "mono-icons", "iconamoon", "zondicons", "mdi-light", "eos-icons", "gridicons", "icon-park", "heroicons", "fa6-solid", "meteocons", "arcticons", "dashicons", "fa-brands", "websymbol", "fontelico", "mingcute", "flowbite", "marketeq", "bytesize", "guidance", "openmoji", "emojione", "nonicons", "brandico", "flagpack", "fa-solid", "fontisto", "si-glyph", "pepicons", "iconoir", "tdesign", "clarity", "octicon", "codicon", "pajamas", "formkit", "line-md", "twemoji", "noto-v1", "fxemoji", "devicon", "raphael", "flat-ui", "topcoat", "feather", "tabler", "carbon", "lucide", "memory", "mynaui", "circum", "fluent", "nimbus", "entypo", "icons8", "subway", "vaadin", "solar", "basil", "typcn", "charm", "prime", "quill", "logos", "token", "covid", "maki", "gala", "mage", "ooui", "noto", "unjs", "flag", "iwwa", "zmdi", "bpmn", "mdi", "ion", "uil", "bxs", "cil", "uiw", "uim", "uit", "uis", "jam", "oui", "bxl", "cib", "cbi", "cif", "gis", "map", "geo", "fad", "eva", "wpf", "whh", "ic", "ph", "ri", "bi", "bx", "gg", "ci", "ep", "fe", "mi", "f7", "ei", "wi", "la", "fa", "oi", "et", "el", "ls", "vs", "il", "ps"];
function c$(e="") {
    let t, r = "";
    if (e[0] === "@" && e.includes(":") && (r = e.split(":")[0].slice(1),
    e = e.split(":").slice(1).join(":")),
    e.startsWith("i-")) {
        e = e.replace(/^i-/, "");
        for (const n of u$)
            if (e.startsWith(n)) {
                t = n,
                e = e.slice(n.length + 1);
                break
            }
    } else if (e.includes(":")) {
        const [n,i] = e.split(":");
        t = n,
        e = i
    }
    return {
        provider: r,
        prefix: t || "",
        name: e || ""
    }
}
const l$ = lr({
    __name: "Icon",
    props: {
        name: {
            type: String,
            required: !0
        },
        size: {
            type: String,
            default: ""
        }
    },
    async setup(e) {
        let t, r;
        const n = ut()
          , i = fa()
          , s = e;
        vt( () => {
            var v;
            return (v = i.nuxtIcon) == null ? void 0 : v.iconifyApiOptions
        }
        , () => {
            var v, I, M, A, k, L;
            if ((I = (v = i.nuxtIcon) == null ? void 0 : v.iconifyApiOptions) != null && I.url) {
                try {
                    new URL(i.nuxtIcon.iconifyApiOptions.url)
                } catch {
                    console.warn("Nuxt Icon: Invalid custom Iconify API URL");
                    return
                }
                if ((A = (M = i.nuxtIcon) == null ? void 0 : M.iconifyApiOptions) != null && A.publicApiFallback) {
                    Dp("custom", {
                        resources: [(k = i.nuxtIcon) == null ? void 0 : k.iconifyApiOptions.url],
                        index: 0
                    });
                    return
                }
                Dp("", {
                    resources: [(L = i.nuxtIcon) == null ? void 0 : L.iconifyApiOptions.url]
                })
            }
        }
        , {
            immediate: !0
        });
        const o = da("icons", () => ({}))
          , a = Ue(!1)
          , u = Se( () => {
            var v, I;
            return (I = (v = i.nuxtIcon) == null ? void 0 : v.aliases) != null && I[s.name] ? i.nuxtIcon.aliases[s.name] : s.name
        }
        )
          , c = Se( () => c$(u.value))
          , l = Se( () => [c.value.provider, c.value.prefix, c.value.name].filter(Boolean).join(":"))
          , p = Se( () => {
            var v;
            return (v = o.value) == null ? void 0 : v[l.value]
        }
        )
          , h = Se( () => {
            var v;
            return (v = n.vueApp) == null ? void 0 : v.component(u.value)
        }
        )
          , g = Se( () => {
            var I, M, A;
            if (!s.size && typeof ((I = i.nuxtIcon) == null ? void 0 : I.size) == "boolean" && !((M = i.nuxtIcon) != null && M.size))
                return;
            const v = s.size || ((A = i.nuxtIcon) == null ? void 0 : A.size) || "1em";
            return String(Number(v)) === v ? `${v}px` : v
        }
        )
          , S = Se( () => {
            var v;
            return ((v = i == null ? void 0 : i.nuxtIcon) == null ? void 0 : v.class) ?? "icon"
        }
        );
        async function x() {
            var v;
            h.value || (v = o.value) != null && v[l.value] || (a.value = !0,
            o.value[l.value] = await o$(c.value).catch( () => {}
            ),
            a.value = !1)
        }
        return vt(u, x),
        !h.value && ([t,r] = SS( () => x()),
        t = await t,
        r()),
        (v, I) => a.value ? (je(),
        Wt("span", {
            key: 0,
            class: ot(S.value),
            style: zs({
                width: g.value,
                height: g.value
            })
        }, null, 6)) : p.value ? (je(),
        yt(ct(_z), {
            key: 1,
            icon: p.value,
            class: ot(S.value),
            width: g.value,
            height: g.value
        }, null, 8, ["icon", "class", "width", "height"])) : h.value ? (je(),
        yt(Nf(h.value), {
            key: 2,
            class: ot(S.value),
            width: g.value,
            height: g.value
        }, null, 8, ["class", "width", "height"])) : (je(),
        Wt("span", {
            key: 3,
            class: ot(S.value),
            style: zs({
                fontSize: g.value,
                lineHeight: g.value,
                width: g.value,
                height: g.value
            })
        }, [$n(v.$slots, "default", {}, () => [uu(Ns(e.name), 1)], !0)], 6))
    }
})
  , us = (e, t) => {
    const r = e.__vccOpts || e;
    for (const [n,i] of t)
        r[n] = i;
    return r
}
  , W6 = us(l$, [["__scopeId", "data-v-2438d50f"]])
  , f$ = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: W6
}, Symbol.toStringTag, {
    value: "Module"
}))
  , d$ = lr({
    props: {
        name: {
            type: String,
            required: !0
        },
        dynamic: {
            type: Boolean,
            default: !1
        }
    },
    setup(e) {
        const t = fa();
        return {
            dynamic: Se( () => {
                var n, i;
                return e.dynamic || ((i = (n = t.ui) == null ? void 0 : n.icons) == null ? void 0 : i.dynamic)
            }
            )
        }
    }
});
function h$(e, t, r, n, i, s) {
    const o = W6;
    return e.dynamic ? (je(),
    yt(o, {
        key: 0,
        name: e.name
    }, null, 8, ["name"])) : (je(),
    Wt("span", {
        key: 1,
        class: ot(e.name)
    }, null, 2))
}
const xa = us(d$, [["render", h$]])
  , Ed = (e, t, r, n, i=!1) => {
    const s = ES()
      , o = fa()
      , a = Se( () => {
        var h;
        const c = Vd(t)
          , l = Vd(r)
          , p = Vd(n);
        return nc((c == null ? void 0 : c.strategy) || ((h = o.ui) == null ? void 0 : h.strategy), p ? {
            wrapper: p
        } : {}, c || {}, i ? VT(o.ui, e, {}) : {}, l || {})
    }
    )
      , u = Se( () => WT(s, ["class"]));
    return {
        ui: a,
        attrs: u
    }
}
  , p$ = {
    wrapper: "relative inline-flex items-center justify-center flex-shrink-0",
    background: "bg-gray-100 dark:bg-gray-800",
    rounded: "rounded-full",
    text: "font-medium leading-none text-gray-900 dark:text-white truncate",
    placeholder: "font-medium leading-none text-gray-500 dark:text-gray-400 truncate",
    size: {
        "3xs": "h-4 w-4 text-[8px]",
        "2xs": "h-5 w-5 text-[10px]",
        xs: "h-6 w-6 text-xs",
        sm: "h-8 w-8 text-sm",
        md: "h-10 w-10 text-base",
        lg: "h-12 w-12 text-lg",
        xl: "h-14 w-14 text-xl",
        "2xl": "h-16 w-16 text-2xl",
        "3xl": "h-20 w-20 text-3xl"
    },
    chip: {
        base: "absolute rounded-full ring-1 ring-white dark:ring-gray-900 flex items-center justify-center text-white dark:text-gray-900 font-medium",
        background: "bg-{color}-500 dark:bg-{color}-400",
        position: {
            "top-right": "top-0 right-0",
            "bottom-right": "bottom-0 right-0",
            "top-left": "top-0 left-0",
            "bottom-left": "bottom-0 left-0"
        },
        size: {
            "3xs": "h-[4px] min-w-[4px] text-[4px] p-px",
            "2xs": "h-[5px] min-w-[5px] text-[5px] p-px",
            xs: "h-1.5 min-w-[0.375rem] text-[6px] p-px",
            sm: "h-2 min-w-[0.5rem] text-[7px] p-0.5",
            md: "h-2.5 min-w-[0.625rem] text-[8px] p-0.5",
            lg: "h-3 min-w-[0.75rem] text-[10px] p-0.5",
            xl: "h-3.5 min-w-[0.875rem] text-[11px] p-1",
            "2xl": "h-4 min-w-[1rem] text-[12px] p-1",
            "3xl": "h-5 min-w-[1.25rem] text-[14px] p-1"
        }
    },
    icon: {
        base: "text-gray-500 dark:text-gray-400 flex-shrink-0",
        size: {
            "3xs": "h-2 w-2",
            "2xs": "h-2.5 w-2.5",
            xs: "h-3 w-3",
            sm: "h-4 w-4",
            md: "h-5 w-5",
            lg: "h-6 w-6",
            xl: "h-7 w-7",
            "2xl": "h-8 w-8",
            "3xl": "h-10 w-10"
        }
    },
    default: {
        size: "sm",
        icon: null,
        chipColor: null,
        chipPosition: "top-right"
    }
}
  , g$ = {
    base: "focus:outline-none focus-visible:outline-0 disabled:cursor-not-allowed disabled:opacity-75 flex-shrink-0",
    font: "font-medium",
    rounded: "rounded-md",
    truncate: "text-left break-all line-clamp-1",
    block: "w-full flex justify-center items-center",
    inline: "inline-flex items-center",
    size: {
        "2xs": "text-xs",
        xs: "text-xs",
        sm: "text-sm",
        md: "text-sm",
        lg: "text-sm",
        xl: "text-base"
    },
    gap: {
        "2xs": "gap-x-1",
        xs: "gap-x-1.5",
        sm: "gap-x-1.5",
        md: "gap-x-2",
        lg: "gap-x-2.5",
        xl: "gap-x-2.5"
    },
    padding: {
        "2xs": "px-2 py-1",
        xs: "px-2.5 py-1.5",
        sm: "px-2.5 py-1.5",
        md: "px-3 py-2",
        lg: "px-3.5 py-2.5",
        xl: "px-3.5 py-2.5"
    },
    square: {
        "2xs": "p-1",
        xs: "p-1.5",
        sm: "p-1.5",
        md: "p-2",
        lg: "p-2.5",
        xl: "p-2.5"
    },
    color: {
        white: {
            solid: "shadow-sm ring-1 ring-inset ring-gray-300 dark:ring-gray-700 text-gray-900 dark:text-white bg-white hover:bg-gray-50 disabled:bg-white dark:bg-gray-900 dark:hover:bg-gray-800/50 dark:disabled:bg-gray-900 focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400",
            ghost: "text-gray-900 dark:text-white hover:bg-white dark:hover:bg-gray-900 focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400"
        },
        gray: {
            solid: "shadow-sm ring-1 ring-inset ring-gray-300 dark:ring-gray-700 text-gray-700 dark:text-gray-200 bg-gray-50 hover:bg-gray-100 disabled:bg-gray-50 dark:bg-gray-800 dark:hover:bg-gray-700/50 dark:disabled:bg-gray-800 focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400",
            ghost: "text-gray-700 dark:text-gray-200 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-gray-800 focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400",
            link: "text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 underline-offset-4 hover:underline focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400"
        },
        black: {
            solid: "shadow-sm text-white dark:text-gray-900 bg-gray-900 hover:bg-gray-800 disabled:bg-gray-900 dark:bg-white dark:hover:bg-gray-100 dark:disabled:bg-white focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400",
            link: "text-gray-900 dark:text-white underline-offset-4 hover:underline focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-primary-500 dark:focus-visible:ring-primary-400"
        }
    },
    variant: {
        solid: "shadow-sm text-white dark:text-gray-900 bg-{color}-500 hover:bg-{color}-600 disabled:bg-{color}-500 dark:bg-{color}-400 dark:hover:bg-{color}-500 dark:disabled:bg-{color}-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-{color}-500 dark:focus-visible:outline-{color}-400",
        outline: "ring-1 ring-inset ring-current text-{color}-500 dark:text-{color}-400 hover:bg-{color}-50 disabled:bg-transparent dark:hover:bg-{color}-950 dark:disabled:bg-transparent focus-visible:ring-2 focus-visible:ring-{color}-500 dark:focus-visible:ring-{color}-400",
        soft: "text-{color}-500 dark:text-{color}-400 bg-{color}-50 hover:bg-{color}-100 disabled:bg-{color}-50 dark:bg-{color}-950 dark:hover:bg-{color}-900 dark:disabled:bg-{color}-950 focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-{color}-500 dark:focus-visible:ring-{color}-400",
        ghost: "text-{color}-500 dark:text-{color}-400 hover:bg-{color}-50 disabled:bg-transparent dark:hover:bg-{color}-950 dark:disabled:bg-transparent focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-{color}-500 dark:focus-visible:ring-{color}-400",
        link: "text-{color}-500 hover:text-{color}-600 disabled:text-{color}-500 dark:text-{color}-400 dark:hover:text-{color}-500 dark:disabled:text-{color}-400 underline-offset-4 hover:underline focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-{color}-500 dark:focus-visible:ring-{color}-400"
    },
    icon: {
        base: "flex-shrink-0",
        loading: "animate-spin",
        size: {
            "2xs": "h-4 w-4",
            xs: "h-4 w-4",
            sm: "h-5 w-5",
            md: "h-5 w-5",
            lg: "h-5 w-5",
            xl: "h-6 w-6"
        }
    },
    default: {
        size: "sm",
        variant: "solid",
        color: "primary",
        loadingIcon: "i-heroicons-arrow-path-20-solid"
    }
}
  , Sd = {
    base: "invisible before:visible before:block before:rotate-45 before:z-[-1] before:w-2 before:h-2",
    ring: "before:ring-1 before:ring-gray-200 dark:before:ring-gray-800",
    rounded: "before:rounded-sm",
    background: "before:bg-gray-200 dark:before:bg-gray-800",
    shadow: "before:shadow",
    placement: "group-data-[popper-placement*='right']:-left-1 group-data-[popper-placement*='left']:-right-1 group-data-[popper-placement*='top']:-bottom-1 group-data-[popper-placement*='bottom']:-top-1"
};
({
    ...Sd
});
const V6 = {
    wrapper: "relative",
    base: "relative block w-full disabled:cursor-not-allowed disabled:opacity-75 focus:outline-none border-0",
    form: "form-input",
    rounded: "rounded-md",
    placeholder: "placeholder-gray-400 dark:placeholder-gray-500",
    file: {
        base: "file:mr-1.5 file:font-medium file:text-gray-500 dark:file:text-gray-400 file:bg-transparent file:border-0 file:p-0 file:outline-none"
    },
    size: {
        "2xs": "text-xs",
        xs: "text-xs",
        sm: "text-sm",
        md: "text-sm",
        lg: "text-sm",
        xl: "text-base"
    },
    gap: {
        "2xs": "gap-x-1",
        xs: "gap-x-1.5",
        sm: "gap-x-1.5",
        md: "gap-x-2",
        lg: "gap-x-2.5",
        xl: "gap-x-2.5"
    },
    padding: {
        "2xs": "px-2 py-1",
        xs: "px-2.5 py-1.5",
        sm: "px-2.5 py-1.5",
        md: "px-3 py-2",
        lg: "px-3.5 py-2.5",
        xl: "px-3.5 py-2.5"
    },
    leading: {
        padding: {
            "2xs": "ps-7",
            xs: "ps-8",
            sm: "ps-9",
            md: "ps-10",
            lg: "ps-11",
            xl: "ps-12"
        }
    },
    trailing: {
        padding: {
            "2xs": "pe-7",
            xs: "pe-8",
            sm: "pe-9",
            md: "pe-10",
            lg: "pe-11",
            xl: "pe-12"
        }
    },
    color: {
        white: {
            outline: "shadow-sm bg-white dark:bg-gray-900 text-gray-900 dark:text-white ring-1 ring-inset ring-gray-300 dark:ring-gray-700 focus:ring-2 focus:ring-primary-500 dark:focus:ring-primary-400"
        },
        gray: {
            outline: "shadow-sm bg-gray-50 dark:bg-gray-800 text-gray-900 dark:text-white ring-1 ring-inset ring-gray-300 dark:ring-gray-700 focus:ring-2 focus:ring-primary-500 dark:focus:ring-primary-400"
        }
    },
    variant: {
        outline: "shadow-sm bg-transparent text-gray-900 dark:text-white ring-1 ring-inset ring-{color}-500 dark:ring-{color}-400 focus:ring-2 focus:ring-{color}-500 dark:focus:ring-{color}-400",
        none: "bg-transparent focus:ring-0 focus:shadow-none"
    },
    icon: {
        base: "flex-shrink-0 text-gray-400 dark:text-gray-500",
        color: "text-{color}-500 dark:text-{color}-400",
        loading: "animate-spin",
        size: {
            "2xs": "h-4 w-4",
            xs: "h-4 w-4",
            sm: "h-5 w-5",
            md: "h-5 w-5",
            lg: "h-5 w-5",
            xl: "h-6 w-6"
        },
        leading: {
            wrapper: "absolute inset-y-0 start-0 flex items-center",
            pointer: "pointer-events-none",
            padding: {
                "2xs": "px-2",
                xs: "px-2.5",
                sm: "px-2.5",
                md: "px-3",
                lg: "px-3.5",
                xl: "px-3.5"
            }
        },
        trailing: {
            wrapper: "absolute inset-y-0 end-0 flex items-center",
            pointer: "pointer-events-none",
            padding: {
                "2xs": "px-2",
                xs: "px-2.5",
                sm: "px-2.5",
                md: "px-3",
                lg: "px-3.5",
                xl: "px-3.5"
            }
        }
    },
    default: {
        size: "sm",
        color: "white",
        variant: "outline",
        loadingIcon: "i-heroicons-arrow-path-20-solid"
    }
}
  , Mw = {
    container: "z-20 group",
    trigger: "flex items-center w-full",
    width: "w-full",
    height: "max-h-60",
    base: "relative focus:outline-none overflow-y-auto scroll-py-1",
    background: "bg-white dark:bg-gray-800",
    shadow: "shadow-lg",
    rounded: "rounded-md",
    padding: "p-1",
    ring: "ring-1 ring-gray-200 dark:ring-gray-700",
    empty: "text-sm text-gray-400 dark:text-gray-500 px-2 py-1.5",
    option: {
        base: "cursor-default select-none relative flex items-center justify-between gap-1",
        rounded: "rounded-md",
        padding: "px-1.5 py-1.5",
        size: "text-sm",
        color: "text-gray-900 dark:text-white",
        container: "flex items-center gap-1.5 min-w-0",
        active: "bg-gray-100 dark:bg-gray-900",
        inactive: "",
        selected: "pe-7",
        disabled: "cursor-not-allowed opacity-50",
        empty: "text-sm text-gray-400 dark:text-gray-500 px-2 py-1.5",
        icon: {
            base: "flex-shrink-0 h-5 w-5",
            active: "text-gray-900 dark:text-white",
            inactive: "text-gray-400 dark:text-gray-500"
        },
        selectedIcon: {
            wrapper: "absolute inset-y-0 end-0 flex items-center",
            padding: "pe-2",
            base: "h-5 w-5 text-gray-900 dark:text-white flex-shrink-0"
        },
        avatar: {
            base: "flex-shrink-0",
            size: "2xs"
        },
        chip: {
            base: "flex-shrink-0 w-2 h-2 mx-1 rounded-full"
        }
    },
    transition: {
        leaveActiveClass: "transition ease-in duration-100",
        leaveFromClass: "opacity-100",
        leaveToClass: "opacity-0"
    },
    popper: {
        placement: "bottom-end"
    },
    default: {
        selectedIcon: "i-heroicons-check-20-solid",
        trailingIcon: "i-heroicons-chevron-down-20-solid"
    },
    arrow: {
        ...Sd,
        ring: "before:ring-1 before:ring-gray-200 dark:before:ring-gray-700",
        background: "before:bg-white dark:before:bg-gray-700"
    }
};
({
    ...V6
});
({
    ...V6
});
({
    ...Mw,
    option: {
        ...Mw.option
    },
    arrow: {
        ...Sd
    }
});
({
    ...Sd
});
const m$ = {
    wrapper: "w-full pointer-events-auto",
    container: "relative overflow-hidden",
    inner: "w-0 flex-1",
    title: "text-sm font-medium text-gray-900 dark:text-white",
    description: "mt-1 text-sm leading-4 text-gray-500 dark:text-gray-400",
    actions: "flex items-center gap-2 mt-3 flex-shrink-0",
    background: "bg-white dark:bg-gray-900",
    shadow: "shadow-lg",
    rounded: "rounded-lg",
    padding: "p-4",
    gap: "gap-3",
    ring: "ring-1 ring-gray-200 dark:ring-gray-800",
    icon: {
        base: "flex-shrink-0 w-5 h-5",
        color: "text-{color}-500 dark:text-{color}-400"
    },
    avatar: {
        base: "flex-shrink-0 self-center",
        size: "md"
    },
    progress: {
        base: "absolute bottom-0 end-0 start-0 h-1",
        background: "bg-{color}-500 dark:bg-{color}-400"
    },
    transition: {
        enterActiveClass: "transform ease-out duration-300 transition",
        enterFromClass: "translate-y-2 opacity-0 sm:translate-y-0 sm:translate-x-2",
        enterToClass: "translate-y-0 opacity-100 sm:translate-x-0",
        leaveActiveClass: "transition ease-in duration-100",
        leaveFromClass: "opacity-100",
        leaveToClass: "opacity-0"
    },
    default: {
        color: "primary",
        icon: null,
        timeout: 5e3,
        closeButton: {
            icon: "i-heroicons-x-mark-20-solid",
            color: "gray",
            variant: "link",
            padded: !1
        },
        actionButton: {
            size: "xs",
            color: "white"
        }
    }
}
  , y$ = {
    wrapper: "fixed flex flex-col justify-end z-[55]",
    position: "bottom-0 end-0",
    width: "w-full sm:w-96",
    container: "px-4 sm:px-6 py-6 space-y-3 overflow-y-auto"
}
  , hs = nc(pn.ui.strategy, pn.ui.avatar, p$)
  , b$ = lr({
    components: {
        UIcon: xa
    },
    inheritAttrs: !1,
    props: {
        as: {
            type: [String, Object],
            default: "img"
        },
        src: {
            type: [String, Boolean],
            default: null
        },
        alt: {
            type: String,
            default: null
        },
        text: {
            type: String,
            default: null
        },
        icon: {
            type: String,
            default: () => hs.default.icon
        },
        size: {
            type: String,
            default: () => hs.default.size,
            validator(e) {
                return Object.keys(hs.size).includes(e)
            }
        },
        chipColor: {
            type: String,
            default: () => hs.default.chipColor,
            validator(e) {
                return ["gray", ...pn.ui.colors].includes(e)
            }
        },
        chipPosition: {
            type: String,
            default: () => hs.default.chipPosition,
            validator(e) {
                return Object.keys(hs.chip.position).includes(e)
            }
        },
        chipText: {
            type: [String, Number],
            default: null
        },
        imgClass: {
            type: String,
            default: ""
        },
        class: {
            type: [String, Object, Array],
            default: () => ""
        },
        ui: {
            type: Object,
            default: () => ({})
        }
    },
    setup(e) {
        const {ui: t, attrs: r} = Ed("avatar", Xs(e, "ui"), hs)
          , n = Se( () => typeof e.src == "boolean" ? null : e.src)
          , i = Se( () => (e.alt || "").split(" ").map(p => p.charAt(0)).join("").substring(0, 2))
          , s = Se( () => Ho(ln(t.value.wrapper, (c.value || !n.value) && t.value.background, t.value.rounded, t.value.size[e.size]), e.class))
          , o = Se( () => Ho(ln(t.value.rounded, t.value.size[e.size]), e.imgClass))
          , a = Se( () => ln(t.value.icon.base, t.value.icon.size[e.size]))
          , u = Se( () => ln(t.value.chip.base, t.value.chip.size[e.size], t.value.chip.position[e.chipPosition], t.value.chip.background.replaceAll("{color}", e.chipColor)))
          , c = Ue(!1);
        vt( () => e.src, () => {
            c.value && (c.value = !1)
        }
        );
        function l() {
            c.value = !0
        }
        return {
            ui: t,
            attrs: r,
            wrapperClass: s,
            imgClass: o,
            iconClass: a,
            chipClass: u,
            url: n,
            placeholder: i,
            error: c,
            onError: l
        }
    }
});
function w$(e, t, r, n, i, s) {
    const o = xa;
    return je(),
    Wt("span", {
        class: ot(e.wrapperClass)
    }, [e.url && !e.error ? (je(),
    yt(Nf(e.as), Sr({
        key: 0,
        class: e.imgClass,
        alt: e.alt,
        src: e.url
    }, e.attrs, {
        onError: e.onError
    }), null, 16, ["class", "alt", "src", "onError"])) : e.text ? (je(),
    Wt("span", {
        key: 1,
        class: ot(e.ui.text)
    }, Ns(e.text), 3)) : e.icon ? (je(),
    yt(o, {
        key: 2,
        name: e.icon,
        class: ot(e.iconClass)
    }, null, 8, ["name", "class"])) : e.placeholder ? (je(),
    Wt("span", {
        key: 3,
        class: ot(e.ui.placeholder)
    }, Ns(e.placeholder), 3)) : Er("", !0), e.chipColor ? (je(),
    Wt("span", {
        key: 4,
        class: ot(e.chipClass)
    }, Ns(e.chipText), 3)) : Er("", !0), $n(e.$slots, "default")], 2)
}
const K6 = us(b$, [["render", w$]])
  , v$ = lr({
    inheritAttrs: !1,
    props: {
        ...Tg,
        as: {
            type: String,
            default: "button"
        },
        type: {
            type: String,
            default: "button"
        },
        disabled: {
            type: Boolean,
            default: null
        },
        active: {
            type: Boolean,
            default: void 0
        },
        exact: {
            type: Boolean,
            default: !1
        },
        exactQuery: {
            type: Boolean,
            default: !1
        },
        exactHash: {
            type: Boolean,
            default: !1
        },
        inactiveClass: {
            type: String,
            default: void 0
        }
    },
    setup(e) {
        function t(r, n, {isActive: i, isExactActive: s}) {
            return e.exactQuery && !Z8(r.query, n.query) || e.exactHash && r.hash !== n.hash ? e.inactiveClass : e.exact && s || !e.exact && i ? e.activeClass : e.inactiveClass
        }
        return {
            resolveLinkClass: t
        }
    }
})
  , x$ = ["href", "aria-disabled", "role", "rel", "target", "onClick"];
function E$(e, t, r, n, i, s) {
    const o = QM;
    return e.to ? (je(),
    yt(o, Sr({
        key: 1
    }, e.$props, {
        custom: ""
    }), {
        default: qn( ({route: a, href: u, target: c, rel: l, navigate: p, isActive: h, isExactActive: g, isExternal: S}) => [zn("a", Sr(e.$attrs, {
            href: e.disabled ? void 0 : u,
            "aria-disabled": e.disabled ? "true" : void 0,
            role: e.disabled ? "link" : void 0,
            rel: l,
            target: c,
            class: e.active !== void 0 ? e.active ? e.activeClass : e.inactiveClass : e.resolveLinkClass(a, e._.provides[la] || e.$route, {
                isActive: h,
                isExactActive: g
            }),
            onClick: x => !S && !e.disabled && p(x)
        }), [$n(e.$slots, "default", Q0(Ul({
            isActive: e.active !== void 0 ? e.active : e.exact ? g : h
        })))], 16, x$)]),
        _: 3
    }, 16)) : (je(),
    yt(Nf(e.as), Sr({
        key: 0,
        type: e.type,
        disabled: e.disabled
    }, e.$attrs, {
        class: e.active ? e.activeClass : e.inactiveClass
    }), {
        default: qn( () => [$n(e.$slots, "default", Q0(Ul({
            isActive: e.active
        })))]),
        _: 3
    }, 16, ["type", "disabled", "class"]))
}
const G6 = us(v$, [["render", E$]]);
function S$({ui: e, props: t}) {
    const r = Gn();
    if (Zi("ButtonGroupContextConsumer", !0),
    Kt("ButtonGroupContextConsumer", !1))
        return {
            size: Se( () => t.size),
            rounded: Se( () => e.value.rounded)
        };
    let i = r.parent, s;
    for (; i && !s; ) {
        if (i.type.name === "ButtonGroup") {
            s = Kt(`group-${i.uid}`);
            break
        }
        i = i.parent
    }
    const o = Se( () => s == null ? void 0 : s.value.children.indexOf(r));
    return vi( () => {
        s == null || s.value.register(r)
    }
    ),
    ca( () => {
        s == null || s.value.unregister(r)
    }
    ),
    {
        size: Se( () => (s == null ? void 0 : s.value.size) || t.size),
        rounded: Se( () => !s || o.value === -1 ? e.value.rounded : s.value.children.length === 1 ? s.value.ui.rounded : o.value === 0 ? s.value.rounded.start : o.value === s.value.children.length - 1 ? s.value.rounded.end : "rounded-none")
    }
}
const ii = nc(pn.ui.strategy, pn.ui.button, g$)
  , _$ = lr({
    components: {
        UIcon: xa,
        ULink: G6
    },
    inheritAttrs: !1,
    props: {
        ...Tg,
        type: {
            type: String,
            default: "button"
        },
        block: {
            type: Boolean,
            default: !1
        },
        label: {
            type: String,
            default: null
        },
        loading: {
            type: Boolean,
            default: !1
        },
        disabled: {
            type: Boolean,
            default: !1
        },
        padded: {
            type: Boolean,
            default: !0
        },
        size: {
            type: String,
            default: () => ii.default.size,
            validator(e) {
                return Object.keys(ii.size).includes(e)
            }
        },
        color: {
            type: String,
            default: () => ii.default.color,
            validator(e) {
                return [...pn.ui.colors, ...Object.keys(ii.color)].includes(e)
            }
        },
        variant: {
            type: String,
            default: () => ii.default.variant,
            validator(e) {
                return [...Object.keys(ii.variant), ...Object.values(ii.color).flatMap(t => Object.keys(t))].includes(e)
            }
        },
        icon: {
            type: String,
            default: null
        },
        loadingIcon: {
            type: String,
            default: () => ii.default.loadingIcon
        },
        leadingIcon: {
            type: String,
            default: null
        },
        trailingIcon: {
            type: String,
            default: null
        },
        trailing: {
            type: Boolean,
            default: !1
        },
        leading: {
            type: Boolean,
            default: !1
        },
        square: {
            type: Boolean,
            default: !1
        },
        truncate: {
            type: Boolean,
            default: !1
        },
        class: {
            type: [String, Object, Array],
            default: () => ""
        },
        ui: {
            type: Object,
            default: () => ({})
        }
    },
    setup(e, {slots: t}) {
        const {ui: r, attrs: n} = Ed("button", Xs(e, "ui"), ii)
          , {size: i, rounded: s} = S$({
            ui: r,
            props: e
        })
          , o = Se( () => e.icon && e.leading || e.icon && !e.trailing || e.loading && !e.trailing || e.leadingIcon)
          , a = Se( () => e.icon && e.trailing || e.loading && e.trailing || e.trailingIcon)
          , u = Se( () => e.square || !t.default && !e.label)
          , c = Se( () => {
            var v, I;
            const x = ((I = (v = r.value.color) == null ? void 0 : v[e.color]) == null ? void 0 : I[e.variant]) || r.value.variant[e.variant];
            return Ho(ln(r.value.base, r.value.font, s.value, r.value.size[i.value], r.value.gap[i.value], e.padded && r.value[u.value ? "square" : "padding"][i.value], x == null ? void 0 : x.replaceAll("{color}", e.color), e.block ? r.value.block : r.value.inline), e.class)
        }
        )
          , l = Se( () => e.loading ? e.loadingIcon : e.leadingIcon || e.icon)
          , p = Se( () => e.loading && !o.value ? e.loadingIcon : e.trailingIcon || e.icon)
          , h = Se( () => ln(r.value.icon.base, r.value.icon.size[i.value], e.loading && r.value.icon.loading))
          , g = Se( () => ln(r.value.icon.base, r.value.icon.size[i.value], e.loading && !o.value && r.value.icon.loading))
          , S = Se( () => KT(e));
        return {
            ui: r,
            attrs: n,
            isLeading: o,
            isTrailing: a,
            isSquare: u,
            buttonClass: c,
            leadingIconName: l,
            trailingIconName: p,
            leadingIconClass: h,
            trailingIconClass: g,
            linkProps: S
        }
    }
});
function A$(e, t, r, n, i, s) {
    const o = xa
      , a = G6;
    return je(),
    yt(a, Sr({
        type: e.type,
        disabled: e.disabled || e.loading,
        class: e.buttonClass
    }, {
        ...e.linkProps,
        ...e.attrs
    }), {
        default: qn( () => [$n(e.$slots, "leading", {
            disabled: e.disabled,
            loading: e.loading
        }, () => [e.isLeading && e.leadingIconName ? (je(),
        yt(o, {
            key: 0,
            name: e.leadingIconName,
            class: ot(e.leadingIconClass),
            "aria-hidden": "true"
        }, null, 8, ["name", "class"])) : Er("", !0)]), $n(e.$slots, "default", {}, () => [e.label ? (je(),
        Wt("span", {
            key: 0,
            class: ot([e.truncate ? e.ui.truncate : ""])
        }, Ns(e.label), 3)) : Er("", !0)]), $n(e.$slots, "trailing", {
            disabled: e.disabled,
            loading: e.loading
        }, () => [e.isTrailing && e.trailingIconName ? (je(),
        yt(o, {
            key: 0,
            name: e.trailingIconName,
            class: ot(e.trailingIconClass),
            "aria-hidden": "true"
        }, null, 8, ["name", "class"])) : Er("", !0)])]),
        _: 3
    }, 16, ["type", "disabled", "class"])
}
const Q6 = us(_$, [["render", A$]]);
function M$(e, t, r) {
    let n = null;
    const {pause: i, resume: s, timestamp: o} = uT({
        ...r || {},
        controls: !0
    })
      , a = Ue(null)
      , u = Se( () => a.value ? t - (o.value - a.value) : 0);
    function c(...x) {
        n = setTimeout( () => {
            n = null,
            a.value = null,
            e(...x)
        }
        , u.value)
    }
    function l() {
        n && (clearTimeout(n),
        n = null)
    }
    function p() {
        a.value = Date.now(),
        c()
    }
    function h() {
        l(),
        i()
    }
    function g() {
        l(),
        i()
    }
    function S() {
        c(),
        s(),
        a.value = (a.value || 0) + (Date.now() - o.value)
    }
    return p(),
    {
        start: p,
        stop: h,
        pause: g,
        resume: S,
        remaining: u
    }
}
const Ba = nc(pn.ui.strategy, pn.ui.notification, m$)
  , I$ = lr({
    components: {
        UIcon: xa,
        UAvatar: K6,
        UButton: Q6
    },
    inheritAttrs: !1,
    props: {
        id: {
            type: [String, Number],
            required: !0
        },
        title: {
            type: String,
            default: null
        },
        description: {
            type: String,
            default: null
        },
        icon: {
            type: String,
            default: () => Ba.default.icon
        },
        avatar: {
            type: Object,
            default: null
        },
        closeButton: {
            type: Object,
            default: () => Ba.default.closeButton
        },
        timeout: {
            type: Number,
            default: () => Ba.default.timeout
        },
        actions: {
            type: Array,
            default: () => []
        },
        callback: {
            type: Function,
            default: null
        },
        color: {
            type: String,
            default: () => Ba.default.color,
            validator(e) {
                return ["gray", ...pn.ui.colors].includes(e)
            }
        },
        class: {
            type: [String, Object, Array],
            default: () => ""
        },
        ui: {
            type: Object,
            default: () => ({})
        }
    },
    emits: ["close"],
    setup(e, {emit: t}) {
        const {ui: r, attrs: n} = Ed("notification", Xs(e, "ui"), Ba);
        let i = null;
        const s = Ue(e.timeout)
          , o = Se( () => {
            var x;
            return Ho(ln(r.value.wrapper, (x = r.value.background) == null ? void 0 : x.replaceAll("{color}", e.color), r.value.rounded, r.value.shadow), e.class)
        }
        )
          , a = Se( () => {
            var x;
            return ln(r.value.progress.base, (x = r.value.progress.background) == null ? void 0 : x.replaceAll("{color}", e.color))
        }
        )
          , u = Se( () => ({
            width: `${s.value / e.timeout * 100 || 0}%`
        }))
          , c = Se( () => {
            var x;
            return ln(r.value.icon.base, (x = r.value.icon.color) == null ? void 0 : x.replaceAll("{color}", e.color))
        }
        );
        function l() {
            i && i.pause()
        }
        function p() {
            i && i.resume()
        }
        function h() {
            i && i.stop(),
            e.callback && e.callback(),
            t("close")
        }
        function g(x) {
            i && i.stop(),
            x.click && x.click(),
            t("close")
        }
        function S() {
            i && i.stop(),
            e.timeout && (i = M$( () => {
                h()
            }
            , e.timeout),
            Cn( () => {
                s.value = i.remaining.value
            }
            ))
        }
        return vt( () => e.timeout, S),
        vi(S),
        ca( () => {
            i && i.stop()
        }
        ),
        {
            ui: r,
            attrs: n,
            wrapperClass: o,
            progressClass: a,
            progressStyle: u,
            iconClass: c,
            onMouseover: l,
            onMouseleave: p,
            onClose: h,
            onAction: g,
            twMerge: Ho
        }
    }
});
function T$(e, t, r, n, i, s) {
    const o = xa
      , a = K6
      , u = Q6;
    return je(),
    yt(ec, Sr({
        appear: ""
    }, e.ui.transition), {
        default: qn( () => [zn("div", Sr({
            class: e.wrapperClass,
            role: "status"
        }, e.attrs, {
            onMouseover: t[0] || (t[0] = (...c) => e.onMouseover && e.onMouseover(...c)),
            onMouseleave: t[1] || (t[1] = (...c) => e.onMouseleave && e.onMouseleave(...c))
        }), [zn("div", {
            class: ot([e.ui.container, e.ui.rounded, e.ui.ring])
        }, [zn("div", {
            class: ot(["flex", [e.ui.padding, e.ui.gap, {
                "items-start": e.description || e.$slots.description,
                "items-center": !e.description && !e.$slots.description
            }]])
        }, [e.icon ? (je(),
        yt(o, {
            key: 0,
            name: e.icon,
            class: ot(e.iconClass)
        }, null, 8, ["name", "class"])) : Er("", !0), e.avatar ? (je(),
        yt(a, Sr({
            key: 1
        }, {
            size: e.ui.avatar.size,
            ...e.avatar
        }, {
            class: e.ui.avatar.base
        }), null, 16, ["class"])) : Er("", !0), zn("div", {
            class: ot(e.ui.inner)
        }, [e.title || e.$slots.title ? (je(),
        Wt("p", {
            key: 0,
            class: ot(e.ui.title)
        }, [$n(e.$slots, "title", {
            title: e.title
        }, () => [uu(Ns(e.title), 1)])], 2)) : Er("", !0), e.description || e.$slots.description ? (je(),
        Wt("p", {
            key: 1,
            class: ot(e.twMerge(e.ui.description, !(e.title && e.$slots.title) && "mt-0 leading-5"))
        }, [$n(e.$slots, "description", {
            description: e.description
        }, () => [uu(Ns(e.description), 1)])], 2)) : Er("", !0), (e.description || e.$slots.description) && e.actions.length ? (je(),
        Wt("div", {
            key: 2,
            class: ot(e.ui.actions)
        }, [(je(!0),
        Wt(tr, null, Pl(e.actions, (c, l) => (je(),
        yt(u, Sr({
            key: l
        }, {
            ...e.ui.default.actionButton || {},
            ...c
        }, {
            onClick: n0(p => e.onAction(c), ["stop"])
        }), null, 16, ["onClick"]))), 128))], 2)) : Er("", !0)], 2), e.closeButton || !e.description && !e.$slots.description && e.actions.length ? (je(),
        Wt("div", {
            key: 2,
            class: ot(e.twMerge(e.ui.actions, "mt-0"))
        }, [!e.description && !e.$slots.description && e.actions.length ? (je(!0),
        Wt(tr, {
            key: 0
        }, Pl(e.actions, (c, l) => (je(),
        yt(u, Sr({
            key: l
        }, {
            ...e.ui.default.actionButton || {},
            ...c
        }, {
            onClick: n0(p => e.onAction(c), ["stop"])
        }), null, 16, ["onClick"]))), 128)) : Er("", !0), e.closeButton ? (je(),
        yt(u, Sr({
            key: 1,
            "aria-label": "Close"
        }, {
            ...e.ui.default.closeButton || {},
            ...e.closeButton
        }, {
            onClick: n0(e.onClose, ["stop"])
        }), null, 16, ["onClick"])) : Er("", !0)], 2)) : Er("", !0)], 2), e.timeout ? (je(),
        Wt("div", {
            key: 0,
            class: ot(e.progressClass),
            style: zs(e.progressStyle)
        }, null, 6)) : Er("", !0)], 2)], 16)]),
        _: 3
    }, 16)
}
const Y6 = us(I$, [["render", T$]]);
function C$() {
    const e = da("notifications", () => []);
    function t(s) {
        const o = {
            id: new Date().getTime().toString(),
            ...s
        };
        return e.value.findIndex(u => u.id === o.id) === -1 && e.value.push(o),
        o
    }
    function r(s) {
        e.value = e.value.filter(o => o.id !== s)
    }
    function n(s, o) {
        const a = e.value.findIndex(u => u.id === s);
        if (a !== -1) {
            const u = e.value[a];
            e.value.splice(a, 1, {
                ...u,
                ...o
            })
        }
    }
    function i() {
        e.value = []
    }
    return {
        add: t,
        remove: r,
        update: n,
        clear: i
    }
}
const k$ = nc(pn.ui.strategy, pn.ui.notifications, y$)
  , L$ = lr({
    components: {
        UNotification: Y6
    },
    inheritAttrs: !1,
    props: {
        class: {
            type: [String, Object, Array],
            default: () => ""
        },
        ui: {
            type: Object,
            default: () => ({})
        }
    },
    setup(e) {
        const {ui: t, attrs: r} = Ed("notifications", Xs(e, "ui"), k$)
          , n = C$()
          , i = da("notifications", () => [])
          , s = Se( () => Ho(ln(t.value.wrapper, t.value.position, t.value.width), e.class));
        return {
            ui: t,
            attrs: r,
            toast: n,
            notifications: i,
            wrapperClass: s
        }
    }
});
function O$(e, t, r, n, i, s) {
    const o = Y6;
    return je(),
    yt(WS, {
        to: "body"
    }, [zn("div", Sr({
        class: e.wrapperClass,
        role: "region"
    }, e.attrs), [e.notifications.length ? (je(),
    Wt("div", {
        key: 0,
        class: ot(e.ui.container)
    }, [(je(!0),
    Wt(tr, null, Pl(e.notifications, a => (je(),
    Wt("div", {
        key: a.id
    }, [at(o, Sr(a, {
        class: a.click && "cursor-pointer",
        onClick: u => a.click && a.click(a),
        onClose: u => e.toast.remove(a.id)
    }), vS({
        _: 2
    }, [Pl(e.$slots, (u, c) => ({
        name: c,
        fn: qn(l => [$n(e.$slots, c, Q0(Ul(l)))])
    }))]), 1040, ["class", "onClick", "onClose"])]))), 128))], 2)) : Er("", !0)], 16)])
}
const N$ = us(L$, [["render", O$]])
  , R$ = {}
  , B$ = {
    class: "notification-description"
};
function P$(e, t) {
    const r = N$
      , n = ZE("sanitize");
    return je(),
    yt(r, null, {
        description: qn( ({description: i}) => [uS(zn("span", B$, null, 512), [[n, i]])]),
        _: 1
    })
}
const j$ = us(R$, [["render", P$], ["__scopeId", "data-v-f27301fa"]])
  , D$ = lr({
    name: "LayoutLoader",
    inheritAttrs: !1,
    props: {
        name: String,
        layoutProps: Object
    },
    async setup(e, t) {
        const r = await Wi[e.name]().then(n => n.default || n);
        return () => cr(r, e.layoutProps, t.slots)
    }
})
  , Z6 = lr({
    name: "NuxtLayout",
    inheritAttrs: !1,
    props: {
        name: {
            type: [String, Boolean, Object],
            default: null
        },
        fallback: {
            type: [String, Object],
            default: null
        }
    },
    setup(e, t) {
        const r = ut()
          , n = Kt(la)
          , i = n === bg() ? xM() : n
          , s = Se( () => {
            let u = ct(e.name) ?? i.meta.layout ?? "default";
            return u && !(u in Wi) && e.fallback && (u = ct(e.fallback)),
            u
        }
        )
          , o = Ue();
        t.expose({
            layoutRef: o
        });
        const a = r.deferHydration();
        if (r.isHydrating) {
            const u = r.hooks.hookOnce("app:error", a);
            Ur().beforeEach(u)
        }
        return () => {
            const u = s.value && s.value in Wi
              , c = i.meta.layoutTransition ?? sA;
            return F2(ec, u && c, {
                default: () => cr(og, {
                    suspensible: !0,
                    onResolve: () => {
                        Kn(a)
                    }
                }, {
                    default: () => cr(U$, {
                        layoutProps: Sr(t.attrs, {
                            ref: o
                        }),
                        key: s.value || void 0,
                        name: s.value,
                        shouldProvide: !e.name,
                        hasTransition: !!c
                    }, t.slots)
                })
            }).default()
        }
    }
})
  , U$ = lr({
    name: "NuxtLayoutProvider",
    inheritAttrs: !1,
    props: {
        name: {
            type: [String, Boolean]
        },
        layoutProps: {
            type: Object
        },
        hasTransition: {
            type: Boolean
        },
        shouldProvide: {
            type: Boolean
        }
    },
    setup(e, t) {
        const r = e.name;
        return e.shouldProvide && Zi(l2, {
            isCurrent: n => r === (n.meta.layout ?? "default")
        }),
        () => {
            var n, i;
            return !r || typeof r == "string" && !(r in Wi) ? (i = (n = t.slots).default) == null ? void 0 : i.call(n) : cr(D$, {
                key: r,
                layoutProps: e.layoutProps,
                name: r
            }, t.slots)
        }
    }
})
  , z$ = {
    __name: "app",
    setup(e) {
        return (t, r) => {
            const n = ez
              , i = j$
              , s = Z6;
            return je(),
            Wt("div", null, [at(s, null, {
                default: qn( () => [at(n), at(i)]),
                _: 1
            })])
        }
    }
}
  , $$ = z$
  , F$ = {
    class: ""
}
  , H$ = {
    __name: "error",
    props: {
        error: Object
    },
    setup(e) {
        ov(e);
        async function r() {
            d2({
                redirect: "/"
            })
        }
        return (n, i) => {
            const s = Z6;
            return je(),
            Wt("div", F$, [at(s, null, {
                default: qn( () => [zn("button", {
                    onClick: i[0] || (i[0] = o => r())
                }, "Go Back Home")]),
                _: 1
            })])
        }
    }
}
  , q$ = H$
  , W$ = {
    __name: "nuxt-root",
    setup(e) {
        const t = () => null
          , r = ut()
          , n = r.deferHydration();
        if (r.isHydrating) {
            const a = r.hooks.hookOnce("app:error", n);
            Ur().beforeEach(a)
        }
        const i = !1;
        Zi(la, bg()),
        r.hooks.callHookWith(a => a.map(u => u()), "vue:setup");
        const s = $f();
        Sv( (a, u, c) => {
            if (r.hooks.callHook("vue:error", a, u, c).catch(l => console.error("[nuxt] Error in `vue:error` hook", l)),
            u5(a) && (a.fatal || a.unhandled))
                return r.runWithContext( () => ho(a)),
                !1
        }
        );
        const o = !1;
        return (a, u) => (je(),
        yt(og, {
            onResolve: ct(n)
        }, {
            default: qn( () => [ct(s) ? (je(),
            yt(ct(q$), {
                key: 0,
                error: ct(s)
            }, null, 8, ["error"])) : ct(o) ? (je(),
            yt(ct(t), {
                key: 1,
                context: ct(o)
            }, null, 8, ["context"])) : ct(i) ? (je(),
            yt(Nf(ct(i)), {
                key: 2
            })) : (je(),
            yt(ct($$), {
                key: 3
            }))]),
            _: 1
        }, 8, ["onResolve"]))
    }
}
  , Iw = W$;
let Tw;
{
    let e;
    Tw = async function() {
        var o, a;
        if (e)
            return e;
        const n = !!((o = window.__NUXT__) != null && o.serverRendered || ((a = document.getElementById("__NUXT_DATA__")) == null ? void 0 : a.dataset.ssr) === "true") ? k_(Iw) : C_(Iw)
          , i = B8({
            vueApp: n
        });
        async function s(u) {
            await i.callHook("app:error", u),
            i.payload.error = i.payload.error || Ff(u)
        }
        n.config.errorHandler = s;
        try {
            await j8(i, JU)
        } catch (u) {
            s(u)
        }
        try {
            await i.hooks.callHook("app:created", n),
            await i.hooks.callHook("app:beforeMount", n),
            n.mount(cA),
            await i.hooks.callHook("app:mounted", n),
            await Kn()
        } catch (u) {
            s(u)
        }
        return n.config.errorHandler === s && (n.config.errorHandler = void 0),
        n
    }
    ,
    e = Tw().catch(t => {
        throw console.error("Error while mounting app:", t),
        t
    }
    )
}
export {lF as $, yg as A, Ho as B, ln as C, Sr as D, $n as E, tr as F, ot as G, Er as H, vF as I, Zi as J, Q0 as K, Ns as L, Ul as M, yt as N, Pl as O, xF as P, K6 as Q, aF as R, C$ as S, bt as T, eF as U, uS as V, J$ as W, bg as X, ov as Y, a5 as Z, Q6 as _, zn as a, ql as a$, xM as a0, sF as a1, ns as a2, K$ as a3, gn as a4, Kn as a5, cF as a6, AF as a7, G$ as a8, Q$ as a9, QF as aA, YF as aB, Ts as aC, ZF as aD, QD as aE, mc as aF, SU as aG, Vn as aH, Yu as aI, wd as aJ, JF as aK, $u as aL, zU as aM, Mr as aN, cg as aO, WU as aP, Ge as aQ, rH as aR, Kp as aS, nH as aT, Cn as aU, Nf as aV, Y$ as aW, vS as aX, Mj as aY, QM as aZ, os as a_, ic as aa, Ke as ab, X$ as ac, pF as ad, bF as ae, mF as af, Ff as ag, fF as ah, ca as ai, Ur as aj, _F as ak, EF as al, SF as am, WC as an, Pr as ao, YI as ap, Z$ as aq, Hf as ar, x2 as as, nF as at, KC as au, Dr as av, uD as aw, sD as ax, PD as ay, YD as az, at as b, cr as b0, rF as b1, Be as b2, da as b3, iF as b4, gS as b5, ut as b6, Gn as b7, If as b8, n8 as b9, ke as bA, N9 as bB, B9 as bC, R9 as bD, P1 as ba, zf as bb, Df as bc, YE as bd, Do as be, Cr as bf, Fl as bg, Z8 as bh, zs as bi, gi as bj, oF as bk, WM as bl, wF as bm, fa as bn, c$ as bo, Sd as bp, WS as bq, Ss as br, ec as bs, hS as bt, cU as bu, Ne as bv, ta as bw, Mu as bx, mn as by, kg as bz, Wt as c, je as d, uu as e, xa as f, gF as g, yF as h, hF as i, vt as j, dF as k, Kt as l, Se as m, uF as n, vi as o, us as p, nc as q, Ue as r, V6 as s, pn as t, ct as u, lr as v, qn as w, Ed as x, Xs as y, S$ as z};
